(function (d, f, b) {
    var g = {version: "0.8-dev"};

    function a() {
        var j = d.L;
        g.noConflict = function () {
            d.L = j;
            return this
        };
        d.L = g
    }

    if (typeof module === "object" && typeof module.exports === "object") {
        module.exports = g
    } else {
        if (typeof define === "function" && define.amd) {
            define(g)
        } else {
            a()
        }
    }
    g.Util = {
        extend: function (m) {
            var n, l, k, o;
            for (l = 1, k = arguments.length; l < k; l++) {
                o = arguments[l];
                for (n in o) {
                    m[n] = o[n]
                }
            }
            return m
        }, create: Object.create || (function () {
            function j() {
            }

            return function (k) {
                j.prototype = k;
                return new j()
            }
        })(), bind: function (k, l) {
            var m = Array.prototype.slice;
            if (k.bind) {
                return k.bind.apply(k, m.call(arguments, 1))
            }
            var j = m.call(arguments, 2);
            return function () {
                return k.apply(l, j.length ? j.concat(m.call(arguments)) : arguments)
            }
        }, stamp: function (j) {
            j._leaflet_id = j._leaflet_id || ++g.Util.lastId;
            return j._leaflet_id
        }, lastId: 0, throttle: function (o, p, n) {
            var m, l, k, j;
            j = function () {
                m = false;
                if (l) {
                    k.apply(n, l);
                    l = false
                }
            };
            k = function () {
                if (m) {
                    l = arguments
                } else {
                    o.apply(n, arguments);
                    setTimeout(j, p);
                    m = true
                }
            };
            return k
        }, wrapNum: function (k, l, n) {
            var j = l[1], m = l[0], o = j - m;
            return k === j && n ? k : ((k - m) % o + o) % o + m
        }, falseFn: function () {
            return false
        }, formatNum: function (j, l) {
            var k = Math.pow(10, l || 5);
            return Math.round(j * k) / k
        }, trim: function (j) {
            return j.trim ? j.trim() : j.replace(/^\s+|\s+$/g, "")
        }, splitWords: function (j) {
            return g.Util.trim(j).split(/\s+/)
        }, setOptions: function (l, j) {
            if (!l.hasOwnProperty("options")) {
                l.options = l.options ? g.Util.create(l.options) : {}
            }
            for (var k in j) {
                l.options[k] = j[k]
            }
            return l.options
        }, getParamString: function (m, j, k) {
            var n = [];
            for (var l in m) {
                n.push(encodeURIComponent(k ? l.toUpperCase() : l) + "=" + encodeURIComponent(m[l]))
            }
            return ((!j || j.indexOf("?") === -1) ? "?" : "&") + n.join("&")
        }, template: function (k, j) {
            return k.replace(g.Util.templateRe, function (n, l) {
                var m = j[l];
                if (m === b) {
                    throw new Error("No value provided for variable " + n)
                } else {
                    if (typeof m === "function") {
                        m = m(j)
                    }
                }
                return m
            })
        }, templateRe: /\{ *([\w_]+) *\}/g, isArray: Array.isArray || function (j) {
            return (Object.prototype.toString.call(j) === "[object Array]")
        }, emptyImageUrl: "data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs="
    };
    (function () {
        function m(o) {
            return d["webkit" + o] || d["moz" + o] || d["ms" + o]
        }

        var n = 0;

        function k(o) {
            var q = +new Date(), p = Math.max(0, 16 - (q - n));
            n = q + p;
            return d.setTimeout(o, p)
        }

        var j = d.requestAnimationFrame || m("RequestAnimationFrame") || k, l = d.cancelAnimationFrame || m("CancelAnimationFrame") || m("CancelRequestAnimationFrame") || function (o) {
                d.clearTimeout(o)
            };
        g.Util.requestAnimFrame = function (q, p, o) {
            if (o && j === k) {
                q.call(p)
            } else {
                return j.call(d, g.bind(q, p))
            }
        };
        g.Util.cancelAnimFrame = function (o) {
            if (o) {
                l.call(d, o)
            }
        }
    })();
    g.extend = g.Util.extend;
    g.bind = g.Util.bind;
    g.stamp = g.Util.stamp;
    g.setOptions = g.Util.setOptions;
    g.Class = function () {
    };
    g.Class.extend = function (k) {
        var n = function () {
            if (this.initialize) {
                this.initialize.apply(this, arguments)
            }
            if (this._initHooks.length) {
                this.callInitHooks()
            }
        };
        var m = n.__super__ = this.prototype;
        var l = g.Util.create(m);
        l.constructor = n;
        n.prototype = l;
        for (var j in this) {
            if (this.hasOwnProperty(j) && j !== "prototype") {
                n[j] = this[j]
            }
        }
        if (k.statics) {
            g.extend(n, k.statics);
            delete k.statics
        }
        if (k.includes) {
            g.Util.extend.apply(null, [l].concat(k.includes));
            delete k.includes
        }
        if (l.options) {
            k.options = g.Util.extend(g.Util.create(l.options), k.options)
        }
        g.extend(l, k);
        l._initHooks = [];
        l.callInitHooks = function () {
            if (this._initHooksCalled) {
                return
            }
            if (m.callInitHooks) {
                m.callInitHooks.call(this)
            }
            this._initHooksCalled = true;
            for (var p = 0, o = l._initHooks.length; p < o; p++) {
                l._initHooks[p].call(this)
            }
        };
        return n
    };
    g.Class.include = function (j) {
        g.extend(this.prototype, j)
    };
    g.Class.mergeOptions = function (j) {
        g.extend(this.prototype.options, j)
    };
    g.Class.addInitHook = function (k) {
        var j = Array.prototype.slice.call(arguments, 1);
        var l = typeof k === "function" ? k : function () {
            this[k].apply(this, j)
        };
        this.prototype._initHooks = this.prototype._initHooks || [];
        this.prototype._initHooks.push(l)
    };
    g.Evented = g.Class.extend({
        on: function (m, o, l) {
            if (typeof m === "object") {
                for (var n in m) {
                    this._on(n, m[n], o)
                }
            } else {
                m = g.Util.splitWords(m);
                for (var k = 0, j = m.length; k < j; k++) {
                    this._on(m[k], o, l)
                }
            }
            return this
        }, off: function (m, o, l) {
            if (!m) {
                delete this._events
            } else {
                if (typeof m === "object") {
                    for (var n in m) {
                        this._off(n, m[n], o)
                    }
                } else {
                    m = g.Util.splitWords(m);
                    for (var k = 0, j = m.length; k < j; k++) {
                        this._off(m[k], o, l)
                    }
                }
            }
            return this
        }, _on: function (p, q, k) {
            var r = this._events = this._events || {}, m = k && k !== this && g.stamp(k);
            if (m) {
                var l = p + "_idx", o = p + "_len", n = r[l] = r[l] || {}, j = g.stamp(q) + "_" + m;
                if (!n[j]) {
                    n[j] = {fn: q, ctx: k};
                    r[o] = (r[o] || 0) + 1
                }
            } else {
                r[p] = r[p] || [];
                r[p].push({fn: q})
            }
        }, _off: function (r, t, k) {
            var u = this._events, n = r + "_idx", q = r + "_len";
            if (!u) {
                return
            }
            if (!t) {
                delete u[r];
                delete u[n];
                delete u[q];
                return
            }
            var o = k && k !== this && g.stamp(k), s, m, p, l, j;
            if (o) {
                j = g.stamp(t) + "_" + o;
                s = u[n];
                if (s && s[j]) {
                    l = s[j];
                    delete s[j];
                    u[q]--
                }
            } else {
                s = u[r];
                if (s) {
                    for (m = 0, p = s.length; m < p; m++) {
                        if (s[m].fn === t) {
                            l = s[m];
                            s.splice(m, 1);
                            break
                        }
                    }
                }
            }
            if (l) {
                l.fn = g.Util.falseFn
            }
        }, fire: function (r, l, n) {
            if (!this.listens(r, n)) {
                return this
            }
            var j = g.Util.extend({}, l, {type: r, target: this}), s = this._events;
            if (s) {
                var p = s[r + "_idx"], m, o, q, k;
                if (s[r]) {
                    q = s[r].slice();
                    for (m = 0, o = q.length; m < o; m++) {
                        q[m].fn.call(this, j)
                    }
                }
                for (k in p) {
                    p[k].fn.call(p[k].ctx, j)
                }
            }
            if (n) {
                this._propagateEvent(j)
            }
            return this
        }, listens: function (l, j) {
            var k = this._events;
            if (k && (k[l] || k[l + "_len"])) {
                return true
            }
            if (j) {
                for (var m in this._eventParents) {
                    if (this._eventParents[m].listens(l, j)) {
                        return true
                    }
                }
            }
            return false
        }, once: function (k, n, j) {
            if (typeof k === "object") {
                for (var m in k) {
                    this.once(m, k[m], n)
                }
                return this
            }
            var l = g.bind(function () {
                this.off(k, n, j).off(k, l, j)
            }, this);
            return this.on(k, n, j).on(k, l, j)
        }, addEventParent: function (j) {
            this._eventParents = this._eventParents || {};
            this._eventParents[g.stamp(j)] = j;
            return this
        }, removeEventParent: function (j) {
            if (this._eventParents) {
                delete this._eventParents[g.stamp(j)]
            }
            return this
        }, _propagateEvent: function (j) {
            for (var k in this._eventParents) {
                this._eventParents[k].fire(j.type, g.extend({layer: j.target}, j), true)
            }
        }
    });
    var c = g.Evented.prototype;
    c.addEventListener = c.on;
    c.removeEventListener = c.clearAllEventListeners = c.off;
    c.addOneTimeEventListener = c.once;
    c.fireEvent = c.fire;
    c.hasEventListeners = c.listens;
    g.Mixin = {Events: c};
    (function () {
        var m = navigator.userAgent.toLowerCase(), w = f.documentElement, l = "ActiveXObject" in d, x = m.indexOf("webkit") !== -1, z = m.indexOf("phantom") !== -1, v = m.search("android [23]") !== -1, s = m.indexOf("chrome") !== -1, n = typeof orientation !== "undefined", q = navigator.msPointerEnabled && navigator.msMaxTouchPoints && !d.PointerEvent, j = (d.PointerEvent && navigator.pointerEnabled && navigator.maxTouchPoints) || q, u = l && ("transition" in w.style), y = ("WebKitCSSMatrix" in d) && ("m11" in new d.WebKitCSSMatrix()) && !v, p = "MozPerspective" in w.style, k = "OTransition" in w.style;
        var o = "devicePixelRatio" in d && d.devicePixelRatio > 1;
        if (!o && "matchMedia" in d) {
            var t = d.matchMedia("(min-resolution:144dpi)");
            o = t && t.matches
        }
        var r = !d.L_NO_TOUCH && !z && (j || "ontouchstart" in d || (d.DocumentTouch && f instanceof d.DocumentTouch));
        g.Browser = {
            ie: l,
            ielt9: l && !f.addEventListener,
            webkit: x,
            gecko: (m.indexOf("gecko") !== -1) && !x && !d.opera && !l,
            android: m.indexOf("android") !== -1,
            android23: v,
            chrome: s,
            safari: !s && m.indexOf("safari") !== -1,
            ie3d: u,
            webkit3d: y,
            gecko3d: p,
            opera3d: k,
            any3d: !d.L_DISABLE_3D && (u || y || p || k) && !z,
            mobile: n,
            mobileWebkit: n && x,
            mobileWebkit3d: n && y,
            mobileOpera: n && d.opera,
            touch: !!r,
            msPointer: !!q,
            pointer: !!j,
            retina: !!o
        }
    }());
    g.Point = function (j, l, k) {
        this.x = (k ? Math.round(j) : j);
        this.y = (k ? Math.round(l) : l)
    };
    g.Point.prototype = {
        clone: function () {
            return new g.Point(this.x, this.y)
        }, add: function (j) {
            return this.clone()._add(g.point(j))
        }, _add: function (j) {
            this.x += j.x;
            this.y += j.y;
            return this
        }, subtract: function (j) {
            return this.clone()._subtract(g.point(j))
        }, _subtract: function (j) {
            this.x -= j.x;
            this.y -= j.y;
            return this
        }, divideBy: function (j) {
            return this.clone()._divideBy(j)
        }, _divideBy: function (j) {
            this.x /= j;
            this.y /= j;
            return this
        }, multiplyBy: function (j) {
            return this.clone()._multiplyBy(j)
        }, _multiplyBy: function (j) {
            this.x *= j;
            this.y *= j;
            return this
        }, round: function () {
            return this.clone()._round()
        }, _round: function () {
            this.x = Math.round(this.x);
            this.y = Math.round(this.y);
            return this
        }, floor: function () {
            return this.clone()._floor()
        }, _floor: function () {
            this.x = Math.floor(this.x);
            this.y = Math.floor(this.y);
            return this
        }, ceil: function () {
            return this.clone()._ceil()
        }, _ceil: function () {
            this.x = Math.ceil(this.x);
            this.y = Math.ceil(this.y);
            return this
        }, distanceTo: function (k) {
            k = g.point(k);
            var j = k.x - this.x, l = k.y - this.y;
            return Math.sqrt(j * j + l * l)
        }, equals: function (j) {
            j = g.point(j);
            return j.x === this.x && j.y === this.y
        }, contains: function (j) {
            j = g.point(j);
            return Math.abs(j.x) <= Math.abs(this.x) && Math.abs(j.y) <= Math.abs(this.y)
        }, toString: function () {
            return "Point(" + g.Util.formatNum(this.x) + ", " + g.Util.formatNum(this.y) + ")"
        }
    };
    g.point = function (j, l, k) {
        if (j instanceof g.Point) {
            return j
        }
        if (g.Util.isArray(j)) {
            return new g.Point(j[0], j[1])
        }
        if (j === b || j === null) {
            return j
        }
        return new g.Point(j, l, k)
    };
    g.Bounds = function (l, k) {
        if (!l) {
            return
        }
        var n = k ? [l, k] : l;
        for (var m = 0, j = n.length; m < j; m++) {
            this.extend(n[m])
        }
    };
    g.Bounds.prototype = {
        extend: function (j) {
            j = g.point(j);
            if (!this.min && !this.max) {
                this.min = j.clone();
                this.max = j.clone()
            } else {
                this.min.x = Math.min(j.x, this.min.x);
                this.max.x = Math.max(j.x, this.max.x);
                this.min.y = Math.min(j.y, this.min.y);
                this.max.y = Math.max(j.y, this.max.y)
            }
            return this
        }, getCenter: function (j) {
            return new g.Point((this.min.x + this.max.x) / 2, (this.min.y + this.max.y) / 2, j)
        }, getBottomLeft: function () {
            return new g.Point(this.min.x, this.max.y)
        }, getTopRight: function () {
            return new g.Point(this.max.x, this.min.y)
        }, getSize: function () {
            return this.max.subtract(this.min)
        }, contains: function (l) {
            var k, j;
            if (typeof l[0] === "number" || l instanceof g.Point) {
                l = g.point(l)
            } else {
                l = g.bounds(l)
            }
            if (l instanceof g.Bounds) {
                k = l.min;
                j = l.max
            } else {
                k = j = l
            }
            return (k.x >= this.min.x) && (j.x <= this.max.x) && (k.y >= this.min.y) && (j.y <= this.max.y)
        }, intersects: function (o) {
            o = g.bounds(o);
            var m = this.min, j = this.max, n = o.min, k = o.max, l = (k.x >= m.x) && (n.x <= j.x), p = (k.y >= m.y) && (n.y <= j.y);
            return l && p
        }, isValid: function () {
            return !!(this.min && this.max)
        }
    };
    g.bounds = function (k, j) {
        if (!k || k instanceof g.Bounds) {
            return k
        }
        return new g.Bounds(k, j)
    };
    g.Transformation = function (k, j, m, l) {
        this._a = k;
        this._b = j;
        this._c = m;
        this._d = l
    };
    g.Transformation.prototype = {
        transform: function (j, k) {
            return this._transform(j.clone(), k)
        }, _transform: function (j, k) {
            k = k || 1;
            j.x = k * (this._a * j.x + this._b);
            j.y = k * (this._c * j.y + this._d);
            return j
        }, untransform: function (j, k) {
            k = k || 1;
            return new g.Point((j.x / k - this._b) / this._a, (j.y / k - this._d) / this._c)
        }
    };
    g.DomUtil = {
        get: function (j) {
            return typeof j === "string" ? f.getElementById(j) : j
        }, getStyle: function (l, k) {
            var m = l.style[k] || (l.currentStyle && l.currentStyle[k]);
            if ((!m || m === "auto") && f.defaultView) {
                var j = f.defaultView.getComputedStyle(l, null);
                m = j ? j[k] : null
            }
            return m === "auto" ? null : m
        }, create: function (k, m, j) {
            var l = f.createElement(k);
            l.className = m;
            if (j) {
                j.appendChild(l)
            }
            return l
        }, remove: function (k) {
            var j = k.parentNode;
            if (j) {
                j.removeChild(k)
            }
        }, empty: function (j) {
            while (j.firstChild) {
                j.removeChild(j.firstChild)
            }
        }, toFront: function (j) {
            j.parentNode.appendChild(j)
        }, toBack: function (k) {
            var j = k.parentNode;
            j.insertBefore(k, j.firstChild)
        }, hasClass: function (l, j) {
            if (l.classList !== b) {
                return l.classList.contains(j)
            }
            var k = g.DomUtil.getClass(l);
            return k.length > 0 && new RegExp("(^|\\s)" + j + "(\\s|$)").test(k)
        }, addClass: function (o, k) {
            if (o.classList !== b) {
                var m = g.Util.splitWords(k);
                for (var l = 0, j = m.length; l < j; l++) {
                    o.classList.add(m[l])
                }
            } else {
                if (!g.DomUtil.hasClass(o, k)) {
                    var n = g.DomUtil.getClass(o);
                    g.DomUtil.setClass(o, (n ? n + " " : "") + k)
                }
            }
        }, removeClass: function (k, j) {
            if (k.classList !== b) {
                k.classList.remove(j)
            } else {
                g.DomUtil.setClass(k, g.Util.trim((" " + g.DomUtil.getClass(k) + " ").replace(" " + j + " ", " ")))
            }
        }, setClass: function (k, j) {
            if (k.className.baseVal === b) {
                k.className = j
            } else {
                k.className.baseVal = j
            }
        }, getClass: function (j) {
            return j.className.baseVal === b ? j.className : j.className.baseVal
        }, setOpacity: function (l, m) {
            if ("opacity" in l.style) {
                l.style.opacity = m
            } else {
                if ("filter" in l.style) {
                    var k = false, j = "DXImageTransform.Microsoft.Alpha";
                    try {
                        k = l.filters.item(j)
                    } catch (n) {
                        if (m === 1) {
                            return
                        }
                    }
                    m = Math.round(m * 100);
                    if (k) {
                        k.Enabled = (m !== 100);
                        k.Opacity = m
                    } else {
                        l.style.filter += " progid:" + j + "(opacity=" + m + ")"
                    }
                }
            }
        }, testProp: function (l) {
            var k = f.documentElement.style;
            for (var j = 0; j < l.length; j++) {
                if (l[j] in k) {
                    return l[j]
                }
            }
            return false
        }, setTransform: function (j, l, k) {
            var m = l || new g.Point(0, 0);
            j.style[g.DomUtil.TRANSFORM] = "translate3d(" + m.x + "px," + m.y + "px,0)" + (k ? " scale(" + k + ")" : "")
        }, setPosition: function (k, j, l) {
            k._leaflet_pos = j;
            if (g.Browser.any3d && !l) {
                g.DomUtil.setTransform(k, j)
            } else {
                k.style.left = j.x + "px";
                k.style.top = j.y + "px"
            }
        }, getPosition: function (j) {
            return j._leaflet_pos
        }
    };
    (function () {
        g.DomUtil.TRANSFORM = g.DomUtil.testProp(["transform", "WebkitTransform", "OTransform", "MozTransform", "msTransform"]);
        var k = g.DomUtil.TRANSITION = g.DomUtil.testProp(["webkitTransition", "transition", "OTransition", "MozTransition", "msTransition"]);
        g.DomUtil.TRANSITION_END = k === "webkitTransition" || k === "OTransition" ? k + "End" : "transitionend";
        if ("onselectstart" in f) {
            g.DomUtil.disableTextSelection = function () {
                g.DomEvent.on(d, "selectstart", g.DomEvent.preventDefault)
            };
            g.DomUtil.enableTextSelection = function () {
                g.DomEvent.off(d, "selectstart", g.DomEvent.preventDefault)
            }
        } else {
            var j = g.DomUtil.testProp(["userSelect", "WebkitUserSelect", "OUserSelect", "MozUserSelect", "msUserSelect"]);
            g.DomUtil.disableTextSelection = function () {
                if (j) {
                    var l = f.documentElement.style;
                    this._userSelect = l[j];
                    l[j] = "none"
                }
            };
            g.DomUtil.enableTextSelection = function () {
                if (j) {
                    f.documentElement.style[j] = this._userSelect;
                    delete this._userSelect
                }
            }
        }
        g.DomUtil.disableImageDrag = function () {
            g.DomEvent.on(d, "dragstart", g.DomEvent.preventDefault)
        };
        g.DomUtil.enableImageDrag = function () {
            g.DomEvent.off(d, "dragstart", g.DomEvent.preventDefault)
        }
    })();
    g.LatLng = function (l, j, k) {
        if (isNaN(l) || isNaN(j)) {
            throw new Error("Invalid LatLng object: (" + l + ", " + j + ")")
        }
        this.lat = +l;
        this.lng = +j;
        if (k !== b) {
            this.alt = +k
        }
    };
    g.LatLng.prototype = {
        equals: function (l, j) {
            if (!l) {
                return false
            }
            l = g.latLng(l);
            var k = Math.max(Math.abs(this.lat - l.lat), Math.abs(this.lng - l.lng));
            return k <= (j === b ? 1e-9 : j)
        }, toString: function (j) {
            return "LatLng(" + g.Util.formatNum(this.lat, j) + ", " + g.Util.formatNum(this.lng, j) + ")"
        }, distanceTo: function (j) {
            return g.CRS.Earth.distance(this, g.latLng(j))
        }, wrap: function () {
            return g.CRS.Earth.wrapLatLng(this)
        }
    };
    g.latLng = function (k, j) {
        if (k instanceof g.LatLng) {
            return k
        }
        if (g.Util.isArray(k) && typeof k[0] !== "object") {
            if (k.length === 3) {
                return new g.LatLng(k[0], k[1], k[2])
            }
            return new g.LatLng(k[0], k[1])
        }
        if (k === b || k === null) {
            return k
        }
        if (typeof k === "object" && "lat" in k) {
            return new g.LatLng(k.lat, "lng" in k ? k.lng : k.lon)
        }
        if (j === b) {
            return null
        }
        return new g.LatLng(k, j)
    };
    g.LatLngBounds = function (n, l) {
        if (!n) {
            return
        }
        var k = l ? [n, l] : n;
        for (var m = 0, j = k.length; m < j; m++) {
            this.extend(k[m])
        }
    };
    g.LatLngBounds.prototype = {
        extend: function (n) {
            var j = this._southWest, m = this._northEast, k, l;
            if (n instanceof g.LatLng) {
                k = n;
                l = n
            } else {
                if (n instanceof g.LatLngBounds) {
                    k = n._southWest;
                    l = n._northEast;
                    if (!k || !l) {
                        return this
                    }
                } else {
                    return n ? this.extend(g.latLng(n) || g.latLngBounds(n)) : this
                }
            }
            if (!j && !m) {
                this._southWest = new g.LatLng(k.lat, k.lng);
                this._northEast = new g.LatLng(l.lat, l.lng)
            } else {
                j.lat = Math.min(k.lat, j.lat);
                j.lng = Math.min(k.lng, j.lng);
                m.lat = Math.max(l.lat, m.lat);
                m.lng = Math.max(l.lng, m.lng)
            }
            return this
        }, pad: function (m) {
            var k = this._southWest, n = this._northEast, j = Math.abs(k.lat - n.lat) * m, l = Math.abs(k.lng - n.lng) * m;
            return new g.LatLngBounds(new g.LatLng(k.lat - j, k.lng - l), new g.LatLng(n.lat + j, n.lng + l))
        }, getCenter: function () {
            return new g.LatLng((this._southWest.lat + this._northEast.lat) / 2, (this._southWest.lng + this._northEast.lng) / 2)
        }, getSouthWest: function () {
            return this._southWest
        }, getNorthEast: function () {
            return this._northEast
        }, getNorthWest: function () {
            return new g.LatLng(this.getNorth(), this.getWest())
        }, getSouthEast: function () {
            return new g.LatLng(this.getSouth(), this.getEast())
        }, getWest: function () {
            return this._southWest.lng
        }, getSouth: function () {
            return this._southWest.lat
        }, getEast: function () {
            return this._northEast.lng
        }, getNorth: function () {
            return this._northEast.lat
        }, contains: function (n) {
            if (typeof n[0] === "number" || n instanceof g.LatLng) {
                n = g.latLng(n)
            } else {
                n = g.latLngBounds(n)
            }
            var j = this._southWest, m = this._northEast, k, l;
            if (n instanceof g.LatLngBounds) {
                k = n.getSouthWest();
                l = n.getNorthEast()
            } else {
                k = l = n
            }
            return (k.lat >= j.lat) && (l.lat <= m.lat) && (k.lng >= j.lng) && (l.lng <= m.lng)
        }, intersects: function (m) {
            m = g.latLngBounds(m);
            var j = this._southWest, p = this._northEast, k = m.getSouthWest(), o = m.getNorthEast(), n = (o.lat >= j.lat) && (k.lat <= p.lat), l = (o.lng >= j.lng) && (k.lng <= p.lng);
            return n && l
        }, toBBoxString: function () {
            return [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(",")
        }, equals: function (j) {
            if (!j) {
                return false
            }
            j = g.latLngBounds(j);
            return this._southWest.equals(j.getSouthWest()) && this._northEast.equals(j.getNorthEast())
        }, isValid: function () {
            return !!(this._southWest && this._northEast)
        }
    };
    g.latLngBounds = function (k, j) {
        if (!k || k instanceof g.LatLngBounds) {
            return k
        }
        return new g.LatLngBounds(k, j)
    };
    g.Projection = {};
    g.Projection.LonLat = {
        project: function (j) {
            return new g.Point(j.lng, j.lat)
        }, unproject: function (j) {
            return new g.LatLng(j.y, j.x)
        }, bounds: g.bounds([-180, -90], [180, 90])
    };
    g.Projection.SphericalMercator = {
        R: 6378137, project: function (m) {
            var l = Math.PI / 180, j = 1 - 1e-15, k = Math.max(Math.min(Math.sin(m.lat * l), j), -j);
            return new g.Point(this.R * m.lng * l, this.R * Math.log((1 + k) / (1 - k)) / 2)
        }, unproject: function (j) {
            var k = 180 / Math.PI;
            return new g.LatLng((2 * Math.atan(Math.exp(j.y / this.R)) - (Math.PI / 2)) * k, j.x * k / this.R)
        }, bounds: (function () {
            var j = 6378137 * Math.PI;
            return g.bounds([-j, -j], [j, j])
        })()
    };
    g.CRS = {
        latLngToPoint: function (m, k) {
            var j = this.projection.project(m), l = this.scale(k);
            return this.transformation._transform(j, l)
        }, pointToLatLng: function (j, l) {
            var m = this.scale(l), k = this.transformation.untransform(j, m);
            return this.projection.unproject(k)
        }, project: function (j) {
            return this.projection.project(j)
        }, unproject: function (j) {
            return this.projection.unproject(j)
        }, scale: function (j) {
            return 256 * Math.pow(2, j)
        }, getProjectedBounds: function (n) {
            if (this.infinite) {
                return null
            }
            var k = this.projection.bounds, m = this.scale(n), l = this.transformation.transform(k.min, m), j = this.transformation.transform(k.max, m);
            return g.bounds(l, j)
        }, wrapLatLng: function (l) {
            var j = this.wrapLng ? g.Util.wrapNum(l.lng, this.wrapLng, true) : l.lng, k = this.wrapLat ? g.Util.wrapNum(l.lat, this.wrapLat, true) : l.lat;
            return g.latLng(k, j)
        }
    };
    g.CRS.Simple = g.extend({}, g.CRS, {
        projection: g.Projection.LonLat,
        transformation: new g.Transformation(1, 0, -1, 0),
        scale: function (j) {
            return Math.pow(2, j)
        },
        distance: function (j, m) {
            var l = m.lng - j.lng, k = m.lat - j.lat;
            return Math.sqrt(l * l + k * k)
        },
        infinite: true
    });
    g.CRS.Earth = g.extend({}, g.CRS, {
        wrapLng: [-180, 180], R: 6378137, distance: function (k, o) {
            var j = Math.PI / 180, n = k.lat * j, m = o.lat * j, l = Math.sin(n) * Math.sin(m) + Math.cos(n) * Math.cos(m) * Math.cos((o.lng - k.lng) * j);
            return this.R * Math.acos(Math.min(l, 1))
        }
    });
    g.CRS.EPSG3857 = g.extend({}, g.CRS.Earth, {
        code: "EPSG:3857",
        projection: g.Projection.SphericalMercator,
        transformation: (function () {
            var j = 0.5 / (Math.PI * g.Projection.SphericalMercator.R);
            return new g.Transformation(j, 0.5, -j, 0.5)
        }())
    });
    g.CRS.EPSG900913 = g.extend({}, g.CRS.EPSG3857, {code: "EPSG:900913"});
    g.CRS.EPSG4326 = g.extend({}, g.CRS.Earth, {
        code: "EPSG:4326",
        projection: g.Projection.LonLat,
        transformation: new g.Transformation(1 / 180, 1, -1 / 180, 0.5)
    });
    g.Map = g.Evented.extend({
        options: {
            crs: g.CRS.EPSG3857,
            fadeAnimation: true,
            trackResize: true,
            markerZoomAnimation: true
        }, initialize: function (k, j) {
            j = g.setOptions(this, j);
            this._initContainer(k);
            this._initLayout();
            this._onResize = g.bind(this._onResize, this);
            this._initEvents();
            if (j.maxBounds) {
                this.setMaxBounds(j.maxBounds)
            }
            if (j.center && j.zoom !== b) {
                this.setView(g.latLng(j.center), j.zoom, {reset: true})
            }
            this._handlers = [];
            this._layers = {};
            this._zoomBoundLayers = {};
            this.callInitHooks();
            this._addLayers(this.options.layers)
        }, setView: function (j, k) {
            k = k === b ? this.getZoom() : k;
            this._resetView(g.latLng(j), this._limitZoom(k));
            return this
        }, setZoom: function (k, j) {
            if (!this._loaded) {
                this._zoom = this._limitZoom(k);
                return this
            }
            return this.setView(this.getCenter(), k, {zoom: j})
        }, zoomIn: function (k, j) {
            return this.setZoom(this._zoom + (k || 1), j)
        }, zoomOut: function (k, j) {
            return this.setZoom(this._zoom - (k || 1), j)
        }, setZoomAround: function (q, o, n) {
            var p = this.getZoomScale(o), m = this.getSize().divideBy(2), l = q instanceof g.Point ? q : this.latLngToContainerPoint(q), j = l.subtract(m).multiplyBy(1 - 1 / p), k = this.containerPointToLatLng(m.add(j));
            return this.setView(k, o, {zoom: n})
        }, fitBounds: function (k, r) {
            r = r || {};
            k = k.getBounds ? k.getBounds() : g.latLngBounds(k);
            var m = g.point(r.paddingTopLeft || r.padding || [0, 0]), l = g.point(r.paddingBottomRight || r.padding || [0, 0]), q = this.getBoundsZoom(k, false, m.add(l));
            q = r.maxZoom ? Math.min(r.maxZoom, q) : q;
            var o = l.subtract(m).divideBy(2), p = this.project(k.getSouthWest(), q), n = this.project(k.getNorthEast(), q), j = this.unproject(p.add(n).divideBy(2).add(o), q);
            return this.setView(j, q, r)
        }, fitWorld: function (j) {
            return this.fitBounds([[-90, -180], [90, 180]], j)
        }, panTo: function (j, k) {
            return this.setView(j, this._zoom, {pan: k})
        }, panBy: function (j) {
            this.fire("movestart");
            this._rawPanBy(g.point(j));
            this.fire("move");
            return this.fire("moveend")
        }, setMaxBounds: function (j) {
            j = g.latLngBounds(j);
            this.options.maxBounds = j;
            if (!j) {
                return this.off("moveend", this._panInsideMaxBounds)
            }
            if (this._loaded) {
                this._panInsideMaxBounds()
            }
            return this.on("moveend", this._panInsideMaxBounds)
        }, panInsideBounds: function (m, l) {
            var j = this.getCenter(), k = this._limitCenter(j, this._zoom, m);
            if (j.equals(k)) {
                return this
            }
            return this.panTo(k, l)
        }, invalidateSize: function (l) {
            if (!this._loaded) {
                return this
            }
            l = g.extend({animate: false, pan: true}, l === true ? {animate: true} : l);
            var m = this.getSize();
            this._sizeChanged = true;
            this._initialCenter = null;
            var k = this.getSize(), o = m.divideBy(2).round(), j = k.divideBy(2).round(), n = o.subtract(j);
            if (!n.x && !n.y) {
                return this
            }
            if (l.animate && l.pan) {
                this.panBy(n)
            } else {
                if (l.pan) {
                    this._rawPanBy(n)
                }
                this.fire("move");
                if (l.debounceMoveend) {
                    clearTimeout(this._sizeTimer);
                    this._sizeTimer = setTimeout(g.bind(this.fire, this, "moveend"), 200)
                } else {
                    this.fire("moveend")
                }
            }
            return this.fire("resize", {oldSize: m, newSize: k})
        }, addHandler: function (j, l) {
            if (!l) {
                return this
            }
            var k = this[j] = new l(this);
            this._handlers.push(k);
            if (this.options[j]) {
                k.enable()
            }
            return this
        }, remove: function () {
            this._initEvents("off");
            try {
                delete this._container._leaflet
            } catch (j) {
                this._container._leaflet = b
            }
            g.DomUtil.remove(this._mapPane);
            if (this._clearControlPos) {
                this._clearControlPos()
            }
            this._clearHandlers();
            if (this._loaded) {
                this.fire("unload")
            }
            return this
        }, createPane: function (k, j) {
            var l = "leaflet-pane" + (k ? " leaflet-" + k.replace("Pane", "") + "-pane" : ""), m = g.DomUtil.create("div", l, j || this._mapPane);
            if (k) {
                this._panes[k] = m
            }
            return m
        }, getCenter: function () {
            this._checkIfLoaded();
            if (this._initialCenter && !this._moved()) {
                return this._initialCenter
            }
            return this.layerPointToLatLng(this._getCenterLayerPoint())
        }, getZoom: function () {
            return this._zoom
        }, getBounds: function () {
            var k = this.getPixelBounds(), j = this.unproject(k.getBottomLeft()), l = this.unproject(k.getTopRight());
            return new g.LatLngBounds(j, l)
        }, getMinZoom: function () {
            return this.options.minZoom === b ? this._layersMinZoom || 0 : this.options.minZoom
        }, getMaxZoom: function () {
            return this.options.maxZoom === b ? (this._layersMaxZoom === b ? Infinity : this._layersMaxZoom) : this.options.maxZoom
        }, getBoundsZoom: function (j, k, o) {
            j = g.latLngBounds(j);
            var q = this.getMinZoom() - (k ? 1 : 0), p = this.getMaxZoom(), s = this.getSize(), m = j.getNorthWest(), n = j.getSouthEast(), l = true, r;
            o = g.point(o || [0, 0]);
            do {
                q++;
                r = this.project(n, q).subtract(this.project(m, q)).add(o);
                l = !k ? s.contains(r) : r.x < s.x || r.y < s.y
            } while (l && q <= p);
            if (l && k) {
                return null
            }
            return k ? q : q - 1
        }, getSize: function () {
            if (!this._size || this._sizeChanged) {
                this._size = new g.Point(this._container.clientWidth, this._container.clientHeight);
                this._sizeChanged = false
            }
            return this._size.clone()
        }, getPixelBounds: function () {
            var j = this._getTopLeftPoint();
            return new g.Bounds(j, j.add(this.getSize()))
        }, getPixelOrigin: function () {
            this._checkIfLoaded();
            return this._initialTopLeftPoint
        }, getPixelWorldBounds: function () {
            return this.options.crs.getProjectedBounds(this.getZoom())
        }, getPane: function (j) {
            return typeof j === "string" ? this._panes[j] : j
        }, getPanes: function () {
            return this._panes
        }, getContainer: function () {
            return this._container
        }, getZoomScale: function (k) {
            var j = this.options.crs;
            return j.scale(k) / j.scale(this._zoom)
        }, getScaleZoom: function (j) {
            return this._zoom + (Math.log(j) / Math.LN2)
        }, project: function (k, j) {
            j = j === b ? this._zoom : j;
            return this.options.crs.latLngToPoint(g.latLng(k), j)
        }, unproject: function (j, k) {
            k = k === b ? this._zoom : k;
            return this.options.crs.pointToLatLng(g.point(j), k)
        }, layerPointToLatLng: function (j) {
            var k = g.point(j).add(this.getPixelOrigin());
            return this.unproject(k)
        }, latLngToLayerPoint: function (k) {
            var j = this.project(g.latLng(k))._round();
            return j._subtract(this.getPixelOrigin())
        }, wrapLatLng: function (j) {
            return this.options.crs.wrapLatLng(g.latLng(j))
        }, distance: function (j, k) {
            return this.options.crs.distance(g.latLng(j), g.latLng(k))
        }, containerPointToLayerPoint: function (j) {
            return g.point(j).subtract(this._getMapPanePos())
        }, layerPointToContainerPoint: function (j) {
            return g.point(j).add(this._getMapPanePos())
        }, containerPointToLatLng: function (j) {
            var k = this.containerPointToLayerPoint(g.point(j));
            return this.layerPointToLatLng(k)
        }, latLngToContainerPoint: function (j) {
            return this.layerPointToContainerPoint(this.latLngToLayerPoint(g.latLng(j)))
        }, mouseEventToContainerPoint: function (j) {
            return g.DomEvent.getMousePosition(j, this._container)
        }, mouseEventToLayerPoint: function (j) {
            return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(j))
        }, mouseEventToLatLng: function (j) {
            return this.layerPointToLatLng(this.mouseEventToLayerPoint(j))
        }, _initContainer: function (k) {
            var j = this._container = g.DomUtil.get(k);
            if (!j) {
                throw new Error("Map container not found.")
            } else {
                if (j._leaflet) {
                    throw new Error("Map container is already initialized.")
                }
            }
            j._leaflet = true
        }, _initLayout: function () {
            var k = this._container;
            this._fadeAnimated = this.options.fadeAnimation && g.Browser.any3d;
            g.DomUtil.addClass(k, "leaflet-container" + (g.Browser.touch ? " leaflet-touch" : "") + (g.Browser.retina ? " leaflet-retina" : "") + (g.Browser.ielt9 ? " leaflet-oldie" : "") + (g.Browser.safari ? " leaflet-safari" : "") + (this._fadeAnimated ? " leaflet-fade-anim" : ""));
            var j = g.DomUtil.getStyle(k, "position");
            if (j !== "absolute" && j !== "relative" && j !== "fixed") {
                k.style.position = "relative"
            }
            this._initPanes();
            if (this._initControlPos) {
                this._initControlPos()
            }
        }, _initPanes: function () {
            var j = this._panes = {};
            this._mapPane = this.createPane("mapPane", this._container);
            this.createPane("tilePane");
            this.createPane("shadowPane");
            this.createPane("overlayPane");
            this.createPane("markerPane");
            this.createPane("popupPane");
            if (!this.options.markerZoomAnimation) {
                g.DomUtil.addClass(j.markerPane, "leaflet-zoom-hide");
                g.DomUtil.addClass(j.shadowPane, "leaflet-zoom-hide")
            }
        }, _resetView: function (l, n, k, m) {
            var j = (this._zoom !== n);
            if (!m) {
                this.fire("movestart");
                if (j) {
                    this.fire("zoomstart")
                }
            }
            this._zoom = n;
            this._initialCenter = l;
            this._initialTopLeftPoint = this._getNewTopLeftPoint(l);
            if (!k) {
                g.DomUtil.setPosition(this._mapPane, new g.Point(0, 0))
            } else {
                this._initialTopLeftPoint._add(this._getMapPanePos())
            }
            var o = !this._loaded;
            this._loaded = true;
            this.fire("viewreset", {hard: !k});
            if (o) {
                this.fire("load")
            }
            this.fire("move");
            if (j || m) {
                this.fire("zoomend")
            }
            this.fire("moveend", {hard: !k})
        }, _rawPanBy: function (j) {
            g.DomUtil.setPosition(this._mapPane, this._getMapPanePos().subtract(j))
        }, _getZoomSpan: function () {
            return this.getMaxZoom() - this.getMinZoom()
        }, _panInsideMaxBounds: function () {
            this.panInsideBounds(this.options.maxBounds)
        }, _checkIfLoaded: function () {
            if (!this._loaded) {
                throw new Error("Set map center and zoom first.")
            }
        }, _initEvents: function (j) {
            if (!g.DomEvent) {
                return
            }
            j = j || "on";
            g.DomEvent[j](this._container, "click dblclick mousedown mouseup mouseenter mouseleave mousemove contextmenu", this._handleMouseEvent, this);
            if (this.options.trackResize) {
                g.DomEvent[j](d, "resize", this._onResize, this)
            }
        }, _onResize: function () {
            g.Util.cancelAnimFrame(this._resizeRequest);
            this._resizeRequest = g.Util.requestAnimFrame(function () {
                this.invalidateSize({debounceMoveend: true})
            }, this, false, this._container)
        }, _handleMouseEvent: function (j) {
            if (!this._loaded) {
                return
            }
            this._fireMouseEvent(this, j, j.type === "mouseenter" ? "mouseover" : j.type === "mouseleave" ? "mouseout" : j.type)
        }, _fireMouseEvent: function (n, m, k, j, o) {
            k = k || m.type;
            if (g.DomEvent._skipped(m)) {
                return
            }
            if (k === "click") {
                if (!m._simulated && ((this.dragging && this.dragging.moved()) || (this.boxZoom && this.boxZoom.moved()))) {
                    return
                }
                n.fire("preclick")
            }
            if (!n.listens(k, j)) {
                return
            }
            if (k === "contextmenu") {
                g.DomEvent.preventDefault(m)
            }
            if (k === "click" || k === "dblclick" || k === "contextmenu") {
                g.DomEvent.stopPropagation(m)
            }
            var l = {originalEvent: m, containerPoint: this.mouseEventToContainerPoint(m)};
            l.layerPoint = this.containerPointToLayerPoint(l.containerPoint);
            l.latlng = o || this.layerPointToLatLng(l.layerPoint);
            n.fire(k, l, j)
        }, _clearHandlers: function () {
            for (var k = 0, j = this._handlers.length; k < j; k++) {
                this._handlers[k].disable()
            }
        }, whenReady: function (k, j) {
            if (this._loaded) {
                k.call(j || this, {target: this})
            } else {
                this.on("load", k, j)
            }
            return this
        }, _getMapPanePos: function () {
            return g.DomUtil.getPosition(this._mapPane)
        }, _moved: function () {
            var j = this._getMapPanePos();
            return j && !j.equals([0, 0])
        }, _getTopLeftPoint: function () {
            return this.getPixelOrigin().subtract(this._getMapPanePos())
        }, _getNewTopLeftPoint: function (j, l) {
            var k = this.getSize()._divideBy(2);
            return this.project(j, l)._subtract(k)._round()
        }, _latLngToNewLayerPoint: function (m, k, j) {
            var l = this._getNewTopLeftPoint(j, k).add(this._getMapPanePos());
            return this.project(m, k)._subtract(l)
        }, _getCenterLayerPoint: function () {
            return this.containerPointToLayerPoint(this.getSize()._divideBy(2))
        }, _getCenterOffset: function (j) {
            return this.latLngToLayerPoint(j).subtract(this._getCenterLayerPoint())
        }, _limitCenter: function (j, m, l) {
            if (!l) {
                return j
            }
            var p = this.project(j, m), k = this.getSize().divideBy(2), n = new g.Bounds(p.subtract(k), p.add(k)), o = this._getBoundsOffset(n, l, m);
            return this.unproject(p.add(o), m)
        }, _limitOffset: function (m, j) {
            if (!j) {
                return m
            }
            var l = this.getPixelBounds(), k = new g.Bounds(l.min.add(m), l.max.add(m));
            return m.add(this._getBoundsOffset(k, j))
        }, _getBoundsOffset: function (m, k, o) {
            var n = this.project(k.getNorthWest(), o).subtract(m.min), p = this.project(k.getSouthEast(), o).subtract(m.max), l = this._rebound(n.x, -p.x), j = this._rebound(n.y, -p.y);
            return new g.Point(l, j)
        }, _rebound: function (k, j) {
            return k + j > 0 ? Math.round(k - j) / 2 : Math.max(0, Math.ceil(k)) - Math.max(0, Math.floor(j))
        }, _limitZoom: function (l) {
            var k = this.getMinZoom(), j = this.getMaxZoom();
            return Math.max(k, Math.min(j, l))
        }
    });
    g.map = function (k, j) {
        return new g.Map(k, j)
    };
    g.Layer = g.Evented.extend({
        options: {pane: "overlayPane"}, addTo: function (j) {
            j.addLayer(this);
            return this
        }, remove: function () {
            return this.removeFrom(this._map || this._mapToAdd)
        }, removeFrom: function (j) {
            if (j) {
                j.removeLayer(this)
            }
            return this
        }, getPane: function (j) {
            return this._map.getPane(j ? (this.options[j] || j) : this.options.pane)
        }, _layerAdd: function (k) {
            var j = k.target;
            if (!j.hasLayer(this)) {
                return
            }
            this._map = j;
            this._zoomAnimated = j._zoomAnimated;
            this.onAdd(j);
            if (this.getAttribution && this._map.attributionControl) {
                this._map.attributionControl.addAttribution(this.getAttribution())
            }
            if (this.getEvents) {
                j.on(this.getEvents(), this)
            }
            this.fire("add");
            j.fire("layeradd", {layer: this})
        }
    });
    g.Map.include({
        addLayer: function (j) {
            var k = g.stamp(j);
            if (this._layers[k]) {
                return j
            }
            this._layers[k] = j;
            j._mapToAdd = this;
            if (j.beforeAdd) {
                j.beforeAdd(this)
            }
            this.whenReady(j._layerAdd, j);
            return this
        }, removeLayer: function (j) {
            var k = g.stamp(j);
            if (!this._layers[k]) {
                return this
            }
            if (this._loaded) {
                j.onRemove(this)
            }
            if (j.getAttribution && this.attributionControl) {
                this.attributionControl.removeAttribution(j.getAttribution())
            }
            if (j.getEvents) {
                this.off(j.getEvents(), j)
            }
            delete this._layers[k];
            if (this._loaded) {
                this.fire("layerremove", {layer: j});
                j.fire("remove")
            }
            j._map = j._mapToAdd = null;
            return this
        }, hasLayer: function (j) {
            return !!j && (g.stamp(j) in this._layers)
        }, eachLayer: function (l, k) {
            for (var j in this._layers) {
                l.call(k, this._layers[j])
            }
            return this
        }, _addLayers: function (l) {
            l = l ? (g.Util.isArray(l) ? l : [l]) : [];
            for (var k = 0, j = l.length; k < j; k++) {
                this.addLayer(l[k])
            }
        }, _addZoomLimit: function (j) {
            if (isNaN(j.options.maxZoom) || !isNaN(j.options.minZoom)) {
                this._zoomBoundLayers[g.stamp(j)] = j;
                this._updateZoomLevels()
            }
        }, _removeZoomLimit: function (j) {
            var k = g.stamp(j);
            if (this._zoomBoundLayers[k]) {
                delete this._zoomBoundLayers[k];
                this._updateZoomLevels()
            }
        }, _updateZoomLevels: function () {
            var n = Infinity, j = -Infinity, m = this._getZoomSpan();
            for (var l in this._zoomBoundLayers) {
                var k = this._zoomBoundLayers[l].options;
                n = k.minZoom === b ? n : Math.min(n, k.minZoom);
                j = k.maxZoom === b ? j : Math.max(j, k.maxZoom)
            }
            this._layersMaxZoom = j === -Infinity ? b : j;
            this._layersMinZoom = n === Infinity ? b : n;
            if (m !== this._getZoomSpan()) {
                this.fire("zoomlevelschange")
            }
        }
    });
    g.Projection.Mercator = {
        R: 6378137,
        R_MINOR: 6356752.314245179,
        bounds: g.bounds([-20037508.34279, -15496570.73972], [20037508.34279, 18764656.23138]),
        project: function (q) {
            var o = Math.PI / 180, m = this.R, p = q.lat * o, k = this.R_MINOR / m, n = Math.sqrt(1 - k * k), j = n * Math.sin(p);
            var l = Math.tan(Math.PI / 4 - p / 2) / Math.pow((1 - j) / (1 + j), n / 2);
            p = -m * Math.log(Math.max(l, 1e-10));
            return new g.Point(q.lng * o * m, p)
        },
        unproject: function (t) {
            var q = 180 / Math.PI, j = this.R, l = this.R_MINOR / j, o = Math.sqrt(1 - l * l), s = Math.exp(-t.y / j), p = Math.PI / 2 - 2 * Math.atan(s);
            for (var m = 0, n = 0.1, k; m < 15 && Math.abs(n) > 1e-7; m++) {
                k = o * Math.sin(p);
                k = Math.pow((1 - k) / (1 + k), o / 2);
                n = Math.PI / 2 - 2 * Math.atan(s * k) - p;
                p += n
            }
            return new g.LatLng(p * q, t.x * q / j)
        }
    };
    g.CRS.EPSG3395 = g.extend({}, g.CRS.Earth, {
        code: "EPSG:3395",
        projection: g.Projection.Mercator,
        transformation: (function () {
            var j = 0.5 / (Math.PI * g.Projection.Mercator.R);
            return new g.Transformation(j, 0.5, -j, 0.5)
        }())
    });
    g.GridLayer = g.Layer.extend({
        options: {
            pane: "tilePane",
            tileSize: 256,
            opacity: 1,
            unloadInvisibleTiles: g.Browser.mobile,
            updateWhenIdle: g.Browser.mobile,
            updateInterval: 150
        }, initialize: function (j) {
            j = g.setOptions(this, j)
        }, onAdd: function () {
            this._initContainer();
            if (!this.options.updateWhenIdle) {
                this._update = g.Util.throttle(this._update, this.options.updateInterval, this)
            }
            this._reset();
            this._update()
        }, beforeAdd: function (j) {
            j._addZoomLimit(this)
        }, onRemove: function (j) {
            this._clearBgBuffer();
            g.DomUtil.remove(this._container);
            j._removeZoomLimit(this);
            this._container = null
        }, bringToFront: function () {
            if (this._map) {
                g.DomUtil.toFront(this._container);
                this._setAutoZIndex(Math.max)
            }
            return this
        }, bringToBack: function () {
            if (this._map) {
                g.DomUtil.toBack(this._container);
                this._setAutoZIndex(Math.min)
            }
            return this
        }, getAttribution: function () {
            return this.options.attribution
        }, getContainer: function () {
            return this._container
        }, setOpacity: function (j) {
            this.options.opacity = j;
            if (this._map) {
                this._updateOpacity()
            }
            return this
        }, setZIndex: function (j) {
            this.options.zIndex = j;
            this._updateZIndex();
            return this
        }, redraw: function () {
            if (this._map) {
                this._reset({hard: true});
                this._update()
            }
            return this
        }, getEvents: function () {
            var j = {viewreset: this._reset, moveend: this._update};
            if (!this.options.updateWhenIdle) {
                j.move = this._update
            }
            if (this._zoomAnimated) {
                j.zoomstart = this._startZoomAnim;
                j.zoomanim = this._animateZoom;
                j.zoomend = this._endZoomAnim
            }
            return j
        }, _updateZIndex: function () {
            if (this._container && this.options.zIndex !== b) {
                this._container.style.zIndex = this.options.zIndex
            }
        }, _setAutoZIndex: function (m) {
            var n = this.getPane().children, l = -m(-Infinity, Infinity);
            for (var k = 0, j = n.length, o; k < j; k++) {
                o = n[k].style.zIndex;
                if (n[k] !== this._container && o) {
                    l = m(l, +o)
                }
            }
            if (isFinite(l)) {
                this.options.zIndex = l + m(-1, 1);
                this._updateZIndex()
            }
        }, _updateOpacity: function () {
            var j = this.options.opacity;
            if (g.Browser.ielt9) {
                for (var k in this._tiles) {
                    g.DomUtil.setOpacity(this._tiles[k], j)
                }
            } else {
                g.DomUtil.setOpacity(this._container, j)
            }
        }, _initContainer: function () {
            if (this._container) {
                return
            }
            this._container = g.DomUtil.create("div", "leaflet-layer");
            this._updateZIndex();
            if (this._zoomAnimated) {
                var j = "leaflet-tile-container leaflet-zoom-animated";
                this._bgBuffer = g.DomUtil.create("div", j, this._container);
                this._tileContainer = g.DomUtil.create("div", j, this._container);
                g.DomUtil.setTransform(this._tileContainer)
            } else {
                this._tileContainer = this._container
            }
            if (this.options.opacity < 1) {
                this._updateOpacity()
            }
            this.getPane().appendChild(this._container)
        }, _reset: function (k) {
            for (var j in this._tiles) {
                this.fire("tileunload", {tile: this._tiles[j]})
            }
            this._tiles = {};
            this._tilesToLoad = 0;
            this._tilesTotal = 0;
            g.DomUtil.empty(this._tileContainer);
            if (this._zoomAnimated && k && k.hard) {
                this._clearBgBuffer()
            }
            this._tileNumBounds = this._getTileNumBounds();
            this._resetWrap()
        }, _resetWrap: function () {
            var l = this._map, j = l.options.crs;
            if (j.infinite) {
                return
            }
            var k = this._getTileSize();
            if (j.wrapLng) {
                this._wrapLng = [Math.floor(l.project([0, j.wrapLng[0]]).x / k), Math.ceil(l.project([0, j.wrapLng[1]]).x / k)]
            }
            if (j.wrapLat) {
                this._wrapLat = [Math.floor(l.project([j.wrapLat[0], 0]).y / k), Math.ceil(l.project([j.wrapLat[1], 0]).y / k)]
            }
        }, _getTileSize: function () {
            return this.options.tileSize
        }, _update: function () {
            if (!this._map) {
                return
            }
            var k = this._map.getPixelBounds(), j = this._map.getZoom(), l = this._getTileSize();
            if (j > this.options.maxZoom || j < this.options.minZoom) {
                return
            }
            var m = g.bounds(k.min.divideBy(l).floor(), k.max.divideBy(l).floor());
            this._addTiles(m);
            if (this.options.unloadInvisibleTiles) {
                this._removeOtherTiles(m)
            }
        }, _addTiles: function (k) {
            var p = [], l = k.getCenter(), s = this._map.getZoom();
            var n, o, r;
            for (n = k.min.y; n <= k.max.y; n++) {
                for (o = k.min.x; o <= k.max.x; o++) {
                    r = new g.Point(o, n);
                    r.z = s;
                    if (!(this._tileCoordsToKey(r) in this._tiles) && this._isValidTile(r)) {
                        p.push(r)
                    }
                }
            }
            var m = p.length;
            if (m === 0) {
                return
            }
            if (!this._tilesToLoad) {
                this.fire("loading")
            }
            this._tilesToLoad += m;
            this._tilesTotal += m;
            p.sort(function (t, j) {
                return t.distanceTo(l) - j.distanceTo(l)
            });
            var q = f.createDocumentFragment();
            for (o = 0; o < m; o++) {
                this._addTile(p[o], q)
            }
            this._tileContainer.appendChild(q)
        }, _isValidTile: function (l) {
            var j = this._map.options.crs;
            if (!j.infinite) {
                var k = this._tileNumBounds;
                if ((!j.wrapLng && (l.x < k.min.x || l.x > k.max.x)) || (!j.wrapLat && (l.y < k.min.y || l.y > k.max.y))) {
                    return false
                }
            }
            if (!this.options.bounds) {
                return true
            }
            var m = this._tileCoordsToBounds(l);
            return g.latLngBounds(this.options.bounds).intersects(m)
        }, _tileCoordsToBounds: function (o) {
            var p = this._map, n = this._getTileSize(), l = o.multiplyBy(n), j = l.add([n, n]), k = p.wrapLatLng(p.unproject(l, o.z)), m = p.wrapLatLng(p.unproject(j, o.z));
            return new g.LatLngBounds(k, m)
        }, _tileCoordsToKey: function (j) {
            return j.x + ":" + j.y
        }, _keyToTileCoords: function (k) {
            var l = k.split(":"), j = parseInt(l[0], 10), m = parseInt(l[1], 10);
            return new g.Point(j, m)
        }, _removeOtherTiles: function (k) {
            for (var j in this._tiles) {
                if (!k.contains(this._keyToTileCoords(j))) {
                    this._removeTile(j)
                }
            }
        }, _removeTile: function (j) {
            var k = this._tiles[j];
            g.DomUtil.remove(k);
            delete this._tiles[j];
            this.fire("tileunload", {tile: k})
        }, _initTile: function (k) {
            var j = this._getTileSize();
            g.DomUtil.addClass(k, "leaflet-tile");
            k.style.width = j + "px";
            k.style.height = j + "px";
            k.onselectstart = g.Util.falseFn;
            k.onmousemove = g.Util.falseFn;
            if (g.Browser.ielt9 && this.options.opacity < 1) {
                g.DomUtil.setOpacity(k, this.options.opacity)
            }
            if (g.Browser.android && !g.Browser.android23) {
                k.style.WebkitBackfaceVisibility = "hidden"
            }
        }, _addTile: function (m, j) {
            var k = this._getTilePos(m);
            this._wrapCoords(m);
            var l = this.createTile(m, g.bind(this._tileReady, this));
            this._initTile(l);
            if (this.createTile.length < 2) {
                setTimeout(g.bind(this._tileReady, this, null, l), 0)
            }
            g.DomUtil.setPosition(l, k, true);
            this._tiles[this._tileCoordsToKey(m)] = l;
            j.appendChild(l);
            this.fire("tileloadstart", {tile: l})
        }, _tileReady: function (k, j) {
            if (k) {
                this.fire("tileerror", {error: k, tile: j})
            }
            g.DomUtil.addClass(j, "leaflet-tile-loaded");
            this.fire("tileload", {tile: j});
            this._tilesToLoad--;
            if (this._tilesToLoad === 0) {
                this._visibleTilesReady()
            }
        }, _visibleTilesReady: function () {
            this.fire("load");
            if (this._zoomAnimated) {
                clearTimeout(this._clearBgBufferTimer);
                this._clearBgBufferTimer = setTimeout(g.bind(this._clearBgBuffer, this), 300)
            }
        }, _getTilePos: function (j) {
            return j.multiplyBy(this._getTileSize()).subtract(this._map.getPixelOrigin())
        }, _wrapCoords: function (j) {
            j.x = this._wrapLng ? g.Util.wrapNum(j.x, this._wrapLng) : j.x;
            j.y = this._wrapLat ? g.Util.wrapNum(j.y, this._wrapLat) : j.y
        }, _getTileNumBounds: function () {
            var k = this._map.getPixelWorldBounds(), j = this._getTileSize();
            return k ? g.bounds(k.min.divideBy(j).floor(), k.max.divideBy(j).ceil().subtract([1, 1])) : null
        }, _startZoomAnim: function () {
            this._prepareBgBuffer();
            this._prevTranslate = this._translate || new g.Point(0, 0);
            this._prevScale = this._scale
        }, _animateZoom: function (j) {
            this._translate = this._prevTranslate.multiplyBy(j.scale).add(j.origin.multiplyBy(1 - j.scale));
            this._scale = this._prevScale * j.scale;
            g.DomUtil.setTransform(this._bgBuffer, this._translate, this._scale)
        }, _endZoomAnim: function () {
            var j = this._tileContainer;
            j.style.visibility = "";
            g.DomUtil.toFront(j)
        }, _clearBgBuffer: function () {
            var k = this._map, j = this._bgBuffer;
            if (k && !k._animatingZoom && !k.touchZoom._zooming && j) {
                g.DomUtil.empty(j);
                g.DomUtil.setTransform(j)
            }
        }, _prepareBgBuffer: function () {
            var k = this._tileContainer, j = this._bgBuffer;
            if (this._abortLoading) {
                this._abortLoading()
            }
            if (this._tilesToLoad / this._tilesTotal > 0.5) {
                k.style.visibility = "hidden";
                return
            }
            j.style.visibility = "hidden";
            g.DomUtil.setTransform(j);
            this._tileContainer = j;
            this._bgBuffer = k;
            this._translate = new g.Point(0, 0);
            this._scale = 1;
            clearTimeout(this._clearBgBufferTimer)
        }
    });
    g.gridLayer = function (j) {
        return new g.GridLayer(j)
    };
    g.TileLayer = g.GridLayer.extend({
        options: {minZoom: 0, maxZoom: 18, subdomains: "abc", zoomOffset: 0},
        initialize: function (k, j) {
            this._url = k;
            j = g.setOptions(this, j);
            if (j.detectRetina && g.Browser.retina && j.maxZoom > 0) {
                j.tileSize = Math.floor(j.tileSize / 2);
                j.zoomOffset++;
                j.minZoom = Math.max(0, j.minZoom);
                j.maxZoom--
            }
            if (typeof j.subdomains === "string") {
                j.subdomains = j.subdomains.split("")
            }
        },
        setUrl: function (j, k) {
            this._url = j;
            if (!k) {
                this.redraw()
            }
            return this
        },
        createTile: function (l, j) {
            var k = f.createElement("img");
            k.onload = g.bind(this._tileOnLoad, this, j, k);
            k.onerror = g.bind(this._tileOnError, this, j, k);
            if (this.options.crossOrigin) {
                k.crossOrigin = ""
            }
            k.alt = "";
            k.src = this.getTileUrl(l);
            return k
        },
        getTileUrl: function (j) {
            return g.Util.template(this._url, g.extend({
                r: this.options.detectRetina && g.Browser.retina && this.options.maxZoom > 0 ? "@2x" : "",
                s: this._getSubdomain(j),
                x: j.x,
                y: this.options.tms ? this._tileNumBounds.max.y - j.y : j.y,
                z: this._getZoomForUrl()
            }, this.options))
        },
        _tileOnLoad: function (j, k) {
            j(null, k)
        },
        _tileOnError: function (k, l, m) {
            var j = this.options.errorTileUrl;
            if (j) {
                l.src = j
            }
            k(m, l)
        },
        _getTileSize: function () {
            var m = this._map, j = this.options, l = m.getZoom() + j.zoomOffset, k = j.maxNativeZoom;
            return k && l > k ? Math.round(m.getZoomScale(l) / m.getZoomScale(k) * j.tileSize) : j.tileSize
        },
        _removeTile: function (j) {
            var k = this._tiles[j];
            g.GridLayer.prototype._removeTile.call(this, j);
            if (!g.Browser.android) {
                k.onload = null;
                k.src = g.Util.emptyImageUrl
            }
        },
        _getZoomForUrl: function () {
            var j = this.options, k = this._map.getZoom();
            if (j.zoomReverse) {
                k = j.maxZoom - k
            }
            k += j.zoomOffset;
            return j.maxNativeZoom ? Math.min(k, j.maxNativeZoom) : k
        },
        _getSubdomain: function (k) {
            var j = Math.abs(k.x + k.y) % this.options.subdomains.length;
            return this.options.subdomains[j]
        },
        _abortLoading: function () {
            var j, k;
            for (j in this._tiles) {
                k = this._tiles[j];
                if (!k.complete) {
                    k.onload = g.Util.falseFn;
                    k.onerror = g.Util.falseFn;
                    k.src = g.Util.emptyImageUrl;
                    g.DomUtil.remove(k)
                }
            }
        }
    });
    g.tileLayer = function (k, j) {
        return new g.TileLayer(k, j)
    };
    g.TileLayer.WMS = g.TileLayer.extend({
        defaultWmsParams: {
            service: "WMS",
            request: "GetMap",
            version: "1.1.1",
            layers: "",
            styles: "",
            format: "image/jpeg",
            transparent: false
        }, initialize: function (l, k) {
            this._url = l;
            var j = g.extend({}, this.defaultWmsParams);
            for (var m in k) {
                if (!this.options.hasOwnProperty(m) && m !== "crs") {
                    j[m] = k[m]
                }
            }
            k = g.setOptions(this, k);
            j.width = j.height = k.tileSize * (k.detectRetina && g.Browser.retina ? 2 : 1);
            this.wmsParams = j
        }, onAdd: function (j) {
            this._crs = this.options.crs || j.options.crs;
            this._wmsVersion = parseFloat(this.wmsParams.version);
            var k = this._wmsVersion >= 1.3 ? "crs" : "srs";
            this.wmsParams[k] = this._crs.code;
            g.TileLayer.prototype.onAdd.call(this, j)
        }, getTileUrl: function (m) {
            var n = this._tileCoordsToBounds(m), j = this._crs.project(n.getNorthWest()), l = this._crs.project(n.getSouthEast()), o = (this._wmsVersion >= 1.3 && this._crs === g.CRS.EPSG4326 ? [l.y, j.x, j.y, l.x] : [j.x, l.y, l.x, j.y]).join(","), k = g.TileLayer.prototype.getTileUrl.call(this, m);
            return k + g.Util.getParamString(this.wmsParams, k, true) + "&BBOX=" + o
        }, setParams: function (k, j) {
            g.extend(this.wmsParams, k);
            if (!j) {
                this.redraw()
            }
            return this
        }
    });
    g.tileLayer.wms = function (k, j) {
        return new g.TileLayer.WMS(k, j)
    };
    g.ImageOverlay = g.Layer.extend({
        options: {opacity: 1}, initialize: function (k, l, j) {
            this._url = k;
            this._bounds = g.latLngBounds(l);
            g.setOptions(this, j)
        }, onAdd: function () {
            if (!this._image) {
                this._initImage();
                if (this.options.opacity < 1) {
                    this._updateOpacity()
                }
            }
            this.getPane().appendChild(this._image);
            this._reset()
        }, onRemove: function () {
            g.DomUtil.remove(this._image)
        }, setOpacity: function (j) {
            this.options.opacity = j;
            if (this._image) {
                this._updateOpacity()
            }
            return this
        }, bringToFront: function () {
            if (this._map) {
                g.DomUtil.toFront(this._image)
            }
            return this
        }, bringToBack: function () {
            if (this._map) {
                g.DomUtil.toBack(this._image)
            }
            return this
        }, setUrl: function (j) {
            this._url = j;
            if (this._image) {
                this._image.src = j
            }
            return this
        }, getAttribution: function () {
            return this.options.attribution
        }, getEvents: function () {
            var j = {viewreset: this._reset};
            if (this._zoomAnimated) {
                j.zoomanim = this._animateZoom
            }
            return j
        }, _initImage: function () {
            var j = this._image = g.DomUtil.create("img", "leaflet-image-layer " + (this._zoomAnimated ? "leaflet-zoom-animated" : ""));
            j.onselectstart = g.Util.falseFn;
            j.onmousemove = g.Util.falseFn;
            j.onload = g.bind(this.fire, this, "load");
            j.src = this._url
        }, _animateZoom: function (l) {
            var k = this._map._latLngToNewLayerPoint(this._bounds.getNorthWest(), l.zoom, l.center), j = this._map._latLngToNewLayerPoint(this._bounds.getSouthEast(), l.zoom, l.center).subtract(k), m = k.add(j._multiplyBy((1 - 1 / l.scale) / 2));
            g.DomUtil.setTransform(this._image, m, l.scale)
        }, _reset: function () {
            var l = this._image, k = new g.Bounds(this._map.latLngToLayerPoint(this._bounds.getNorthWest()), this._map.latLngToLayerPoint(this._bounds.getSouthEast())), j = k.getSize();
            g.DomUtil.setPosition(l, k.min);
            l.style.width = j.x + "px";
            l.style.height = j.y + "px"
        }, _updateOpacity: function () {
            g.DomUtil.setOpacity(this._image, this.options.opacity)
        }
    });
    g.imageOverlay = function (k, l, j) {
        return new g.ImageOverlay(k, l, j)
    };
    g.Icon = g.Class.extend({
        initialize: function (j) {
            g.setOptions(this, j)
        }, createIcon: function (j) {
            return this._createIcon("icon", j)
        }, createShadow: function (j) {
            return this._createIcon("shadow", j)
        }, _createIcon: function (k, l) {
            var m = this._getIconUrl(k);
            if (!m) {
                if (k === "icon") {
                    throw new Error("iconUrl not set in Icon options (see the docs).")
                }
                return null
            }
            var j = this._createImg(m, l && l.tagName === "IMG" ? l : null);
            this._setIconStyles(j, k);
            return j
        }, _setIconStyles: function (j, m) {
            var l = this.options, n = g.point(l[m + "Size"]), k = g.point(m === "shadow" && l.shadowAnchor || l.iconAnchor || n && n.divideBy(2, true));
            j.className = "leaflet-marker-" + m + " " + (l.className || "");
            if (k) {
                j.style.marginLeft = (-k.x) + "px";
                j.style.marginTop = (-k.y) + "px"
            }
            if (n) {
                j.style.width = n.x + "px";
                j.style.height = n.y + "px"
            }
        }, _createImg: function (k, j) {
            j = j || f.createElement("img");
            j.src = k;
            return j
        }, _getIconUrl: function (j) {
            return g.Browser.retina && this.options[j + "RetinaUrl"] || this.options[j + "Url"]
        }
    });
    g.icon = function (j) {
        return new g.Icon(j)
    };
    g.Icon.Default = g.Icon.extend({
        options: {
            iconSize: [25, 41],
            iconAnchor: [12, 41],
            popupAnchor: [1, -34],
            shadowSize: [41, 41]
        }, _getIconUrl: function (j) {
            var k = j + "Url";
            if (this.options[k]) {
                return this.options[k]
            }
            var l = g.Icon.Default.imagePath;
            if (!l) {
                throw new Error("Couldn't autodetect L.Icon.Default.imagePath, set it manually.")
            }
            return l + "/marker-" + j + (g.Browser.retina && j === "icon" ? "-2x" : "") + ".png"
        }
    });
    g.Icon.Default.imagePath = (function () {
        var k = f.getElementsByTagName("script"), m = /[\/^]leaflet[\-\._]?([\w\-\._]*)\.js\??/;
        var l, j, o, n;
        for (l = 0, j = k.length; l < j; l++) {
            o = k[l].src;
            if (o.match(m)) {
                n = o.split(m)[0];
                return (n ? n + "/" : "") + "images"
            }
        }
    }());
    g.Marker = g.Layer.extend({
        options: {
            pane: "markerPane",
            icon: new g.Icon.Default(),
            clickable: true,
            keyboard: true,
            zIndexOffset: 0,
            opacity: 1,
            riseOffset: 250
        }, initialize: function (k, j) {
            g.setOptions(this, j);
            this._latlng = g.latLng(k)
        }, onAdd: function (j) {
            this._zoomAnimated = this._zoomAnimated && j.options.markerZoomAnimation;
            this._initIcon();
            this.update()
        }, onRemove: function () {
            if (this.dragging) {
                this.dragging.disable()
            }
            this._removeIcon();
            this._removeShadow()
        }, getEvents: function () {
            var j = {viewreset: this.update};
            if (this._zoomAnimated) {
                j.zoomanim = this._animateZoom
            }
            return j
        }, getLatLng: function () {
            return this._latlng
        }, setLatLng: function (k) {
            var j = this._latlng;
            this._latlng = g.latLng(k);
            this.update();
            return this.fire("move", {oldLatLng: j, latlng: this._latlng})
        }, setZIndexOffset: function (j) {
            this.options.zIndexOffset = j;
            return this.update()
        }, setIcon: function (j) {
            this.options.icon = j;
            if (this._map) {
                this._initIcon();
                this.update()
            }
            if (this._popup) {
                this.bindPopup(this._popup)
            }
            return this
        }, update: function () {
            if (this._icon) {
                var j = this._map.latLngToLayerPoint(this._latlng).round();
                this._setPos(j)
            }
            return this
        }, _initIcon: function () {
            var k = this.options, m = "leaflet-zoom-" + (this._zoomAnimated ? "animated" : "hide");
            var l = k.icon.createIcon(this._icon), n = false;
            if (l !== this._icon) {
                if (this._icon) {
                    this._removeIcon()
                }
                n = true;
                if (k.title) {
                    l.title = k.title
                }
                if (k.alt) {
                    l.alt = k.alt
                }
            }
            g.DomUtil.addClass(l, m);
            if (k.keyboard) {
                l.tabIndex = "0"
            }
            this._icon = l;
            this._initInteraction();
            if (k.riseOnHover) {
                g.DomEvent.on(l, {mouseover: this._bringToFront, mouseout: this._resetZIndex}, this)
            }
            var j = k.icon.createShadow(this._shadow), o = false;
            if (j !== this._shadow) {
                this._removeShadow();
                o = true
            }
            if (j) {
                g.DomUtil.addClass(j, m)
            }
            this._shadow = j;
            if (k.opacity < 1) {
                this._updateOpacity()
            }
            if (n) {
                this.getPane().appendChild(this._icon)
            }
            if (j && o) {
                this.getPane("shadowPane").appendChild(this._shadow)
            }
        }, _removeIcon: function () {
            if (this.options.riseOnHover) {
                g.DomEvent.off(this._icon, {mouseover: this._bringToFront, mouseout: this._resetZIndex}, this)
            }
            g.DomUtil.remove(this._icon);
            this._icon = null
        }, _removeShadow: function () {
            if (this._shadow) {
                g.DomUtil.remove(this._shadow)
            }
            this._shadow = null
        }, _setPos: function (j) {
            g.DomUtil.setPosition(this._icon, j);
            if (this._shadow) {
                g.DomUtil.setPosition(this._shadow, j)
            }
            this._zIndex = j.y + this.options.zIndexOffset;
            this._resetZIndex()
        }, _updateZIndex: function (j) {
            this._icon.style.zIndex = this._zIndex + j
        }, _animateZoom: function (j) {
            var k = this._map._latLngToNewLayerPoint(this._latlng, j.zoom, j.center).round();
            this._setPos(k)
        }, _initInteraction: function () {
            if (!this.options.clickable) {
                return
            }
            g.DomUtil.addClass(this._icon, "leaflet-clickable");
            g.DomEvent.on(this._icon, "click dblclick mousedown mouseup mouseover mouseout contextmenu keypress", this._fireMouseEvent, this);
            if (g.Handler.MarkerDrag) {
                this.dragging = new g.Handler.MarkerDrag(this);
                if (this.options.draggable) {
                    this.dragging.enable()
                }
            }
        }, _fireMouseEvent: function (k, j) {
            if (k.type === "mousedown") {
                g.DomEvent.preventDefault(k)
            }
            if (k.type === "click" && this.dragging && this.dragging.moved()) {
                return
            }
            if (k.type === "keypress" && k.keyCode === 13) {
                j = "click"
            }
            if (this._map) {
                this._map._fireMouseEvent(this, k, j, true, this._latlng)
            }
        }, setOpacity: function (j) {
            this.options.opacity = j;
            if (this._map) {
                this._updateOpacity()
            }
            return this
        }, _updateOpacity: function () {
            var j = this.options.opacity;
            g.DomUtil.setOpacity(this._icon, j);
            if (this._shadow) {
                g.DomUtil.setOpacity(this._shadow, j)
            }
        }, _bringToFront: function () {
            this._updateZIndex(this.options.riseOffset)
        }, _resetZIndex: function () {
            this._updateZIndex(0)
        }
    });
    g.marker = function (k, j) {
        return new g.Marker(k, j)
    };
    g.DivIcon = g.Icon.extend({
        options: {iconSize: [12, 12], className: "leaflet-div-icon", html: false},
        createIcon: function (k) {
            var l = (k && k.tagName === "DIV") ? k : f.createElement("div"), j = this.options;
            l.innerHTML = j.html !== false ? j.html : "";
            if (j.bgPos) {
                l.style.backgroundPosition = (-j.bgPos.x) + "px " + (-j.bgPos.y) + "px"
            }
            this._setIconStyles(l, "icon");
            return l
        },
        createShadow: function () {
            return null
        }
    });
    g.divIcon = function (j) {
        return new g.DivIcon(j)
    };
    g.Map.mergeOptions({closePopupOnClick: true});
    g.Popup = g.Layer.extend({
        options: {
            pane: "popupPane",
            minWidth: 50,
            maxWidth: 300,
            offset: [0, 7],
            autoPan: true,
            autoPanPadding: [5, 5],
            closeButton: true,
            zoomAnimation: true
        }, initialize: function (j, k) {
            g.setOptions(this, j);
            this._source = k
        }, onAdd: function (j) {
            this._zoomAnimated = this._zoomAnimated && this.options.zoomAnimation;
            if (!this._container) {
                this._initLayout()
            }
            if (j._fadeAnimated) {
                g.DomUtil.setOpacity(this._container, 0)
            }
            clearTimeout(this._removeTimeout);
            this.getPane().appendChild(this._container);
            this.update();
            if (j._fadeAnimated) {
                g.DomUtil.setOpacity(this._container, 1)
            }
            j.fire("popupopen", {popup: this});
            if (this._source) {
                this._source.fire("popupopen", {popup: this}, true)
            }
        }, openOn: function (j) {
            j.openPopup(this);
            return this
        }, onRemove: function (j) {
            if (j._fadeAnimated) {
                g.DomUtil.setOpacity(this._container, 0);
                this._removeTimeout = setTimeout(g.bind(g.DomUtil.remove, g.DomUtil, this._container), 200)
            } else {
                g.DomUtil.remove(this._container)
            }
            j.fire("popupclose", {popup: this});
            if (this._source) {
                this._source.fire("popupclose", {popup: this}, true)
            }
        }, getLatLng: function () {
            return this._latlng
        }, setLatLng: function (j) {
            this._latlng = g.latLng(j);
            if (this._map) {
                this._updatePosition();
                this._adjustPan()
            }
            return this
        }, getContent: function () {
            return this._content
        }, setContent: function (j) {
            this._content = j;
            this.update();
            return this
        }, update: function () {
            if (!this._map) {
                return
            }
            this._container.style.visibility = "hidden";
            this._updateContent();
            this._updateLayout();
            this._updatePosition();
            this._container.style.visibility = "";
            this._adjustPan()
        }, getEvents: function () {
            var k = {viewreset: this._updatePosition}, j = this.options;
            if (this._zoomAnimated) {
                k.zoomanim = this._animateZoom
            }
            if ("closeOnClick" in j ? j.closeOnClick : this._map.options.closePopupOnClick) {
                k.preclick = this._close
            }
            if (j.keepInView) {
                k.moveend = this._adjustPan
            }
            return k
        }, isOpen: function () {
            return !!this._map && this._map.hasLayer(this)
        }, _close: function () {
            if (this._map) {
                this._map.closePopup(this)
            }
        }, _initLayout: function () {
            var l = "leaflet-popup", j = this._container = g.DomUtil.create("div", l + " " + (this.options.className || "") + " leaflet-zoom-" + (this._zoomAnimated ? "animated" : "hide"));
            if (this.options.closeButton) {
                var k = this._closeButton = g.DomUtil.create("a", l + "-close-button", j);
                k.href = "#close";
                k.innerHTML = "&#215;";
                g.DomEvent.on(k, "click", this._onCloseButtonClick, this)
            }
            var m = this._wrapper = g.DomUtil.create("div", l + "-content-wrapper", j);
            this._contentNode = g.DomUtil.create("div", l + "-content", m);
            g.DomEvent.disableClickPropagation(m).disableScrollPropagation(this._contentNode).on(m, "contextmenu", g.DomEvent.stopPropagation);
            this._tipContainer = g.DomUtil.create("div", l + "-tip-container", j);
            this._tip = g.DomUtil.create("div", l + "-tip", this._tipContainer)
        }, _updateContent: function () {
            if (!this._content) {
                return
            }
            var j = this._contentNode;
            if (typeof this._content === "string") {
                j.innerHTML = this._content
            } else {
                while (j.hasChildNodes()) {
                    j.removeChild(j.firstChild)
                }
                j.appendChild(this._content)
            }
            this.fire("contentupdate")
        }, _updateLayout: function () {
            var k = this._contentNode, m = k.style;
            m.width = "";
            m.whiteSpace = "nowrap";
            var l = k.offsetWidth;
            l = Math.min(l, this.options.maxWidth);
            l = Math.max(l, this.options.minWidth);
            m.width = (l + 1) + "px";
            m.whiteSpace = "";
            m.height = "";
            var j = k.offsetHeight, n = this.options.maxHeight, o = "leaflet-popup-scrolled";
            if (n && j > n) {
                m.height = n + "px";
                g.DomUtil.addClass(k, o)
            } else {
                g.DomUtil.removeClass(k, o)
            }
            this._containerWidth = this._container.offsetWidth
        }, _updatePosition: function () {
            if (!this._map) {
                return
            }
            var m = this._map.latLngToLayerPoint(this._latlng), l = g.point(this.options.offset);
            if (this._zoomAnimated) {
                g.DomUtil.setPosition(this._container, m)
            } else {
                l = l.add(m)
            }
            var j = this._containerBottom = -l.y, k = this._containerLeft = -Math.round(this._containerWidth / 2) + l.x;
            this._container.style.bottom = j + "px";
            this._container.style.left = k + "px"
        }, _animateZoom: function (j) {
            var k = this._map._latLngToNewLayerPoint(this._latlng, j.zoom, j.center);
            g.DomUtil.setPosition(this._container, k)
        }, _adjustPan: function () {
            if (!this.options.autoPan) {
                return
            }
            var k = this._map, t = this._container.offsetHeight, p = this._containerWidth, n = new g.Point(this._containerLeft, -t - this._containerBottom);
            if (this._zoomAnimated) {
                n._add(g.DomUtil.getPosition(this._container))
            }
            var m = k.layerPointToContainerPoint(n), o = g.point(this.options.autoPanPadding), l = g.point(this.options.autoPanPaddingTopLeft || o), j = g.point(this.options.autoPanPaddingBottomRight || o), s = k.getSize(), r = 0, q = 0;
            if (m.x + p + j.x > s.x) {
                r = m.x + p - s.x + j.x
            }
            if (m.x - r - l.x < 0) {
                r = m.x - l.x
            }
            if (m.y + t + j.y > s.y) {
                q = m.y + t - s.y + j.y
            }
            if (m.y - q - l.y < 0) {
                q = m.y - l.y
            }
            if (r || q) {
                k.fire("autopanstart").panBy([r, q])
            }
        }, _onCloseButtonClick: function (j) {
            this._close();
            g.DomEvent.stop(j)
        }
    });
    g.popup = function (j, k) {
        return new g.Popup(j, k)
    };
    g.Map.include({
        openPopup: function (j, m, k) {
            if (!(j instanceof g.Popup)) {
                var l = j;
                j = new g.Popup(k).setContent(l)
            }
            if (m) {
                j.setLatLng(m)
            }
            if (this.hasLayer(j)) {
                return this
            }
            this.closePopup();
            this._popup = j;
            return this.addLayer(j)
        }, closePopup: function (j) {
            if (!j || j === this._popup) {
                j = this._popup;
                this._popup = null
            }
            if (j) {
                this.removeLayer(j)
            }
            return this
        }
    });
    g.Layer.include({
        bindPopup: function (k, j) {
            if (k instanceof g.Popup) {
                this._popup = k;
                k._source = this
            } else {
                if (!this._popup || j) {
                    this._popup = new g.Popup(j, this)
                }
                this._popup.setContent(k)
            }
            if (!this._popupHandlersAdded) {
                this.on({click: this._openPopup, remove: this.closePopup, move: this._movePopup});
                this._popupHandlersAdded = true
            }
            return this
        }, unbindPopup: function () {
            if (this._popup) {
                this.on({click: this._openPopup, remove: this.closePopup, move: this._movePopup});
                this._popupHandlersAdded = false;
                this._popup = null
            }
            return this
        }, openPopup: function (j) {
            if (this._popup && this._map) {
                this._map.openPopup(this._popup, j || this._latlng || this.getCenter())
            }
            return this
        }, closePopup: function () {
            if (this._popup) {
                this._popup._close()
            }
            return this
        }, togglePopup: function () {
            if (this._popup) {
                if (this._popup._map) {
                    this.closePopup()
                } else {
                    this.openPopup()
                }
            }
            return this
        }, setPopupContent: function (j) {
            if (this._popup) {
                this._popup.setContent(j)
            }
            return this
        }, getPopup: function () {
            return this._popup
        }, _openPopup: function (j) {
            this._map.openPopup(this._popup, j.latlng)
        }, _movePopup: function (j) {
            this._popup.setLatLng(j.latlng)
        }
    });
    g.Marker.include({
        bindPopup: function (l, k) {
            var j = g.point(this.options.icon.options.popupAnchor || [0, 0]).add(g.Popup.prototype.options.offset);
            k = g.extend({offset: j}, k);
            return g.Layer.prototype.bindPopup.call(this, l, k)
        }, _openPopup: g.Layer.prototype.togglePopup
    });
    g.LayerGroup = g.Layer.extend({
        initialize: function (l) {
            this._layers = {};
            var k, j;
            if (l) {
                for (k = 0, j = l.length; k < j; k++) {
                    this.addLayer(l[k])
                }
            }
        }, addLayer: function (j) {
            var k = this.getLayerId(j);
            this._layers[k] = j;
            if (this._map) {
                this._map.addLayer(j)
            }
            return this
        }, removeLayer: function (j) {
            var k = j in this._layers ? j : this.getLayerId(j);
            if (this._map && this._layers[k]) {
                this._map.removeLayer(this._layers[k])
            }
            delete this._layers[k];
            return this
        }, hasLayer: function (j) {
            return !!j && (j in this._layers || this.getLayerId(j) in this._layers)
        }, clearLayers: function () {
            for (var j in this._layers) {
                this.removeLayer(this._layers[j])
            }
            return this
        }, invoke: function (j) {
            var k = Array.prototype.slice.call(arguments, 1), m, l;
            for (m in this._layers) {
                l = this._layers[m];
                if (l[j]) {
                    l[j].apply(l, k)
                }
            }
            return this
        }, onAdd: function (k) {
            for (var j in this._layers) {
                k.addLayer(this._layers[j])
            }
        }, onRemove: function (k) {
            for (var j in this._layers) {
                k.removeLayer(this._layers[j])
            }
        }, eachLayer: function (l, k) {
            for (var j in this._layers) {
                l.call(k, this._layers[j])
            }
            return this
        }, getLayer: function (j) {
            return this._layers[j]
        }, getLayers: function () {
            var k = [];
            for (var j in this._layers) {
                k.push(this._layers[j])
            }
            return k
        }, setZIndex: function (j) {
            return this.invoke("setZIndex", j)
        }, getLayerId: function (j) {
            return g.stamp(j)
        }
    });
    g.layerGroup = function (j) {
        return new g.LayerGroup(j)
    };
    g.FeatureGroup = g.LayerGroup.extend({
        addLayer: function (j) {
            if (this.hasLayer(j)) {
                return this
            }
            j.addEventParent(this);
            g.LayerGroup.prototype.addLayer.call(this, j);
            if (this._popupContent && j.bindPopup) {
                j.bindPopup(this._popupContent, this._popupOptions)
            }
            return this.fire("layeradd", {layer: j})
        }, removeLayer: function (j) {
            if (!this.hasLayer(j)) {
                return this
            }
            if (j in this._layers) {
                j = this._layers[j]
            }
            j.removeEventParent(this);
            g.LayerGroup.prototype.removeLayer.call(this, j);
            if (this._popupContent) {
                this.invoke("unbindPopup")
            }
            return this.fire("layerremove", {layer: j})
        }, bindPopup: function (k, j) {
            this._popupContent = k;
            this._popupOptions = j;
            return this.invoke("bindPopup", k, j)
        }, openPopup: function (k) {
            for (var j in this._layers) {
                this._layers[j].openPopup(k);
                break
            }
            return this
        }, setStyle: function (j) {
            return this.invoke("setStyle", j)
        }, bringToFront: function () {
            return this.invoke("bringToFront")
        }, bringToBack: function () {
            return this.invoke("bringToBack")
        }, getBounds: function () {
            var j = new g.LatLngBounds();
            this.eachLayer(function (k) {
                j.extend(k.getBounds ? k.getBounds() : k.getLatLng())
            });
            return j
        }
    });
    g.featureGroup = function (j) {
        return new g.FeatureGroup(j)
    };
    g.Renderer = g.Layer.extend({
        options: {padding: 0}, initialize: function (j) {
            g.setOptions(this, j);
            g.stamp(this)
        }, onAdd: function () {
            if (!this._container) {
                this._initContainer();
                if (this._zoomAnimated) {
                    g.DomUtil.addClass(this._container, "leaflet-zoom-animated")
                }
            }
            this.getPane().appendChild(this._container);
            this._update()
        }, onRemove: function () {
            g.DomUtil.remove(this._container)
        }, getEvents: function () {
            var j = {moveend: this._update};
            if (this._zoomAnimated) {
                j.zoomanim = this._animateZoom
            }
            return j
        }, _animateZoom: function (k) {
            var j = k.origin.subtract(this._map._getCenterLayerPoint()), l = this._bounds.min.add(j.multiplyBy(1 - k.scale));
            g.DomUtil.setTransform(this._container, l, k.scale)
        }, _update: function () {
            var l = this.options.padding, k = this._map.getSize(), j = this._map.containerPointToLayerPoint(k.multiplyBy(-l)).round();
            this._bounds = new g.Bounds(j, j.add(k.multiplyBy(1 + l * 2)).round())
        }
    });
    g.Map.include({
        getRenderer: function (j) {
            var k = j.options.renderer || this.options.renderer || this._renderer;
            if (!k) {
                k = this._renderer = (g.SVG && g.svg()) || (g.Canvas && g.canvas())
            }
            if (!this.hasLayer(k)) {
                this.addLayer(k)
            }
            return k
        }
    });
    g.Path = g.Layer.extend({
        options: {
            stroke: true,
            color: "#3388ff",
            weight: 3,
            opacity: 1,
            lineCap: "round",
            lineJoin: "round",
            fillOpacity: 0.2,
            clickable: true
        }, onAdd: function () {
            this._renderer = this._map.getRenderer(this);
            this._renderer._initPath(this);
            this._project();
            this._update();
            this._renderer._addPath(this)
        }, onRemove: function () {
            this._renderer._removePath(this)
        }, getEvents: function () {
            return {viewreset: this._project, moveend: this._update}
        }, redraw: function () {
            if (this._map) {
                this._renderer._updatePath(this)
            }
            return this
        }, setStyle: function (j) {
            g.setOptions(this, j);
            if (this._renderer) {
                this._renderer._updateStyle(this)
            }
            return this
        }, bringToFront: function () {
            this._renderer._bringToFront(this);
            return this
        }, bringToBack: function () {
            this._renderer._bringToBack(this);
            return this
        }, _fireMouseEvent: function (k, j) {
            this._map._fireMouseEvent(this, k, j, true)
        }, _clickTolerance: function () {
            return (this.options.stroke ? this.options.weight / 2 : 0) + (g.Browser.touch ? 10 : 0)
        }
    });
    g.LineUtil = {
        simplify: function (l, j) {
            if (!j || !l.length) {
                return l.slice()
            }
            var k = j * j;
            l = this._reducePoints(l, k);
            l = this._simplifyDP(l, k);
            return l
        }, pointToSegmentDistance: function (k, l, j) {
            return Math.sqrt(this._sqClosestPointOnSegment(k, l, j, true))
        }, closestPointOnSegment: function (k, l, j) {
            return this._sqClosestPointOnSegment(k, l, j)
        }, _simplifyDP: function (n, k) {
            var j = n.length, m = typeof Uint8Array !== b + "" ? Uint8Array : Array, p = new m(j);
            p[0] = p[j - 1] = 1;
            this._simplifyDPStep(n, p, k, 0, j - 1);
            var l, o = [];
            for (l = 0; l < j; l++) {
                if (p[l]) {
                    o.push(n[l])
                }
            }
            return o
        }, _simplifyDPStep: function (r, k, j, o, q) {
            var l = 0, p, m, n;
            for (m = o + 1; m <= q - 1; m++) {
                n = this._sqClosestPointOnSegment(r[m], r[o], r[q], true);
                if (n > l) {
                    p = m;
                    l = n
                }
            }
            if (l > j) {
                k[p] = 1;
                this._simplifyDPStep(r, k, j, o, p);
                this._simplifyDPStep(r, k, j, p, q)
            }
        }, _reducePoints: function (m, k) {
            var o = [m[0]];
            for (var l = 1, n = 0, j = m.length; l < j; l++) {
                if (this._sqDist(m[l], m[n]) > k) {
                    o.push(m[l]);
                    n = l
                }
            }
            if (n < j - 1) {
                o.push(m[j - 1])
            }
            return o
        }, clipSegment: function (r, q, j, s) {
            var n = s ? this._lastCode : this._getBitCode(r, j), l = this._getBitCode(q, j), m, k, o;
            this._lastCode = l;
            while (true) {
                if (!(n | l)) {
                    return [r, q]
                } else {
                    if (n & l) {
                        return false
                    } else {
                        m = n || l;
                        k = this._getEdgeIntersection(r, q, m, j);
                        o = this._getBitCode(k, j);
                        if (m === n) {
                            r = k;
                            n = o
                        } else {
                            q = k;
                            l = o
                        }
                    }
                }
            }
        }, _getEdgeIntersection: function (q, n, k, j) {
            var s = n.x - q.x, r = n.y - q.y, l = j.min, o = j.max, p, m;
            if (k & 8) {
                p = q.x + s * (o.y - q.y) / r;
                m = o.y
            } else {
                if (k & 4) {
                    p = q.x + s * (l.y - q.y) / r;
                    m = l.y
                } else {
                    if (k & 2) {
                        p = o.x;
                        m = q.y + r * (o.x - q.x) / s
                    } else {
                        if (k & 1) {
                            p = l.x;
                            m = q.y + r * (l.x - q.x) / s
                        }
                    }
                }
            }
            return new g.Point(p, m, true)
        }, _getBitCode: function (l, k) {
            var j = 0;
            if (l.x < k.min.x) {
                j |= 1
            } else {
                if (l.x > k.max.x) {
                    j |= 2
                }
            }
            if (l.y < k.min.y) {
                j |= 4
            } else {
                if (l.y > k.max.y) {
                    j |= 8
                }
            }
            return j
        }, _sqDist: function (m, l) {
            var k = l.x - m.x, j = l.y - m.y;
            return k * k + j * j
        }, _sqClosestPointOnSegment: function (k, q, o, l) {
            var n = q.x, m = q.y, u = o.x - n, s = o.y - m, j = u * u + s * s, r;
            if (j > 0) {
                r = ((k.x - n) * u + (k.y - m) * s) / j;
                if (r > 1) {
                    n = o.x;
                    m = o.y
                } else {
                    if (r > 0) {
                        n += u * r;
                        m += s * r
                    }
                }
            }
            u = k.x - n;
            s = k.y - m;
            return l ? u * u + s * s : new g.Point(n, m)
        }
    };
    g.Polyline = g.Path.extend({
        options: {smoothFactor: 1}, initialize: function (j, k) {
            g.setOptions(this, k);
            this._setLatLngs(j)
        }, getLatLngs: function () {
            return this._latlngs
        }, setLatLngs: function (j) {
            this._setLatLngs(j);
            return this.redraw()
        }, addLatLng: function (j) {
            j = g.latLng(j);
            this._latlngs.push(j);
            this._bounds.extend(j);
            return this.redraw()
        }, spliceLatLngs: function () {
            var j = [].splice.apply(this._latlngs, arguments);
            this._setLatLngs(this._latlngs);
            this.redraw();
            return j
        }, closestLayerPoint: function (k) {
            var t = Infinity, r = null, l = g.LineUtil._sqClosestPointOnSegment, v, u;
            for (var m = 0, w = this._parts.length; m < w; m++) {
                var s = this._parts[m];
                for (var n = 1, q = s.length; n < q; n++) {
                    v = s[n - 1];
                    u = s[n];
                    var o = l(k, v, u, true);
                    if (o < t) {
                        t = o;
                        r = l(k, v, u)
                    }
                }
            }
            if (r) {
                r.distance = Math.sqrt(t)
            }
            return r
        }, getCenter: function () {
            var l, j, k, o, r, p, n, q = this._rings[0], m = q.length;
            for (l = 0, j = 0; l < m - 1; l++) {
                j += q[l].distanceTo(q[l + 1]) / 2
            }
            for (l = 0, o = 0; l < m - 1; l++) {
                r = q[l];
                p = q[l + 1];
                k = r.distanceTo(p);
                o += k;
                if (o > j) {
                    n = (o - j) / k;
                    return this._map.layerPointToLatLng([p.x - n * (p.x - r.x), p.y - n * (p.y - r.y)])
                }
            }
        }, getBounds: function () {
            return this._bounds
        }, _setLatLngs: function (j) {
            this._bounds = new g.LatLngBounds();
            this._latlngs = this._convertLatLngs(j)
        }, _convertLatLngs: function (l) {
            var k = [], n = this._flat(l);
            for (var m = 0, j = l.length; m < j; m++) {
                if (n) {
                    k[m] = g.latLng(l[m]);
                    this._bounds.extend(k[m])
                } else {
                    k[m] = this._convertLatLngs(l[m])
                }
            }
            return k
        }, _flat: function (j) {
            return !g.Util.isArray(j[0]) || typeof j[0][0] !== "object"
        }, _project: function () {
            this._rings = [];
            this._projectLatlngs(this._latlngs, this._rings);
            var j = this._clickTolerance(), k = new g.Point(j, -j);
            if (this._latlngs.length) {
                this._pxBounds = new g.Bounds(this._map.latLngToLayerPoint(this._bounds.getSouthWest())._subtract(k), this._map.latLngToLayerPoint(this._bounds.getNorthEast())._add(k))
            }
        }, _projectLatlngs: function (l, k) {
            var o = l[0] instanceof g.LatLng, j = l.length, n, m;
            if (o) {
                m = [];
                for (n = 0; n < j; n++) {
                    m[n] = this._map.latLngToLayerPoint(l[n])
                }
                k.push(m)
            } else {
                for (n = 0; n < j; n++) {
                    this._projectLatlngs(l[n], k)
                }
            }
        }, _clipPoints: function () {
            if (this.options.noClip) {
                this._parts = this._rings;
                return
            }
            this._parts = [];
            var o = this._parts, l = this._renderer._bounds, q, p, m, s, n, r, t;
            for (q = 0, m = 0, s = this._rings.length; q < s; q++) {
                t = this._rings[q];
                for (p = 0, n = t.length; p < n - 1; p++) {
                    r = g.LineUtil.clipSegment(t[p], t[p + 1], l, p);
                    if (!r) {
                        continue
                    }
                    o[m] = o[m] || [];
                    o[m].push(r[0]);
                    if ((r[1] !== t[p + 1]) || (p === n - 2)) {
                        o[m].push(r[1]);
                        m++
                    }
                }
            }
        }, _simplifyPoints: function () {
            var m = this._parts, k = this.options.smoothFactor;
            for (var l = 0, j = m.length; l < j; l++) {
                m[l] = g.LineUtil.simplify(m[l], k)
            }
        }, _update: function () {
            if (!this._map) {
                return
            }
            this._clipPoints();
            this._simplifyPoints();
            this._updatePath()
        }, _updatePath: function () {
            this._renderer._updatePoly(this)
        }
    });
    g.polyline = function (j, k) {
        return new g.Polyline(j, k)
    };
    g.PolyUtil = {};
    g.PolyUtil.clipPolygon = function (y, l) {
        var v, s = [1, 4, 2, 8], t, r, q, x, w, u, n, m, o = g.LineUtil;
        for (t = 0, u = y.length; t < u; t++) {
            y[t]._code = o._getBitCode(y[t], l)
        }
        for (q = 0; q < 4; q++) {
            n = s[q];
            v = [];
            for (t = 0, u = y.length, r = u - 1; t < u; r = t++) {
                x = y[t];
                w = y[r];
                if (!(x._code & n)) {
                    if (w._code & n) {
                        m = o._getEdgeIntersection(w, x, n, l);
                        m._code = o._getBitCode(m, l);
                        v.push(m)
                    }
                    v.push(x)
                } else {
                    if (!(w._code & n)) {
                        m = o._getEdgeIntersection(w, x, n, l);
                        m._code = o._getBitCode(m, l);
                        v.push(m)
                    }
                }
            }
            y = v
        }
        return y
    };
    g.Polygon = g.Polyline.extend({
        options: {fill: true}, getCenter: function () {
            var m, l, o, t, s, n, k, q, p, r = this._rings[0];
            k = q = p = 0;
            for (m = 0, o = r.length, l = o - 1; m < o; l = m++) {
                t = r[m];
                s = r[l];
                n = t.y * s.x - s.y * t.x;
                q += (t.x + s.x) * n;
                p += (t.y + s.y) * n;
                k += n * 3
            }
            return this._map.layerPointToLatLng([q / k, p / k])
        }, _convertLatLngs: function (l) {
            var k = g.Polyline.prototype._convertLatLngs.call(this, l), j = k.length;
            if (j >= 2 && k[0] instanceof g.LatLng && k[0].equals(k[j - 1])) {
                k.pop()
            }
            return k
        }, _clipPoints: function () {
            if (this.options.noClip) {
                this._parts = this._rings;
                return
            }
            var n = this._renderer._bounds, l = this.options.weight, o = new g.Point(l, l);
            n = new g.Bounds(n.min.subtract(o), n.max.add(o));
            this._parts = [];
            for (var m = 0, k = this._rings.length, j; m < k; m++) {
                j = g.PolyUtil.clipPolygon(this._rings[m], n);
                if (j.length) {
                    this._parts.push(j)
                }
            }
        }, _updatePath: function () {
            this._renderer._updatePoly(this, true)
        }
    });
    g.polygon = function (j, k) {
        return new g.Polygon(j, k)
    };
    g.Rectangle = g.Polygon.extend({
        initialize: function (k, j) {
            g.Polygon.prototype.initialize.call(this, this._boundsToLatLngs(k), j)
        }, setBounds: function (j) {
            this.setLatLngs(this._boundsToLatLngs(j))
        }, _boundsToLatLngs: function (j) {
            j = g.latLngBounds(j);
            return [j.getSouthWest(), j.getNorthWest(), j.getNorthEast(), j.getSouthEast()]
        }
    });
    g.rectangle = function (k, j) {
        return new g.Rectangle(k, j)
    };
    g.CircleMarker = g.Path.extend({
        options: {fill: true, radius: 10}, initialize: function (k, j) {
            g.setOptions(this, j);
            this._latlng = g.latLng(k);
            this._radius = this.options.radius
        }, setLatLng: function (j) {
            this._latlng = g.latLng(j);
            this.redraw();
            return this.fire("move", {latlng: this._latlng})
        }, getLatLng: function () {
            return this._latlng
        }, setRadius: function (j) {
            this.options.radius = this._radius = j;
            return this.redraw()
        }, getRadius: function () {
            return this._radius
        }, setStyle: function (k) {
            var j = k && k.radius || this._radius;
            g.Path.prototype.setStyle.call(this, k);
            this.setRadius(j);
            return this
        }, _project: function () {
            this._point = this._map.latLngToLayerPoint(this._latlng);
            this._updateBounds()
        }, _updateBounds: function () {
            var l = this._radius, k = this._radiusY || l, j = this._clickTolerance(), m = [l + j, k + j];
            this._pxBounds = new g.Bounds(this._point.subtract(m), this._point.add(m))
        }, _update: function () {
            if (this._map) {
                this._updatePath()
            }
        }, _updatePath: function () {
            this._renderer._updateCircle(this)
        }, _empty: function () {
            return this._radius && !this._renderer._bounds.intersects(this._pxBounds)
        }
    });
    g.circleMarker = function (k, j) {
        return new g.CircleMarker(k, j)
    };
    g.Circle = g.CircleMarker.extend({
        initialize: function (l, j, k) {
            g.setOptions(this, k);
            this._latlng = g.latLng(l);
            this._mRadius = j
        }, setRadius: function (j) {
            this._mRadius = j;
            return this.redraw()
        }, getRadius: function () {
            return this._mRadius
        }, getBounds: function () {
            var j = [this._radius, this._radiusY];
            return new g.LatLngBounds(this._map.layerPointToLatLng(this._point.subtract(j)), this._map.layerPointToLatLng(this._point.add(j)))
        }, setStyle: g.Path.prototype.setStyle, _project: function () {
            var s = this._latlng.lng, q = this._latlng.lat, k = this._map, u = k.options.crs;
            if (u.distance === g.CRS.Earth.distance) {
                var o = Math.PI / 180, v = (this._mRadius / g.CRS.Earth.R) / o, r = k.project([q + v, s]), j = k.project([q - v, s]), l = r.add(j).divideBy(2), n = k.unproject(l).lat, m = Math.acos((Math.cos(v * o) - Math.sin(q * o) * Math.sin(n * o)) / (Math.cos(q * o) * Math.cos(n * o))) / o;
                this._point = l.subtract(k.getPixelOrigin());
                this._radius = isNaN(m) ? 0 : Math.max(Math.round(l.x - k.project([n, s - m]).x), 1);
                this._radiusY = Math.max(Math.round(l.y - r.y), 1)
            } else {
                var t = u.unproject(u.project(this._latlng).subtract([this._mRadius, 0]));
                this._point = k.latLngToLayerPoint(this._latlng);
                this._radius = this._point.x - k.latLngToLayerPoint(t).x
            }
            this._updateBounds()
        }
    });
    g.circle = function (l, j, k) {
        return new g.Circle(l, j, k)
    };
    g.SVG = g.Renderer.extend({
        _initContainer: function () {
            this._container = g.SVG.create("svg");
            this._paths = {};
            this._initEvents();
            this._container.setAttribute("pointer-events", "none")
        }, _update: function () {
            if (this._map._animatingZoom && this._bounds) {
                return
            }
            g.Renderer.prototype._update.call(this);
            var j = this._bounds, l = j.getSize(), k = this._container, m = this.getPane();
            if (g.Browser.mobileWebkit) {
                m.removeChild(k)
            }
            g.DomUtil.setPosition(k, j.min);
            if (!this._svgSize || !this._svgSize.equals(l)) {
                this._svgSize = l;
                k.setAttribute("width", l.x);
                k.setAttribute("height", l.y)
            }
            g.DomUtil.setPosition(k, j.min);
            k.setAttribute("viewBox", [j.min.x, j.min.y, l.x, l.y].join(" "));
            if (g.Browser.mobileWebkit) {
                m.appendChild(k)
            }
        }, _initPath: function (j) {
            var k = j._path = g.SVG.create("path");
            if (j.options.className) {
                g.DomUtil.addClass(k, j.options.className)
            }
            if (j.options.clickable) {
                g.DomUtil.addClass(k, "leaflet-clickable")
            }
            this._updateStyle(j)
        }, _addPath: function (j) {
            var k = j._path;
            this._container.appendChild(k);
            this._paths[g.stamp(k)] = j
        }, _removePath: function (j) {
            var k = j._path;
            g.DomUtil.remove(k);
            delete this._paths[g.stamp(k)]
        }, _updatePath: function (j) {
            j._project();
            j._update()
        }, _updateStyle: function (k) {
            var l = k._path, j = k.options;
            if (!l) {
                return
            }
            if (j.stroke) {
                l.setAttribute("stroke", j.color);
                l.setAttribute("stroke-opacity", j.opacity);
                l.setAttribute("stroke-width", j.weight);
                l.setAttribute("stroke-linecap", j.lineCap);
                l.setAttribute("stroke-linejoin", j.lineJoin);
                if (j.dashArray) {
                    l.setAttribute("stroke-dasharray", j.dashArray)
                } else {
                    l.removeAttribute("stroke-dasharray")
                }
                if (j.dashOffset) {
                    l.setAttribute("stroke-dashoffset", j.dashOffset)
                } else {
                    l.removeAttribute("stroke-dashoffset")
                }
            } else {
                l.setAttribute("stroke", "none")
            }
            if (j.fill) {
                l.setAttribute("fill", j.fillColor || j.color);
                l.setAttribute("fill-opacity", j.fillOpacity);
                l.setAttribute("fill-rule", "evenodd")
            } else {
                l.setAttribute("fill", "none")
            }
            l.setAttribute("pointer-events", j.pointerEvents || (j.clickable ? "visiblePainted" : "none"))
        }, _updatePoly: function (k, j) {
            this._setPath(k, g.SVG.pointsToPath(k._parts, j))
        }, _updateCircle: function (l) {
            var n = l._point, m = l._radius, j = l._radiusY || m, k = "a" + m + "," + j + " 0 1,0 ";
            var o = l._empty() ? "M0 0" : "M" + (n.x - m) + "," + n.y + k + (m * 2) + ",0 " + k + (-m * 2) + ",0 ";
            this._setPath(l, o)
        }, _setPath: function (j, k) {
            j._path.setAttribute("d", k)
        }, _bringToFront: function (j) {
            g.DomUtil.toFront(j._path)
        }, _bringToBack: function (j) {
            g.DomUtil.toBack(j._path)
        }, _initEvents: function () {
            g.DomEvent.on(this._container, "click dblclick mousedown mouseup mouseover mouseout mousemove contextmenu", this._fireMouseEvent, this)
        }, _fireMouseEvent: function (k) {
            var j = this._paths[g.stamp(k.target || k.srcElement)];
            if (j) {
                j._fireMouseEvent(k)
            }
        }
    });
    g.extend(g.SVG, {
        create: function (j) {
            return f.createElementNS("http://www.w3.org/2000/svg", j)
        }, pointsToPath: function (s, o) {
            var r = "", n, m, q, l, t, k;
            for (n = 0, q = s.length; n < q; n++) {
                t = s[n];
                for (m = 0, l = t.length; m < l; m++) {
                    k = t[m];
                    r += (m ? "L" : "M") + k.x + " " + k.y
                }
                r += o ? (g.Browser.svg ? "z" : "x") : ""
            }
            return r || "M0 0"
        }
    });
    g.Browser.svg = !!(f.createElementNS && g.SVG.create("svg").createSVGRect);
    g.svg = function (j) {
        return g.Browser.svg || g.Browser.vml ? new g.SVG(j) : null
    };
    g.Browser.vml = !g.Browser.svg && (function () {
            try {
                var l = f.createElement("div");
                l.innerHTML = '<v:shape adj="1"/>';
                var j = l.firstChild;
                j.style.behavior = "url(#default#VML)";
                return j && (typeof j.adj === "object")
            } catch (k) {
                return false
            }
        }());
    g.SVG.include(!g.Browser.vml ? {} : {
        _initContainer: function () {
            this._container = g.DomUtil.create("div", "leaflet-vml-container");
            this._paths = {};
            this._initEvents()
        }, _update: function () {
            if (this._map._animatingZoom) {
                return
            }
            g.Renderer.prototype._update.call(this)
        }, _initPath: function (k) {
            var j = k._container = g.SVG.create("shape");
            g.DomUtil.addClass(j, "leaflet-vml-shape " + (this.options.className || ""));
            j.coordsize = "1 1";
            k._path = g.SVG.create("path");
            j.appendChild(k._path);
            this._updateStyle(k)
        }, _addPath: function (k) {
            var j = k._container;
            this._container.appendChild(j);
            this._paths[g.stamp(j)] = k
        }, _removePath: function (k) {
            var j = k._container;
            g.DomUtil.remove(j);
            delete this._paths[g.stamp(j)]
        }, _updateStyle: function (l) {
            var n = l._stroke, m = l._fill, k = l.options, j = l._container;
            j.stroked = !!k.stroke;
            j.filled = !!k.fill;
            if (k.stroke) {
                if (!n) {
                    n = l._stroke = g.SVG.create("stroke");
                    j.appendChild(n)
                }
                n.weight = k.weight + "px";
                n.color = k.color;
                n.opacity = k.opacity;
                if (k.dashArray) {
                    n.dashStyle = g.Util.isArray(k.dashArray) ? k.dashArray.join(" ") : k.dashArray.replace(/( *, *)/g, " ")
                } else {
                    n.dashStyle = ""
                }
                n.endcap = k.lineCap.replace("butt", "flat");
                n.joinstyle = k.lineJoin
            } else {
                if (n) {
                    j.removeChild(n);
                    l._stroke = null
                }
            }
            if (k.fill) {
                if (!m) {
                    m = l._fill = g.SVG.create("fill");
                    j.appendChild(m)
                }
                m.color = k.fillColor || k.color;
                m.opacity = k.fillOpacity
            } else {
                if (m) {
                    j.removeChild(m);
                    l._fill = null
                }
            }
        }, _updateCircle: function (k) {
            var m = k._point, l = Math.round(k._radius), j = Math.round(k._radiusY || l);
            this._setPath(k, k._empty() ? "M0 0" : "AL " + m.x + "," + m.y + " " + l + "," + j + " 0," + (65535 * 360))
        }, _setPath: function (j, k) {
            j._path.v = k
        }
    });
    if (g.Browser.vml) {
        g.SVG.create = (function () {
            try {
                f.namespaces.add("lvml", "urn:schemas-microsoft-com:vml");
                return function (k) {
                    return f.createElement("<lvml:" + k + ' class="lvml">')
                }
            } catch (j) {
                return function (k) {
                    return f.createElement("<" + k + ' xmlns="urn:schemas-microsoft.com:vml" class="lvml">')
                }
            }
        })()
    }
    g.Canvas = g.Renderer.extend({
        onAdd: function () {
            g.Renderer.prototype.onAdd.call(this);
            this._layers = this._layers || {};
            this._draw()
        }, _initContainer: function () {
            var j = this._container = f.createElement("canvas");
            g.DomEvent.on(j, "mousemove", this._onMouseMove, this).on(j, "click dblclick mousedown mouseup contextmenu", this._onClick, this);
            this._ctx = j.getContext("2d")
        }, _update: function () {
            if (this._map._animatingZoom && this._bounds) {
                return
            }
            g.Renderer.prototype._update.call(this);
            var k = this._bounds, l = this._container, n = k.getSize(), j = g.Browser.retina ? 2 : 1;
            g.DomUtil.setPosition(l, k.min);
            l.width = j * n.x;
            l.height = j * n.y;
            l.style.width = n.x + "px";
            l.style.height = n.y + "px";
            if (g.Browser.retina) {
                this._ctx.scale(2, 2)
            }
            this._ctx.translate(-k.min.x, -k.min.y)
        }, _initPath: function (j) {
            this._layers[g.stamp(j)] = j
        }, _addPath: g.Util.falseFn, _removePath: function (j) {
            j._removed = true;
            this._requestRedraw(j)
        }, _updatePath: function (j) {
            this._redrawBounds = j._pxBounds;
            this._draw(true);
            j._project();
            j._update();
            this._draw();
            this._redrawBounds = null
        }, _updateStyle: function (j) {
            this._requestRedraw(j)
        }, _requestRedraw: function (j) {
            if (!this._map) {
                return
            }
            this._redrawBounds = this._redrawBounds || new g.Bounds();
            this._redrawBounds.extend(j._pxBounds.min).extend(j._pxBounds.max);
            this._redrawRequest = this._redrawRequest || g.Util.requestAnimFrame(this._redraw, this)
        }, _redraw: function () {
            this._redrawRequest = null;
            this._draw(true);
            this._draw();
            this._redrawBounds = null
        }, _draw: function (j) {
            this._clear = j;
            var k;
            for (var l in this._layers) {
                k = this._layers[l];
                if (!this._redrawBounds || k._pxBounds.intersects(this._redrawBounds)) {
                    k._updatePath()
                }
                if (j && k._removed) {
                    delete k._removed;
                    delete this._layers[l]
                }
            }
        }, _updatePoly: function (q, r) {
            var o, n, l, k, m = q._parts, s = m.length, t = this._ctx;
            if (!s) {
                return
            }
            t.beginPath();
            for (o = 0; o < s; o++) {
                for (n = 0, l = m[o].length; n < l; n++) {
                    k = m[o][n];
                    t[n ? "lineTo" : "moveTo"](k.x, k.y)
                }
                if (r) {
                    t.closePath()
                }
            }
            this._fillStroke(t, q)
        }, _updateCircle: function (k) {
            if (k._empty()) {
                return
            }
            var n = k._point, j = this._ctx, m = k._radius, l = (k._radiusY || m) / m;
            if (l !== 1) {
                j.save();
                j.scale(1, l)
            }
            j.beginPath();
            j.arc(n.x, n.y / l, m, 0, Math.PI * 2, false);
            if (l !== 1) {
                j.restore()
            }
            this._fillStroke(j, k)
        }, _fillStroke: function (k, m) {
            var j = this._clear, l = m.options;
            k.globalCompositeOperation = j ? "destination-out" : "source-over";
            if (l.fill) {
                k.globalAlpha = j ? 1 : l.fillOpacity;
                k.fillStyle = l.fillColor || l.color;
                k.fill("evenodd")
            }
            if (l.stroke) {
                k.globalAlpha = j ? 1 : l.opacity;
                m._prevWeight = k.lineWidth = j ? m._prevWeight + 1 : l.weight;
                k.strokeStyle = l.color;
                k.lineCap = l.lineCap;
                k.lineJoin = l.lineJoin;
                k.stroke()
            }
        }, _onClick: function (k) {
            var j = this._map.mouseEventToLayerPoint(k);
            for (var l in this._layers) {
                if (this._layers[l]._containsPoint(j)) {
                    this._layers[l]._fireMouseEvent(k)
                }
            }
        }, _onMouseMove: function (k) {
            if (!this._map || this._map._animatingZoom) {
                return
            }
            var j = this._map.mouseEventToLayerPoint(k);
            for (var l in this._layers) {
                this._handleHover(this._layers[l], k, j)
            }
        }, _handleHover: function (k, l, j) {
            if (!k.options.clickable) {
                return
            }
            if (k._containsPoint(j)) {
                if (!k._mouseInside) {
                    g.DomUtil.addClass(this._container, "leaflet-clickable");
                    k._fireMouseEvent(l, "mouseover");
                    k._mouseInside = true
                }
                k._fireMouseEvent(l)
            } else {
                if (k._mouseInside) {
                    g.DomUtil.removeClass(this._container, "leaflet-clickable");
                    k._fireMouseEvent(l, "mouseout");
                    k._mouseInside = false
                }
            }
        }, _bringToFront: g.Util.falseFn, _bringToBack: g.Util.falseFn
    });
    g.Browser.canvas = (function () {
        return !!f.createElement("canvas").getContext
    }());
    g.canvas = function (j) {
        return g.Browser.canvas ? new g.Canvas(j) : null
    };
    g.Polyline.prototype._containsPoint = function (l, s) {
        var r, q, n, t, o, m, u = this._clickTolerance();
        if (!this._pxBounds.contains(l)) {
            return false
        }
        for (r = 0, t = this._parts.length; r < t; r++) {
            m = this._parts[r];
            for (q = 0, o = m.length, n = o - 1; q < o; n = q++) {
                if (!s && (q === 0)) {
                    continue
                }
                if (g.LineUtil.pointToSegmentDistance(l, m[n], m[q]) <= u) {
                    return true
                }
            }
        }
        return false
    };
    g.Polygon.prototype._containsPoint = function (l) {
        var n = false, m, v, u, s, r, q, t, o;
        if (!this._pxBounds.contains(l)) {
            return false
        }
        for (s = 0, t = this._parts.length; s < t; s++) {
            m = this._parts[s];
            for (r = 0, o = m.length, q = o - 1; r < o; q = r++) {
                v = m[r];
                u = m[q];
                if (((v.y > l.y) !== (u.y > l.y)) && (l.x < (u.x - v.x) * (l.y - v.y) / (u.y - v.y) + v.x)) {
                    n = !n
                }
            }
        }
        return n || g.Polyline.prototype._containsPoint.call(this, l, true)
    };
    g.CircleMarker.prototype._containsPoint = function (j) {
        return j.distanceTo(this._point) <= this._radius + this._clickTolerance()
    };
    g.GeoJSON = g.FeatureGroup.extend({
        initialize: function (k, j) {
            g.setOptions(this, j);
            this._layers = {};
            if (k) {
                this.addData(k)
            }
        }, addData: function (l) {
            var p = g.Util.isArray(l) ? l : l.features, o, j, n;
            if (p) {
                for (o = 0, j = p.length; o < j; o++) {
                    n = p[o];
                    if (n.geometries || n.geometry || n.features || n.coordinates) {
                        this.addData(n)
                    }
                }
                return this
            }
            var k = this.options;
            if (k.filter && !k.filter(l)) {
                return
            }
            var m = g.GeoJSON.geometryToLayer(l, k);
            m.feature = g.GeoJSON.asFeature(l);
            m.defaultOptions = m.options;
            this.resetStyle(m);
            if (k.onEachFeature) {
                k.onEachFeature(l, m)
            }
            return this.addLayer(m)
        }, resetStyle: function (j) {
            j.options = j.defaultOptions;
            this._setLayerStyle(j, this.options.style);
            return this
        }, setStyle: function (j) {
            return this.eachLayer(function (k) {
                this._setLayerStyle(k, j)
            }, this)
        }, _setLayerStyle: function (j, k) {
            if (typeof k === "function") {
                k = k(j.feature)
            }
            if (j.setStyle) {
                j.setStyle(k)
            }
        }
    });
    g.extend(g.GeoJSON, {
        geometryToLayer: function (k, t) {
            var r = k.type === "Feature" ? k.geometry : k, s = r.coordinates, p = [], l = t && t.pointToLayer, m = t && t.coordsToLatLng || this.coordsToLatLng, n, j, o, q;
            switch (r.type) {
                case"Point":
                    n = m(s);
                    return l ? l(k, n) : new g.Marker(n);
                case"MultiPoint":
                    for (o = 0, q = s.length; o < q; o++) {
                        n = m(s[o]);
                        p.push(l ? l(k, n) : new g.Marker(n))
                    }
                    return new g.FeatureGroup(p);
                case"LineString":
                case"MultiLineString":
                    j = this.coordsToLatLngs(s, r.type === "LineString" ? 0 : 1, m);
                    return new g.Polyline(j, t);
                case"Polygon":
                case"MultiPolygon":
                    j = this.coordsToLatLngs(s, r.type === "Polygon" ? 1 : 2, m);
                    return new g.Polygon(j, t);
                case"GeometryCollection":
                    for (o = 0, q = r.geometries.length; o < q; o++) {
                        p.push(this.geometryToLayer({
                            geometry: r.geometries[o],
                            type: "Feature",
                            properties: k.properties
                        }, t))
                    }
                    return new g.FeatureGroup(p);
                default:
                    throw new Error("Invalid GeoJSON object.")
            }
        }, coordsToLatLng: function (j) {
            return new g.LatLng(j[1], j[0], j[2])
        }, coordsToLatLngs: function (n, m, p) {
            var k = [];
            for (var l = 0, j = n.length, o; l < j; l++) {
                o = m ? this.coordsToLatLngs(n[l], m - 1, p) : (p || this.coordsToLatLng)(n[l]);
                k.push(o)
            }
            return k
        }, latLngToCoords: function (j) {
            return j.alt !== b ? [j.lng, j.lat, j.alt] : [j.lng, j.lat]
        }, latLngsToCoords: function (k, o, l) {
            var n = [];
            for (var m = 0, j = k.length; m < j; m++) {
                n.push(o ? g.GeoJSON.latLngsToCoords(k[m], o - 1, l) : g.GeoJSON.latLngToCoords(k[m]))
            }
            if (!o && l) {
                n.push(n[0])
            }
            return n
        }, getFeature: function (k, j) {
            return k.feature ? g.extend({}, k.feature, {geometry: j}) : g.GeoJSON.asFeature(j)
        }, asFeature: function (j) {
            if (j.type === "Feature") {
                return j
            }
            return {type: "Feature", properties: {}, geometry: j}
        }
    });
    var e = {
        toGeoJSON: function () {
            return g.GeoJSON.getFeature(this, {type: "Point", coordinates: g.GeoJSON.latLngToCoords(this.getLatLng())})
        }
    };
    g.Marker.include(e);
    g.Circle.include(e);
    g.CircleMarker.include(e);
    g.Polyline.prototype.toGeoJSON = function () {
        var k = !this._flat(this._latlngs);
        var j = g.GeoJSON.latLngsToCoords(this._latlngs, k ? 1 : 0);
        return g.GeoJSON.getFeature(this, {type: (k ? "Multi" : "") + "LineString", coordinates: j})
    };
    g.Polygon.prototype.toGeoJSON = function () {
        var j = !this._flat(this._latlngs), l = j && !this._flat(this._latlngs[0]);
        var k = g.GeoJSON.latLngsToCoords(this._latlngs, l ? 2 : j ? 1 : 0, true);
        if (j && this._latlngs.length === 1) {
            l = true;
            k = [k]
        }
        if (!j) {
            k = [k]
        }
        return g.GeoJSON.getFeature(this, {type: (l ? "Multi" : "") + "Polygon", coordinates: k})
    };
    g.LayerGroup.include({
        toMultiPoint: function () {
            var j = [];
            this.eachLayer(function (k) {
                j.push(k.toGeoJSON().geometry.coordinates)
            });
            return g.GeoJSON.getFeature(this, {type: "MultiPoint", coordinates: j})
        }, toGeoJSON: function () {
            var k = this.feature && this.feature.geometry && this.feature.geometry.type;
            if (k === "MultiPoint") {
                return this.toMultiPoint()
            }
            var j = k === "GeometryCollection", l = [];
            this.eachLayer(function (n) {
                if (n.toGeoJSON) {
                    var m = n.toGeoJSON();
                    l.push(j ? m.geometry : g.GeoJSON.asFeature(m))
                }
            });
            if (j) {
                return g.GeoJSON.getFeature(this, {geometries: l, type: "GeometryCollection"})
            }
            return {type: "FeatureCollection", features: l}
        }
    });
    g.geoJson = function (k, j) {
        return new g.GeoJSON(k, j)
    };
    var i = "_leaflet_events";
    g.DomEvent = {
        on: function (p, m, o, l) {
            if (typeof m === "object") {
                for (var n in m) {
                    this._on(p, n, m[n], o)
                }
            } else {
                m = g.Util.splitWords(m);
                for (var k = 0, j = m.length; k < j; k++) {
                    this._on(p, m[k], o, l)
                }
            }
            return this
        }, off: function (p, m, o, l) {
            if (typeof m === "object") {
                for (var n in m) {
                    this._off(p, n, m[n], o)
                }
            } else {
                m = g.Util.splitWords(m);
                for (var k = 0, j = m.length; k < j; k++) {
                    this._off(p, m[k], o, l)
                }
            }
            return this
        }, _on: function (o, n, m, k) {
            var p = n + g.stamp(m) + (k ? "_" + g.stamp(k) : "");
            if (o[i] && o[i][p]) {
                return this
            }
            var l = function (q) {
                return m.call(k || o, q || d.event)
            };
            var j = l;
            if (g.Browser.pointer && n.indexOf("touch") === 0) {
                return this.addPointerListener(o, n, l, p)
            }
            if (g.Browser.touch && (n === "dblclick") && this.addDoubleTapListener) {
                this.addDoubleTapListener(o, l, p)
            }
            if ("addEventListener" in o) {
                if (n === "mousewheel") {
                    o.addEventListener("DOMMouseScroll", l, false);
                    o.addEventListener(n, l, false)
                } else {
                    if ((n === "mouseenter") || (n === "mouseleave")) {
                        l = function (q) {
                            q = q || d.event;
                            if (!g.DomEvent._checkMouse(o, q)) {
                                return
                            }
                            return j(q)
                        };
                        o.addEventListener(n === "mouseenter" ? "mouseover" : "mouseout", l, false)
                    } else {
                        if (n === "click" && g.Browser.android) {
                            l = function (q) {
                                return g.DomEvent._filterClick(q, j)
                            }
                        }
                        o.addEventListener(n, l, false)
                    }
                }
            } else {
                if ("attachEvent" in o) {
                    o.attachEvent("on" + n, l)
                }
            }
            o[i] = o[i] || {};
            o[i][p] = l;
            return this
        }, _off: function (n, m, l, j) {
            var o = m + g.stamp(l) + (j ? "_" + g.stamp(j) : ""), k = n[i] && n[i][o];
            if (!k) {
                return this
            }
            if (g.Browser.pointer && m.indexOf("touch") === 0) {
                this.removePointerListener(n, m, o)
            } else {
                if (g.Browser.touch && (m === "dblclick") && this.removeDoubleTapListener) {
                    this.removeDoubleTapListener(n, o)
                } else {
                    if ("removeEventListener" in n) {
                        if (m === "mousewheel") {
                            n.removeEventListener("DOMMouseScroll", k, false);
                            n.removeEventListener(m, k, false)
                        } else {
                            n.removeEventListener(m === "mouseenter" ? "mouseover" : m === "mouseleave" ? "mouseout" : m, k, false)
                        }
                    } else {
                        if ("detachEvent" in n) {
                            n.detachEvent("on" + m, k)
                        }
                    }
                }
            }
            n[i][o] = null;
            return this
        }, stopPropagation: function (j) {
            if (j.stopPropagation) {
                j.stopPropagation()
            } else {
                j.cancelBubble = true
            }
            g.DomEvent._skipped(j);
            return this
        }, disableScrollPropagation: function (j) {
            return g.DomEvent.on(j, "mousewheel MozMousePixelScroll", g.DomEvent.stopPropagation)
        }, disableClickPropagation: function (k) {
            var j = g.DomEvent.stopPropagation;
            g.DomEvent.on(k, g.Draggable.START.join(" "), j);
            return g.DomEvent.on(k, {click: g.DomEvent._fakeStop, dblclick: j})
        }, preventDefault: function (j) {
            if (j.preventDefault) {
                j.preventDefault()
            } else {
                j.returnValue = false
            }
            return this
        }, stop: function (j) {
            return g.DomEvent.preventDefault(j).stopPropagation(j)
        }, getMousePosition: function (l, j) {
            if (!j) {
                return new g.Point(l.clientX, l.clientY)
            }
            var k = j.getBoundingClientRect();
            return new g.Point(l.clientX - k.left - j.clientLeft, l.clientY - k.top - j.clientTop)
        }, getWheelDelta: function (j) {
            var k = 0;
            if (j.wheelDelta) {
                k = j.wheelDelta / 120
            }
            if (j.detail) {
                k = -j.detail / 3
            }
            return k
        }, _skipEvents: {}, _fakeStop: function (j) {
            g.DomEvent._skipEvents[j.type] = true
        }, _skipped: function (k) {
            var j = this._skipEvents[k.type];
            this._skipEvents[k.type] = false;
            return j
        }, _checkMouse: function (j, m) {
            var l = m.relatedTarget;
            if (!l) {
                return true
            }
            try {
                while (l && (l !== j)) {
                    l = l.parentNode
                }
            } catch (k) {
                return false
            }
            return (l !== j)
        }, _filterClick: function (m, l) {
            var k = (m.timeStamp || m.originalEvent.timeStamp), j = g.DomEvent._lastClick && (k - g.DomEvent._lastClick);
            if ((j && j > 100 && j < 500) || (m.target._simulatedClick && !m._simulated)) {
                g.DomEvent.stop(m);
                return
            }
            g.DomEvent._lastClick = k;
            return l(m)
        }
    };
    g.DomEvent.addListener = g.DomEvent.on;
    g.DomEvent.removeListener = g.DomEvent.off;
    g.Draggable = g.Evented.extend({
        statics: {
            START: g.Browser.touch ? ["touchstart", "mousedown"] : ["mousedown"],
            END: {mousedown: "mouseup", touchstart: "touchend", pointerdown: "touchend", MSPointerDown: "touchend"},
            MOVE: {
                mousedown: "mousemove",
                touchstart: "touchmove",
                pointerdown: "touchmove",
                MSPointerDown: "touchmove"
            }
        }, initialize: function (j, k) {
            this._element = j;
            this._dragStartTarget = k || j
        }, enable: function () {
            if (this._enabled) {
                return
            }
            g.DomEvent.on(this._dragStartTarget, g.Draggable.START.join(" "), this._onDown, this);
            this._enabled = true
        }, disable: function () {
            if (!this._enabled) {
                return
            }
            g.DomEvent.off(this._dragStartTarget, g.Draggable.START.join(" "), this._onDown, this);
            this._enabled = false;
            this._moved = false
        }, _onDown: function (j) {
            this._moved = false;
            if (j.shiftKey || ((j.which !== 1) && (j.button !== 1) && !j.touches)) {
                return
            }
            g.DomEvent.stopPropagation(j);
            if (g.Draggable._disabled) {
                return
            }
            g.DomUtil.disableImageDrag();
            g.DomUtil.disableTextSelection();
            if (this._moving) {
                return
            }
            this.fire("down");
            var k = j.touches ? j.touches[0] : j;
            this._startPoint = new g.Point(k.clientX, k.clientY);
            this._startPos = this._newPos = g.DomUtil.getPosition(this._element);
            g.DomEvent.on(f, g.Draggable.MOVE[j.type], this._onMove, this).on(f, g.Draggable.END[j.type], this._onUp, this)
        }, _onMove: function (k) {
            if (k.touches && k.touches.length > 1) {
                this._moved = true;
                return
            }
            var m = (k.touches && k.touches.length === 1 ? k.touches[0] : k), j = new g.Point(m.clientX, m.clientY), l = j.subtract(this._startPoint);
            if (!l.x && !l.y) {
                return
            }
            if (g.Browser.touch && Math.abs(l.x) + Math.abs(l.y) < 3) {
                return
            }
            g.DomEvent.preventDefault(k);
            if (!this._moved) {
                this.fire("dragstart");
                this._moved = true;
                this._startPos = g.DomUtil.getPosition(this._element).subtract(l);
                g.DomUtil.addClass(f.body, "leaflet-dragging");
                this._lastTarget = k.target || k.srcElement;
                g.DomUtil.addClass(this._lastTarget, "leaflet-drag-target")
            }
            this._newPos = this._startPos.add(l);
            this._moving = true;
            g.Util.cancelAnimFrame(this._animRequest);
            this._animRequest = g.Util.requestAnimFrame(this._updatePosition, this, true, this._dragStartTarget)
        }, _updatePosition: function () {
            this.fire("predrag");
            g.DomUtil.setPosition(this._element, this._newPos);
            this.fire("drag")
        }, _onUp: function () {
            g.DomUtil.removeClass(f.body, "leaflet-dragging");
            if (this._lastTarget) {
                g.DomUtil.removeClass(this._lastTarget, "leaflet-drag-target");
                this._lastTarget = null
            }
            for (var j in g.Draggable.MOVE) {
                g.DomEvent.off(f, g.Draggable.MOVE[j], this._onMove, this).off(f, g.Draggable.END[j], this._onUp, this)
            }
            g.DomUtil.enableImageDrag();
            g.DomUtil.enableTextSelection();
            if (this._moved && this._moving) {
                g.Util.cancelAnimFrame(this._animRequest);
                this.fire("dragend", {distance: this._newPos.distanceTo(this._startPos)})
            }
            this._moving = false
        }
    });
    g.Handler = g.Class.extend({
        initialize: function (j) {
            this._map = j
        }, enable: function () {
            if (this._enabled) {
                return
            }
            this._enabled = true;
            this.addHooks()
        }, disable: function () {
            if (!this._enabled) {
                return
            }
            this._enabled = false;
            this.removeHooks()
        }, enabled: function () {
            return !!this._enabled
        }
    });
    g.Map.mergeOptions({
        dragging: true,
        inertia: !g.Browser.android23,
        inertiaDeceleration: 3400,
        inertiaMaxSpeed: Infinity,
        inertiaThreshold: g.Browser.touch ? 32 : 18,
        easeLinearity: 0.25,
        worldCopyJump: false
    });
    g.Map.Drag = g.Handler.extend({
        addHooks: function () {
            if (!this._draggable) {
                var j = this._map;
                this._draggable = new g.Draggable(j._mapPane, j._container);
                this._draggable.on({
                    down: this._onDown,
                    dragstart: this._onDragStart,
                    drag: this._onDrag,
                    dragend: this._onDragEnd
                }, this);
                if (j.options.worldCopyJump) {
                    this._draggable.on("predrag", this._onPreDrag, this);
                    j.on("viewreset", this._onViewReset, this);
                    j.whenReady(this._onViewReset, this)
                }
            }
            this._draggable.enable()
        }, removeHooks: function () {
            this._draggable.disable()
        }, moved: function () {
            return this._draggable && this._draggable._moved
        }, _onDown: function () {
            if (this._map._panAnim) {
                this._map._panAnim.stop()
            }
        }, _onDragStart: function () {
            var j = this._map;
            j.fire("movestart").fire("dragstart");
            if (j.options.inertia) {
                this._positions = [];
                this._times = []
            }
        }, _onDrag: function () {
            if (this._map.options.inertia) {
                var j = this._lastTime = +new Date(), k = this._lastPos = this._draggable._newPos;
                this._positions.push(k);
                this._times.push(j);
                if (j - this._times[0] > 200) {
                    this._positions.shift();
                    this._times.shift()
                }
            }
            this._map.fire("move").fire("drag")
        }, _onViewReset: function () {
            var k = this._map.getSize().divideBy(2), j = this._map.latLngToLayerPoint([0, 0]);
            this._initialWorldOffset = j.subtract(k).x;
            this._worldWidth = this._map.getPixelWorldBounds().getSize().x
        }, _onPreDrag: function () {
            var p = this._worldWidth, o = Math.round(p / 2), k = this._initialWorldOffset, j = this._draggable._newPos.x, m = (j - o + k) % p + o - k, l = (j + o + k) % p - o - k, n = Math.abs(m + k) < Math.abs(l + k) ? m : l;
            this._draggable._newPos.x = n
        }, _onDragEnd: function (s) {
            var k = this._map, w = k.options, r = +new Date() - this._lastTime, j = !w.inertia || r > w.inertiaThreshold || !this._positions[0];
            k.fire("dragend", s);
            if (j) {
                k.fire("moveend")
            } else {
                var t = this._lastPos.subtract(this._positions[0]), p = (this._lastTime + r - this._times[0]) / 1000, o = w.easeLinearity, n = t.multiplyBy(o / p), m = n.distanceTo([0, 0]), v = Math.min(w.inertiaMaxSpeed, m), u = n.multiplyBy(v / m), l = v / (w.inertiaDeceleration * o), q = u.multiplyBy(-l / 2).round();
                if (!q.x || !q.y) {
                    k.fire("moveend")
                } else {
                    q = k._limitOffset(q, k.options.maxBounds);
                    g.Util.requestAnimFrame(function () {
                        k.panBy(q, {duration: l, easeLinearity: o, noMoveStart: true})
                    })
                }
            }
        }
    });
    g.Map.addInitHook("addHandler", "dragging", g.Map.Drag);
    g.Map.mergeOptions({doubleClickZoom: true});
    g.Map.DoubleClickZoom = g.Handler.extend({
        addHooks: function () {
            this._map.on("dblclick", this._onDoubleClick, this)
        }, removeHooks: function () {
            this._map.off("dblclick", this._onDoubleClick, this)
        }, _onDoubleClick: function (l) {
            var k = this._map, j = k.getZoom() + (l.originalEvent.shiftKey ? -1 : 1);
            if (k.options.doubleClickZoom === "center") {
                k.setZoom(j)
            } else {
                k.setZoomAround(l.containerPoint, j)
            }
        }
    });
    g.Map.addInitHook("addHandler", "doubleClickZoom", g.Map.DoubleClickZoom);
    g.Map.mergeOptions({scrollWheelZoom: true});
    g.Map.ScrollWheelZoom = g.Handler.extend({
        addHooks: function () {
            g.DomEvent.on(this._map._container, {
                mousewheel: this._onWheelScroll,
                MozMousePixelScroll: g.DomEvent.preventDefault
            }, this);
            this._delta = 0
        }, removeHooks: function () {
            g.DomEvent.off(this._map._container, {
                mousewheel: this._onWheelScroll,
                MozMousePixelScroll: g.DomEvent.preventDefault
            }, this)
        }, _onWheelScroll: function (k) {
            var l = g.DomEvent.getWheelDelta(k);
            this._delta += l;
            this._lastMousePos = this._map.mouseEventToContainerPoint(k);
            if (!this._startTime) {
                this._startTime = +new Date()
            }
            var j = Math.max(40 - (+new Date() - this._startTime), 0);
            clearTimeout(this._timer);
            this._timer = setTimeout(g.bind(this._performZoom, this), j);
            g.DomEvent.stop(k)
        }, _performZoom: function () {
            var k = this._map, l = this._delta, j = k.getZoom();
            l = l > 0 ? Math.ceil(l) : Math.floor(l);
            l = Math.max(Math.min(l, 4), -4);
            l = k._limitZoom(j + l) - j;
            this._delta = 0;
            this._startTime = null;
            if (!l) {
                return
            }
            if (k.options.scrollWheelZoom === "center") {
                k.setZoom(j + l)
            } else {
                k.setZoomAround(this._lastMousePos, j + l)
            }
        }
    });
    g.Map.addInitHook("addHandler", "scrollWheelZoom", g.Map.ScrollWheelZoom);
    g.extend(g.DomEvent, {
        _touchstart: g.Browser.msPointer ? "MSPointerDown" : g.Browser.pointer ? "pointerdown" : "touchstart",
        _touchend: g.Browser.msPointer ? "MSPointerUp" : g.Browser.pointer ? "pointerup" : "touchend",
        addDoubleTapListener: function (o, w, j) {
            var v, n, r = false, p = 250, t = [];

            function m(z) {
                var y;
                if (g.Browser.pointer) {
                    t.push(z.pointerId);
                    y = t.length
                } else {
                    y = z.touches.length
                }
                if (y > 1) {
                    return
                }
                var x = Date.now(), A = x - (v || x);
                n = z.touches ? z.touches[0] : z;
                r = (A > 0 && A <= p);
                v = x
            }

            function s(A) {
                if (g.Browser.pointer) {
                    var y = t.indexOf(A.pointerId);
                    if (y === -1) {
                        return
                    }
                    t.splice(y, 1)
                }
                if (r) {
                    if (g.Browser.pointer) {
                        var x = {}, B, z;
                        for (z in n) {
                            B = n[z];
                            x[z] = B && B.bind ? B.bind(n) : B
                        }
                        n = x
                    }
                    n.type = "dblclick";
                    w(n);
                    v = null
                }
            }

            var l = "_leaflet_", q = this._touchstart, u = this._touchend;
            o[l + q + j] = m;
            o[l + u + j] = s;
            var k = g.Browser.pointer ? f.documentElement : o;
            o.addEventListener(q, m, false);
            k.addEventListener(u, s, false);
            if (g.Browser.pointer) {
                k.addEventListener(g.DomEvent.POINTER_CANCEL, s, false)
            }
            return this
        },
        removeDoubleTapListener: function (l, n) {
            var k = "_leaflet_", j = g.Browser.pointer ? f.documentElement : l, m = l[k + this._touchend + n];
            l.removeEventListener(this._touchstart, l[k + this._touchstart + n], false);
            j.removeEventListener(this._touchend, m, false);
            if (g.Browser.pointer) {
                j.removeEventListener(g.DomEvent.POINTER_CANCEL, m, false)
            }
            return this
        }
    });
    g.extend(g.DomEvent, {
        POINTER_DOWN: g.Browser.msPointer ? "MSPointerDown" : "pointerdown",
        POINTER_MOVE: g.Browser.msPointer ? "MSPointerMove" : "pointermove",
        POINTER_UP: g.Browser.msPointer ? "MSPointerUp" : "pointerup",
        POINTER_CANCEL: g.Browser.msPointer ? "MSPointerCancel" : "pointercancel",
        _pointers: {},
        addPointerListener: function (l, k, j, m) {
            if (k === "touchstart") {
                this._addPointerStart(l, j, m)
            } else {
                if (k === "touchmove") {
                    this._addPointerMove(l, j, m)
                } else {
                    if (k === "touchend") {
                        this._addPointerEnd(l, j, m)
                    }
                }
            }
            return this
        },
        removePointerListener: function (l, k, m) {
            var j = l["_leaflet_" + k + m];
            if (k === "touchstart") {
                l.removeEventListener(this.POINTER_DOWN, j, false)
            } else {
                if (k === "touchmove") {
                    l.removeEventListener(this.POINTER_MOVE, j, false)
                } else {
                    if (k === "touchend") {
                        l.removeEventListener(this.POINTER_UP, j, false);
                        l.removeEventListener(this.POINTER_CANCEL, j, false)
                    }
                }
            }
            return this
        },
        _addPointerStart: function (m, j, n) {
            var l = g.bind(function (o) {
                g.DomEvent.preventDefault(o);
                this._pointers[o.pointerId] = o;
                this._handlePointer(o, j)
            }, this);
            m["_leaflet_touchstart" + n] = l;
            m.addEventListener(this.POINTER_DOWN, l, false);
            if (!this._pointerDocListener) {
                var k = g.bind(function (o) {
                    delete this._pointers[o.pointerId]
                }, this);
                f.documentElement.addEventListener(this.POINTER_UP, k, false);
                f.documentElement.addEventListener(this.POINTER_CANCEL, k, false);
                this._pointerDocListener = true
            }
        },
        _handlePointer: function (l, k) {
            l.touches = [];
            for (var j in this._pointers) {
                l.touches.push(this._pointers[j])
            }
            l.changedTouches = [l];
            k(l)
        },
        _addPointerMove: function (k, j, m) {
            var l = g.bind(function (n) {
                if ((n.pointerType === n.MSPOINTER_TYPE_MOUSE || n.pointerType === "mouse") && n.buttons === 0) {
                    return
                }
                this._pointers[n.pointerId] = n;
                this._handlePointer(n, j)
            }, this);
            k["_leaflet_touchmove" + m] = l;
            k.addEventListener(this.POINTER_MOVE, l, false)
        },
        _addPointerEnd: function (k, j, m) {
            var l = g.bind(function (n) {
                delete this._pointers[n.pointerId];
                this._handlePointer(n, j)
            }, this);
            k["_leaflet_touchend" + m] = l;
            k.addEventListener(this.POINTER_UP, l, false);
            k.addEventListener(this.POINTER_CANCEL, l, false)
        }
    });
    g.Map.mergeOptions({touchZoom: g.Browser.touch && !g.Browser.android23, bounceAtZoomLimits: true});
    g.Map.TouchZoom = g.Handler.extend({
        addHooks: function () {
            g.DomEvent.on(this._map._container, "touchstart", this._onTouchStart, this)
        }, removeHooks: function () {
            g.DomEvent.off(this._map._container, "touchstart", this._onTouchStart, this)
        }, _onTouchStart: function (m) {
            var l = this._map;
            if (!m.touches || m.touches.length !== 2 || l._animatingZoom || this._zooming) {
                return
            }
            var n = l.mouseEventToLayerPoint(m.touches[0]), k = l.mouseEventToLayerPoint(m.touches[1]), j = l._getCenterLayerPoint();
            this._startCenter = n.add(k)._divideBy(2);
            this._startDist = n.distanceTo(k);
            this._moved = false;
            this._zooming = true;
            this._centerOffset = j.subtract(this._startCenter);
            if (l._panAnim) {
                l._panAnim.stop()
            }
            g.DomEvent.on(f, "touchmove", this._onTouchMove, this).on(f, "touchend", this._onTouchEnd, this);
            g.DomEvent.preventDefault(m)
        }, _onTouchMove: function (l) {
            if (!l.touches || l.touches.length !== 2 || !this._zooming) {
                return
            }
            var k = this._map, m = k.mouseEventToLayerPoint(l.touches[0]), j = k.mouseEventToLayerPoint(l.touches[1]);
            this._scale = m.distanceTo(j) / this._startDist;
            this._delta = m._add(j)._divideBy(2)._subtract(this._startCenter);
            if (!k.options.bounceAtZoomLimits && ((k.getZoom() === k.getMinZoom() && this._scale < 1) || (k.getZoom() === k.getMaxZoom() && this._scale > 1))) {
                return
            }
            if (!this._moved) {
                k.fire("movestart").fire("zoomstart");
                this._moved = true
            }
            g.Util.cancelAnimFrame(this._animRequest);
            this._animRequest = g.Util.requestAnimFrame(this._updateOnMove, this, true, this._map._container);
            g.DomEvent.preventDefault(l)
        }, _updateOnMove: function () {
            var j = this._map;
            if (j.options.touchZoom === "center") {
                this._center = j.getCenter()
            } else {
                this._center = j.layerPointToLatLng(this._getTargetCenter())
            }
            this._zoom = j.getScaleZoom(this._scale);
            j._animateZoom(this._center, this._zoom)
        }, _onTouchEnd: function () {
            if (!this._moved || !this._zooming) {
                this._zooming = false;
                return
            }
            this._zooming = false;
            g.Util.cancelAnimFrame(this._animRequest);
            g.DomEvent.off(f, "touchmove", this._onTouchMove).off(f, "touchend", this._onTouchEnd);
            var k = this._map, j = k.getZoom(), l = this._zoom - j, m = k._limitZoom(j + (l > 0 ? Math.ceil(l) : Math.floor(l)));
            k._animateZoom(this._center, m, true)
        }, _getTargetCenter: function () {
            var j = this._centerOffset.subtract(this._delta).divideBy(this._scale);
            return this._startCenter.add(j)
        }
    });
    g.Map.addInitHook("addHandler", "touchZoom", g.Map.TouchZoom);
    g.Map.mergeOptions({tap: true, tapTolerance: 15});
    g.Map.Tap = g.Handler.extend({
        addHooks: function () {
            g.DomEvent.on(this._map._container, "touchstart", this._onDown, this)
        }, removeHooks: function () {
            g.DomEvent.off(this._map._container, "touchstart", this._onDown, this)
        }, _onDown: function (k) {
            if (!k.touches) {
                return
            }
            g.DomEvent.preventDefault(k);
            this._fireClick = true;
            if (k.touches.length > 1) {
                this._fireClick = false;
                clearTimeout(this._holdTimeout);
                return
            }
            var l = k.touches[0], j = l.target;
            this._startPos = this._newPos = new g.Point(l.clientX, l.clientY);
            if (j.tagName && j.tagName.toLowerCase() === "a") {
                g.DomUtil.addClass(j, "leaflet-active")
            }
            this._holdTimeout = setTimeout(g.bind(function () {
                if (this._isTapValid()) {
                    this._fireClick = false;
                    this._onUp();
                    this._simulateEvent("contextmenu", l)
                }
            }, this), 1000);
            this._simulateEvent("mousedown", l);
            g.DomEvent.on(f, {touchmove: this._onMove, touchend: this._onUp}, this)
        }, _onUp: function (k) {
            clearTimeout(this._holdTimeout);
            g.DomEvent.off(f, {touchmove: this._onMove, touchend: this._onUp}, this);
            if (this._fireClick && k && k.changedTouches) {
                var l = k.changedTouches[0], j = l.target;
                if (j && j.tagName && j.tagName.toLowerCase() === "a") {
                    g.DomUtil.removeClass(j, "leaflet-active")
                }
                this._simulateEvent("mouseup", l);
                if (this._isTapValid()) {
                    this._simulateEvent("click", l)
                }
            }
        }, _isTapValid: function () {
            return this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance
        }, _onMove: function (j) {
            var k = j.touches[0];
            this._newPos = new g.Point(k.clientX, k.clientY)
        }, _simulateEvent: function (j, l) {
            var k = f.createEvent("MouseEvents");
            k._simulated = true;
            l.target._simulatedClick = true;
            k.initMouseEvent(j, true, true, d, 1, l.screenX, l.screenY, l.clientX, l.clientY, false, false, false, false, 0, null);
            l.target.dispatchEvent(k)
        }
    });
    if (g.Browser.touch && !g.Browser.pointer) {
        g.Map.addInitHook("addHandler", "tap", g.Map.Tap)
    }
    g.Map.mergeOptions({boxZoom: true});
    g.Map.BoxZoom = g.Handler.extend({
        initialize: function (j) {
            this._map = j;
            this._container = j._container;
            this._pane = j._panes.overlayPane
        }, addHooks: function () {
            g.DomEvent.on(this._container, "mousedown", this._onMouseDown, this)
        }, removeHooks: function () {
            g.DomEvent.off(this._container, "mousedown", this._onMouseDown, this)
        }, moved: function () {
            return this._moved
        }, _onMouseDown: function (j) {
            if (!j.shiftKey || ((j.which !== 1) && (j.button !== 1))) {
                return false
            }
            this._moved = false;
            g.DomUtil.disableTextSelection();
            g.DomUtil.disableImageDrag();
            this._startPoint = this._map.mouseEventToContainerPoint(j);
            g.DomEvent.on(f, {
                contextmenu: g.DomEvent.stop,
                mousemove: this._onMouseMove,
                mouseup: this._onMouseUp,
                keydown: this._onKeyDown
            }, this)
        }, _onMouseMove: function (l) {
            if (!this._moved) {
                this._moved = true;
                this._box = g.DomUtil.create("div", "leaflet-zoom-box", this._container);
                g.DomUtil.addClass(this._container, "leaflet-crosshair");
                this._map.fire("boxzoomstart")
            }
            this._point = this._map.mouseEventToContainerPoint(l);
            var k = new g.Bounds(this._point, this._startPoint), j = k.getSize();
            g.DomUtil.setPosition(this._box, k.min);
            this._box.style.width = j.x + "px";
            this._box.style.height = j.y + "px"
        }, _finish: function () {
            if (this._moved) {
                g.DomUtil.remove(this._box);
                g.DomUtil.removeClass(this._container, "leaflet-crosshair")
            }
            g.DomUtil.enableTextSelection();
            g.DomUtil.enableImageDrag();
            g.DomEvent.off(f, {
                contextmenu: g.DomEvent.stop,
                mousemove: this._onMouseMove,
                mouseup: this._onMouseUp,
                keydown: this._onKeyDown
            }, this)
        }, _onMouseUp: function (k) {
            if ((k.which !== 1) && (k.button !== 1)) {
                return false
            }
            this._finish();
            if (!this._moved) {
                return
            }
            var j = new g.LatLngBounds(this._map.containerPointToLatLng(this._startPoint), this._map.containerPointToLatLng(this._point));
            this._map.fitBounds(j).fire("boxzoomend", {boxZoomBounds: j})
        }, _onKeyDown: function (j) {
            if (j.keyCode === 27) {
                this._finish()
            }
        }
    });
    g.Map.addInitHook("addHandler", "boxZoom", g.Map.BoxZoom);
    g.Map.mergeOptions({keyboard: true, keyboardPanOffset: 80, keyboardZoomOffset: 1});
    g.Map.Keyboard = g.Handler.extend({
        keyCodes: {
            left: [37],
            right: [39],
            down: [40],
            up: [38],
            zoomIn: [187, 107, 61, 171],
            zoomOut: [189, 109, 173]
        }, initialize: function (j) {
            this._map = j;
            this._setPanOffset(j.options.keyboardPanOffset);
            this._setZoomOffset(j.options.keyboardZoomOffset)
        }, addHooks: function () {
            var j = this._map._container;
            if (j.tabIndex === -1) {
                j.tabIndex = "0"
            }
            g.DomEvent.on(j, {focus: this._onFocus, blur: this._onBlur, mousedown: this._onMouseDown}, this);
            this._map.on({focus: this._addHooks, blur: this._removeHooks}, this)
        }, removeHooks: function () {
            this._removeHooks();
            g.DomEvent.off(this._map._container, {
                focus: this._onFocus,
                blur: this._onBlur,
                mousedown: this._onMouseDown
            }, this);
            this._map.off({focus: this._addHooks, blur: this._removeHooks}, this)
        }, _onMouseDown: function () {
            if (this._focused) {
                return
            }
            var j = f.body, m = f.documentElement, l = j.scrollTop || m.scrollTop, k = j.scrollLeft || m.scrollLeft;
            this._map._container.focus();
            d.scrollTo(k, l)
        }, _onFocus: function () {
            this._focused = true;
            this._map.fire("focus")
        }, _onBlur: function () {
            this._focused = false;
            this._map.fire("blur")
        }, _setPanOffset: function (n) {
            var m = this._panKeys = {}, k = this.keyCodes, l, j;
            for (l = 0, j = k.left.length; l < j; l++) {
                m[k.left[l]] = [-1 * n, 0]
            }
            for (l = 0, j = k.right.length; l < j; l++) {
                m[k.right[l]] = [n, 0]
            }
            for (l = 0, j = k.down.length; l < j; l++) {
                m[k.down[l]] = [0, n]
            }
            for (l = 0, j = k.up.length; l < j; l++) {
                m[k.up[l]] = [0, -1 * n]
            }
        }, _setZoomOffset: function (n) {
            var m = this._zoomKeys = {}, k = this.keyCodes, l, j;
            for (l = 0, j = k.zoomIn.length; l < j; l++) {
                m[k.zoomIn[l]] = n
            }
            for (l = 0, j = k.zoomOut.length; l < j; l++) {
                m[k.zoomOut[l]] = -n
            }
        }, _addHooks: function () {
            g.DomEvent.on(f, "keydown", this._onKeyDown, this)
        }, _removeHooks: function () {
            g.DomEvent.off(f, "keydown", this._onKeyDown, this)
        }, _onKeyDown: function (l) {
            if (l.altKey || l.ctrlKey || l.metaKey) {
                return
            }
            var j = l.keyCode, k = this._map;
            if (j in this._panKeys) {
                if (k._panAnim && k._panAnim._inProgress) {
                    return
                }
                k.panBy(this._panKeys[j]);
                if (k.options.maxBounds) {
                    k.panInsideBounds(k.options.maxBounds)
                }
            } else {
                if (j in this._zoomKeys) {
                    k.setZoom(k.getZoom() + this._zoomKeys[j])
                } else {
                    return
                }
            }
            g.DomEvent.stop(l)
        }
    });
    g.Map.addInitHook("addHandler", "keyboard", g.Map.Keyboard);
    g.Handler.MarkerDrag = g.Handler.extend({
        initialize: function (j) {
            this._marker = j
        }, addHooks: function () {
            var j = this._marker._icon;
            if (!this._draggable) {
                this._draggable = new g.Draggable(j, j)
            }
            this._draggable.on({
                dragstart: this._onDragStart,
                drag: this._onDrag,
                dragend: this._onDragEnd
            }, this).enable();
            g.DomUtil.addClass(j, "leaflet-marker-draggable")
        }, removeHooks: function () {
            this._draggable.off({
                dragstart: this._onDragStart,
                drag: this._onDrag,
                dragend: this._onDragEnd
            }, this).disable();
            g.DomUtil.removeClass(this._marker._icon, "leaflet-marker-draggable")
        }, moved: function () {
            return this._draggable && this._draggable._moved
        }, _onDragStart: function () {
            this._marker.closePopup().fire("movestart").fire("dragstart")
        }, _onDrag: function () {
            var j = this._marker, m = j._shadow, k = g.DomUtil.getPosition(j._icon), l = j._map.layerPointToLatLng(k);
            if (m) {
                g.DomUtil.setPosition(m, k)
            }
            j._latlng = l;
            j.fire("move", {latlng: l}).fire("drag")
        }, _onDragEnd: function (j) {
            this._marker.fire("moveend").fire("dragend", j)
        }
    });
    g.Control = g.Class.extend({
        options: {position: "topright"}, initialize: function (j) {
            g.setOptions(this, j)
        }, getPosition: function () {
            return this.options.position
        }, setPosition: function (j) {
            var k = this._map;
            if (k) {
                k.removeControl(this)
            }
            this.options.position = j;
            if (k) {
                k.addControl(this)
            }
            return this
        }, getContainer: function () {
            return this._container
        }, addTo: function (l) {
            this._map = l;
            var j = this._container = this.onAdd(l), m = this.getPosition(), k = l._controlCorners[m];
            g.DomUtil.addClass(j, "leaflet-control");
            if (m.indexOf("bottom") !== -1) {
                k.insertBefore(j, k.firstChild)
            } else {
                k.appendChild(j)
            }
            return this
        }, remove: function () {
            g.DomUtil.remove(this._container);
            if (this.onRemove) {
                this.onRemove(this._map)
            }
            this._map = null;
            return this
        }, _refocusOnMap: function () {
            if (this._map) {
                this._map.getContainer().focus()
            }
        }
    });
    g.control = function (j) {
        return new g.Control(j)
    };
    g.Map.include({
        addControl: function (j) {
            j.addTo(this);
            return this
        }, removeControl: function (j) {
            j.remove();
            return this
        }, _initControlPos: function () {
            var m = this._controlCorners = {}, k = "leaflet-", j = this._controlContainer = g.DomUtil.create("div", k + "control-container", this._container);

            function n(o, p) {
                var l = k + o + " " + k + p;
                m[o + p] = g.DomUtil.create("div", l, j)
            }

            n("top", "left");
            n("top", "right");
            n("bottom", "left");
            n("bottom", "right")
        }, _clearControlPos: function () {
            g.DomUtil.remove(this._controlContainer)
        }
    });
    g.Control.Zoom = g.Control.extend({
        options: {
            position: "topleft",
            zoomInText: "+",
            zoomInTitle: "Zoom in",
            zoomOutText: "-",
            zoomOutTitle: "Zoom out"
        }, onAdd: function (l) {
            var m = "leaflet-control-zoom", j = g.DomUtil.create("div", m + " leaflet-bar"), k = this.options;
            this._zoomInButton = this._createButton(k.zoomInText, k.zoomInTitle, m + "-in", j, this._zoomIn);
            this._zoomOutButton = this._createButton(k.zoomOutText, k.zoomOutTitle, m + "-out", j, this._zoomOut);
            this._updateDisabled();
            l.on("zoomend zoomlevelschange", this._updateDisabled, this);
            return j
        }, onRemove: function (j) {
            j.off("zoomend zoomlevelschange", this._updateDisabled, this)
        }, _zoomIn: function (j) {
            this._map.zoomIn(j.shiftKey ? 3 : 1)
        }, _zoomOut: function (j) {
            this._map.zoomOut(j.shiftKey ? 3 : 1)
        }, _createButton: function (k, o, m, j, l) {
            var n = g.DomUtil.create("a", m, j);
            n.innerHTML = k;
            n.href = "#";
            n.title = o;
            g.DomEvent.on(n, "mousedown dblclick", g.DomEvent.stopPropagation).on(n, "click", g.DomEvent.stop).on(n, "click", l, this).on(n, "click", this._refocusOnMap, this);
            return n
        }, _updateDisabled: function () {
            var k = this._map, j = "leaflet-disabled";
            g.DomUtil.removeClass(this._zoomInButton, j);
            g.DomUtil.removeClass(this._zoomOutButton, j);
            if (k._zoom === k.getMinZoom()) {
                g.DomUtil.addClass(this._zoomOutButton, j)
            }
            if (k._zoom === k.getMaxZoom()) {
                g.DomUtil.addClass(this._zoomInButton, j)
            }
        }
    });
    g.Map.mergeOptions({zoomControl: true});
    g.Map.addInitHook(function () {
        if (this.options.zoomControl) {
            this.zoomControl = new g.Control.Zoom();
            this.addControl(this.zoomControl)
        }
    });
    g.control.zoom = function (j) {
        return new g.Control.Zoom(j)
    };
    g.Control.Attribution = g.Control.extend({
        options: {
            position: "bottomright",
            prefix: '<a href="http://leafletjs.com" title="A JS library for interactive maps">Leaflet</a>'
        }, initialize: function (j) {
            g.setOptions(this, j);
            this._attributions = {}
        }, onAdd: function (k) {
            this._container = g.DomUtil.create("div", "leaflet-control-attribution");
            g.DomEvent.disableClickPropagation(this._container);
            for (var j in k._layers) {
                if (k._layers[j].getAttribution) {
                    this.addAttribution(k._layers[j].getAttribution())
                }
            }
            this._update();
            return this._container
        }, setPrefix: function (j) {
            this.options.prefix = j;
            this._update();
            return this
        }, addAttribution: function (j) {
            if (!j) {
                return
            }
            if (!this._attributions[j]) {
                this._attributions[j] = 0
            }
            this._attributions[j]++;
            this._update();
            return this
        }, removeAttribution: function (j) {
            if (!j) {
                return
            }
            if (this._attributions[j]) {
                this._attributions[j]--;
                this._update()
            }
            return this
        }, _update: function () {
            if (!this._map) {
                return
            }
            var l = [];
            for (var j in this._attributions) {
                if (this._attributions[j]) {
                    l.push(j)
                }
            }
            var k = [];
            if (this.options.prefix) {
                k.push(this.options.prefix)
            }
            if (l.length) {
                k.push(l.join(", "))
            }
            this._container.innerHTML = k.join(" | ")
        }
    });
    g.Map.mergeOptions({attributionControl: true});
    g.Map.addInitHook(function () {
        if (this.options.attributionControl) {
            this.attributionControl = (new g.Control.Attribution()).addTo(this)
        }
    });
    g.control.attribution = function (j) {
        return new g.Control.Attribution(j)
    };
    g.Control.Scale = g.Control.extend({
        options: {position: "bottomleft", maxWidth: 100, metric: true, imperial: true},
        onAdd: function (m) {
            var l = "leaflet-control-scale", j = g.DomUtil.create("div", l), k = this.options;
            this._addScales(k, l + "-line", j);
            m.on(k.updateWhenIdle ? "moveend" : "move", this._update, this);
            m.whenReady(this._update, this);
            return j
        },
        onRemove: function (j) {
            j.off(this.options.updateWhenIdle ? "moveend" : "move", this._update, this)
        },
        _addScales: function (k, l, j) {
            if (k.metric) {
                this._mScale = g.DomUtil.create("div", l, j)
            }
            if (k.imperial) {
                this._iScale = g.DomUtil.create("div", l, j)
            }
        },
        _update: function () {
            var k = this._map, l = k.getSize().y / 2;
            var j = g.CRS.Earth.distance(k.containerPointToLatLng([0, l]), k.containerPointToLatLng([this.options.maxWidth, l]));
            this._updateScales(j)
        },
        _updateScales: function (j) {
            if (this.options.metric && j) {
                this._updateMetric(j)
            }
            if (this.options.imperial && j) {
                this._updateImperial(j)
            }
        },
        _updateMetric: function (l) {
            var j = this._getRoundNum(l), k = j < 1000 ? j + " m" : (j / 1000) + " km";
            this._updateScale(this._mScale, k, j / l)
        },
        _updateImperial: function (n) {
            var m = n * 3.2808399, l, k, j;
            if (m > 5280) {
                l = m / 5280;
                k = this._getRoundNum(l);
                this._updateScale(this._iScale, k + " mi", k / l)
            } else {
                j = this._getRoundNum(m);
                this._updateScale(this._iScale, j + " ft", j / m)
            }
        },
        _updateScale: function (l, k, j) {
            l.style.width = (Math.round(this.options.maxWidth * j) - 10) + "px";
            l.innerHTML = k
        },
        _getRoundNum: function (k) {
            var j = Math.pow(10, (Math.floor(k) + "").length - 1), l = k / j;
            l = l >= 10 ? 10 : l >= 5 ? 5 : l >= 3 ? 3 : l >= 2 ? 2 : 1;
            return j * l
        }
    });
    g.control.scale = function (j) {
        return new g.Control.Scale(j)
    };
    g.Control.Layers = g.Control.extend({
        options: {collapsed: true, position: "topright", autoZIndex: true},
        initialize: function (m, l, j) {
            g.setOptions(this, j);
            this._layers = {};
            this._lastZIndex = 0;
            this._handlingClick = false;
            for (var k in m) {
                this._addLayer(m[k], k)
            }
            for (k in l) {
                this._addLayer(l[k], k, true)
            }
        },
        onAdd: function () {
            this._initLayout();
            this._update();
            return this._container
        },
        addBaseLayer: function (k, j) {
            this._addLayer(k, j);
            return this._update()
        },
        addOverlay: function (k, j) {
            this._addLayer(k, j, true);
            return this._update()
        },
        removeLayer: function (j) {
            j.off("add remove", this._onLayerChange, this);
            delete this._layers[g.stamp(j)];
            return this._update()
        },
        _initLayout: function () {
            var k = "leaflet-control-layers", j = this._container = g.DomUtil.create("div", k);
            j.setAttribute("aria-haspopup", true);
            if (!g.Browser.touch) {
                g.DomEvent.disableClickPropagation(j).disableScrollPropagation(j)
            } else {
                g.DomEvent.on(j, "click", g.DomEvent.stopPropagation)
            }
            var m = this._form = g.DomUtil.create("form", k + "-list");
            if (this.options.collapsed) {
                if (!g.Browser.android) {
                    g.DomEvent.on(j, {mouseenter: this._expand, mouseleave: this._collapse}, this)
                }
                var l = this._layersLink = g.DomUtil.create("a", k + "-toggle", j);
                l.href = "#";
                l.title = "Layers";
                if (g.Browser.touch) {
                    g.DomEvent.on(l, "click", g.DomEvent.stop).on(l, "click", this._expand, this)
                } else {
                    g.DomEvent.on(l, "focus", this._expand, this)
                }
                g.DomEvent.on(m, "click", function () {
                    setTimeout(g.bind(this._onInputClick, this), 0)
                }, this);
                this._map.on("click", this._collapse, this)
            } else {
                this._expand()
            }
            this._baseLayersList = g.DomUtil.create("div", k + "-base", m);
            this._separator = g.DomUtil.create("div", k + "-separator", m);
            this._overlaysList = g.DomUtil.create("div", k + "-overlays", m);
            j.appendChild(m)
        },
        _addLayer: function (l, k, j) {
            l.on("add remove", this._onLayerChange, this);
            var m = g.stamp(l);
            this._layers[m] = {layer: l, name: k, overlay: j};
            if (this.options.autoZIndex && l.setZIndex) {
                this._lastZIndex++;
                l.setZIndex(this._lastZIndex)
            }
        },
        _update: function () {
            if (!this._container) {
                return
            }
            g.DomUtil.empty(this._baseLayersList);
            g.DomUtil.empty(this._overlaysList);
            var j, l, k, m;
            for (k in this._layers) {
                m = this._layers[k];
                this._addItem(m);
                l = l || m.overlay;
                j = j || !m.overlay
            }
            this._separator.style.display = l && j ? "" : "none";
            return this
        },
        _onLayerChange: function (l) {
            if (!this._handlingClick) {
                this._update()
            }
            var j = this._layers[g.stamp(l.target)].overlay;
            var k = j ? (l.type === "add" ? "overlayadd" : "overlayremove") : (l.type === "add" ? "baselayerchange" : null);
            if (k) {
                this._map.fire(k, l.target)
            }
        },
        _createRadioElement: function (j, m) {
            var l = '<input type="radio" class="leaflet-control-layers-selector" name="' + j + '"' + (m ? ' checked="checked"' : "") + "/>";
            var k = f.createElement("div");
            k.innerHTML = l;
            return k.firstChild
        },
        _addItem: function (o) {
            var m = f.createElement("label"), n = this._map.hasLayer(o.layer), k;
            if (o.overlay) {
                k = f.createElement("input");
                k.type = "checkbox";
                k.className = "leaflet-control-layers-selector";
                k.defaultChecked = n
            } else {
                k = this._createRadioElement("leaflet-base-layers", n)
            }
            k.layerId = g.stamp(o.layer);
            g.DomEvent.on(k, "click", this._onInputClick, this);
            var l = f.createElement("span");
            l.innerHTML = " " + o.name;
            m.appendChild(k);
            m.appendChild(l);
            var j = o.overlay ? this._overlaysList : this._baseLayersList;
            j.appendChild(m);
            return m
        },
        _onInputClick: function () {
            var l = this._form.getElementsByTagName("input"), m, o, k;
            this._handlingClick = true;
            for (var n = 0, j = l.length; n < j; n++) {
                m = l[n];
                o = this._layers[m.layerId].layer;
                k = this._map.hasLayer(o);
                if (m.checked && !k) {
                    this._map.addLayer(o)
                } else {
                    if (!m.checked && k) {
                        this._map.removeLayer(o)
                    }
                }
            }
            this._handlingClick = false;
            this._refocusOnMap()
        },
        _expand: function () {
            g.DomUtil.addClass(this._container, "leaflet-control-layers-expanded")
        },
        _collapse: function () {
            g.DomUtil.removeClass(this._container, "leaflet-control-layers-expanded")
        }
    });
    g.control.layers = function (l, k, j) {
        return new g.Control.Layers(l, k, j)
    };
    g.PosAnimation = g.Evented.extend({
        run: function (k, j, l, m) {
            this.stop();
            this._el = k;
            this._inProgress = true;
            this._newPos = j;
            this.fire("start");
            k.style[g.DomUtil.TRANSITION] = "all " + (l || 0.25) + "s cubic-bezier(0,0," + (m || 0.5) + ",1)";
            g.DomEvent.on(k, g.DomUtil.TRANSITION_END, this._onTransitionEnd, this);
            g.DomUtil.setPosition(k, j);
            g.Util.falseFn(k.offsetWidth);
            this._stepTimer = setInterval(g.bind(this._onStep, this), 50)
        }, stop: function () {
            if (!this._inProgress) {
                return
            }
            this._newPos = this._getPos();
            if (this._newPos) {
                g.DomUtil.setPosition(this._el, this._newPos)
            }
            this._onTransitionEnd();
            g.Util.falseFn(this._el.offsetWidth)
        }, _onStep: function () {
            var j = this._getPos();
            if (!j) {
                this._onTransitionEnd();
                return
            }
            this._el._leaflet_pos = j;
            this.fire("step")
        }, _transformRe: /([-+]?(?:\d*\.)?\d+)\D*, ([-+]?(?:\d*\.)?\d+)\D*\)/, _getPos: function () {
            var n, m, l, k = this._el, j = d.getComputedStyle(k);
            if (g.Browser.any3d) {
                l = j[g.DomUtil.TRANSFORM].match(this._transformRe);
                if (!l) {
                    return
                }
                n = parseFloat(l[1]);
                m = parseFloat(l[2])
            } else {
                n = parseFloat(j.left);
                m = parseFloat(j.top)
            }
            return new g.Point(n, m, true)
        }, _onTransitionEnd: function () {
            g.DomEvent.off(this._el, g.DomUtil.TRANSITION_END, this._onTransitionEnd, this);
            if (!this._inProgress) {
                return
            }
            this._inProgress = false;
            this._el.style[g.DomUtil.TRANSITION] = "";
            this._el._leaflet_pos = this._newPos;
            clearInterval(this._stepTimer);
            this.fire("step").fire("end")
        }
    });
    g.Map.include({
        setView: function (j, m, k) {
            m = m === b ? this._zoom : this._limitZoom(m);
            j = this._limitCenter(g.latLng(j), m, this.options.maxBounds);
            k = k || {};
            if (this._panAnim) {
                this._panAnim.stop()
            }
            if (this._loaded && !k.reset && k !== true) {
                if (k.animate !== b) {
                    k.zoom = g.extend({animate: k.animate}, k.zoom);
                    k.pan = g.extend({animate: k.animate}, k.pan)
                }
                var l = (this._zoom !== m) ? this._tryAnimatedZoom && this._tryAnimatedZoom(j, m, k.zoom) : this._tryAnimatedPan(j, k.pan);
                if (l) {
                    clearTimeout(this._sizeTimer);
                    return this
                }
            }
            this._resetView(j, m);
            return this
        }, panBy: function (l, j) {
            l = g.point(l).round();
            j = j || {};
            if (!l.x && !l.y) {
                return this
            }
            if (j.animate !== true && !this.getSize().contains(l)) {
                return this._resetView(this.unproject(this.project(this.getCenter()).add(l)), this.getZoom())
            }
            if (!this._panAnim) {
                this._panAnim = new g.PosAnimation();
                this._panAnim.on({step: this._onPanTransitionStep, end: this._onPanTransitionEnd}, this)
            }
            if (!j.noMoveStart) {
                this.fire("movestart")
            }
            if (j.animate !== false) {
                g.DomUtil.addClass(this._mapPane, "leaflet-pan-anim");
                var k = this._getMapPanePos().subtract(l);
                this._panAnim.run(this._mapPane, k, j.duration || 0.25, j.easeLinearity)
            } else {
                this._rawPanBy(l);
                this.fire("move").fire("moveend")
            }
            return this
        }, _onPanTransitionStep: function () {
            this.fire("move")
        }, _onPanTransitionEnd: function () {
            g.DomUtil.removeClass(this._mapPane, "leaflet-pan-anim");
            this.fire("moveend")
        }, _tryAnimatedPan: function (j, k) {
            var l = this._getCenterOffset(j)._floor();
            if ((k && k.animate) !== true && !this.getSize().contains(l)) {
                return false
            }
            this.panBy(l, k);
            return true
        }
    });
    g.PosAnimation = g.DomUtil.TRANSITION ? g.PosAnimation : g.PosAnimation.extend({
        run: function (k, j, l, m) {
            this.stop();
            this._el = k;
            this._inProgress = true;
            this._duration = l || 0.25;
            this._easeOutPower = 1 / Math.max(m || 0.5, 0.2);
            this._startPos = g.DomUtil.getPosition(k);
            this._offset = j.subtract(this._startPos);
            this._startTime = +new Date();
            this.fire("start");
            this._animate()
        }, stop: function () {
            if (!this._inProgress) {
                return
            }
            this._step();
            this._complete()
        }, _animate: function () {
            this._animId = g.Util.requestAnimFrame(this._animate, this);
            this._step()
        }, _step: function () {
            var j = (+new Date()) - this._startTime, k = this._duration * 1000;
            if (j < k) {
                this._runFrame(this._easeOut(j / k))
            } else {
                this._runFrame(1);
                this._complete()
            }
        }, _runFrame: function (j) {
            var k = this._startPos.add(this._offset.multiplyBy(j));
            g.DomUtil.setPosition(this._el, k);
            this.fire("step")
        }, _complete: function () {
            g.Util.cancelAnimFrame(this._animId);
            this._inProgress = false;
            this.fire("end")
        }, _easeOut: function (j) {
            return 1 - Math.pow(1 - j, this._easeOutPower)
        }
    });
    g.Map.mergeOptions({zoomAnimation: true, zoomAnimationThreshold: 4});
    var h = g.DomUtil.TRANSITION && g.Browser.any3d && !g.Browser.mobileOpera;
    if (h) {
        g.Map.addInitHook(function () {
            this._zoomAnimated = this.options.zoomAnimation;
            if (this._zoomAnimated) {
                g.DomEvent.on(this._mapPane, g.DomUtil.TRANSITION_END, this._catchTransitionEnd, this)
            }
        })
    }
    g.Map.include(!h ? {} : {
        _catchTransitionEnd: function (j) {
            if (this._animatingZoom && j.propertyName.indexOf("transform") >= 0) {
                this._onZoomTransitionEnd()
            }
        }, _nothingToAnimate: function () {
            return !this._container.getElementsByClassName("leaflet-zoom-animated").length
        }, _tryAnimatedZoom: function (j, l, k) {
            if (this._animatingZoom) {
                return true
            }
            k = k || {};
            if (!this._zoomAnimated || k.animate === false || this._nothingToAnimate() || Math.abs(l - this._zoom) > this.options.zoomAnimationThreshold) {
                return false
            }
            var n = this.getZoomScale(l), m = this._getCenterOffset(j)._divideBy(1 - 1 / n);
            if (k.animate !== true && !this.getSize().contains(m)) {
                return false
            }
            g.Util.requestAnimFrame(function () {
                this.fire("movestart").fire("zoomstart")._animateZoom(j, l, true)
            }, this);
            return true
        }, _animateZoom: function (j, m, l) {
            if (l) {
                this._animatingZoom = true;
                this._animateToCenter = j;
                this._animateToZoom = m;
                if (g.Draggable) {
                    g.Draggable._disabled = true
                }
                g.DomUtil.addClass(this._mapPane, "leaflet-zoom-anim")
            }
            var n = this.getZoomScale(m), k = this._getCenterLayerPoint().add(this._getCenterOffset(j)._divideBy(1 - 1 / n));
            this.fire("zoomanim", {center: j, zoom: m, origin: k, scale: n})
        }, _onZoomTransitionEnd: function () {
            this._animatingZoom = false;
            g.DomUtil.removeClass(this._mapPane, "leaflet-zoom-anim");
            this._resetView(this._animateToCenter, this._animateToZoom, true, true);
            if (g.Draggable) {
                g.Draggable._disabled = false
            }
        }
    });
    g.Map.include({
        _defaultLocateOptions: {timeout: 10000, watch: false}, locate: function (j) {
            j = this._locateOptions = g.extend(this._defaultLocateOptions, j);
            if (!navigator.geolocation) {
                this._handleGeolocationError({code: 0, message: "Geolocation not supported."});
                return this
            }
            var l = g.bind(this._handleGeolocationResponse, this), k = g.bind(this._handleGeolocationError, this);
            if (j.watch) {
                this._locationWatchId = navigator.geolocation.watchPosition(l, k, j)
            } else {
                navigator.geolocation.getCurrentPosition(l, k, j)
            }
            return this
        }, stopLocate: function () {
            if (navigator.geolocation) {
                navigator.geolocation.clearWatch(this._locationWatchId)
            }
            if (this._locateOptions) {
                this._locateOptions.setView = false
            }
            return this
        }, _handleGeolocationError: function (j) {
            var l = j.code, k = j.message || (l === 1 ? "permission denied" : (l === 2 ? "position unavailable" : "timeout"));
            if (this._locateOptions.setView && !this._loaded) {
                this.fitWorld()
            }
            this.fire("locationerror", {code: l, message: "Geolocation error: " + k + "."})
        }, _handleGeolocationResponse: function (p) {
            var o = p.coords.latitude, r = p.coords.longitude, k = new g.LatLng(o, r), q = 180 * p.coords.accuracy / 40075017, l = q / Math.cos((Math.PI / 180) * o), j = g.latLngBounds([o - q, r - l], [o + q, r + l]), t = this._locateOptions;
            if (t.setView) {
                var s = this.getBoundsZoom(j);
                this.setView(k, t.maxZoom ? Math.min(s, t.maxZoom) : s)
            }
            var n = {latlng: k, bounds: j, timestamp: p.timestamp};
            for (var m in p.coords) {
                if (typeof p.coords[m] === "number") {
                    n[m] = p.coords[m]
                }
            }
            this.fire("locationfound", n)
        }
    })
}(window, document));