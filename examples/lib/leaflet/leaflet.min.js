(function (b, d, a) {
    var g, f;
    typeof exports != a + "" ? g = exports : (f = b.L, g = {}, g.noConflict = function () {
        return b.L = f, this
    }, b.L = g), g.version = "0.5.1", g.Util = {
        extend: function (j) {
            var l, h, p, m, k = Array.prototype.slice.call(arguments, 1);
            for (h = 0, p = k.length; p > h; h++) {
                m = k[h] || {};
                for (l in m) {
                    m.hasOwnProperty(l) && (j[l] = m[l])
                }
            }
            return j
        }, bind: function (j, k) {
            var h = arguments.length > 2 ? Array.prototype.slice.call(arguments, 2) : null;
            return function () {
                return j.apply(k, h || arguments)
            }
        }, stamp: function () {
            var h = 0, i = "_leaflet_id";
            return function (e) {
                return e[i] = e[i] || ++h, e[i]
            }
        }(), limitExecByInterval: function (i, k, m) {
            var l, j;
            return function h() {
                var e = arguments;
                return l ? (j = !0, a) : (l = !0, setTimeout(function () {
                    l = !1, j && (h.apply(m, e), j = !1)
                }, k), i.apply(m, e), a)
            }
        }, falseFn: function () {
            return !1
        }, formatNum: function (j, k) {
            var h = Math.pow(10, k || 5);
            return Math.round(j * h) / h
        }, splitWords: function (e) {
            return e.replace(/^\s+|\s+$/g, "").split(/\s+/)
        }, setOptions: function (h, i) {
            return h.options = g.extend({}, h.options, i), h.options
        }, getParamString: function (j, k) {
            var h = [];
            for (var l in j) {
                j.hasOwnProperty(l) && h.push(l + "=" + j[l])
            }
            return (k && -1 !== k.indexOf("?") ? "&" : "?") + h.join("&")
        }, template: function (h, i) {
            return h.replace(/\{ *([\w_]+) *\}/g, function (j, e) {
                var k = i[e];
                if (!i.hasOwnProperty(e)) {
                    throw Error("No value provided for variable " + j)
                }
                return k
            })
        }, isArray: function (e) {
            return "[object Array]" === Object.prototype.toString.call(e)
        }, emptyImageUrl: "data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs="
    }, function () {
        function k(p) {
            var m, r, q = ["webkit", "moz", "o", "ms"];
            for (m = 0; q.length > m && !r; m++) {
                r = b[q[m] + p]
            }
            return r
        }

        function l(o) {
            var m = +new Date, p = Math.max(0, 16 - (m - i));
            return i = m + p, b.setTimeout(o, p)
        }

        var i = 0, h = b.requestAnimationFrame || k("RequestAnimationFrame") || l, j = b.cancelAnimationFrame || k("CancelAnimationFrame") || k("CancelRequestAnimationFrame") || function (m) {
                b.clearTimeout(m)
            };
        g.Util.requestAnimFrame = function (p, n, o, m) {
            return p = g.bind(p, n), o && h === l ? (p(), a) : h.call(b, p, m)
        }, g.Util.cancelAnimFrame = function (m) {
            m && j.call(b, m)
        }
    }(), g.extend = g.Util.extend, g.bind = g.Util.bind, g.stamp = g.Util.stamp, g.setOptions = g.Util.setOptions, g.Class = function () {
    }, g.Class.extend = function (k) {
        var m = function () {
            this.initialize && this.initialize.apply(this, arguments), this._initHooks && this.callInitHooks()
        }, j = function () {
        };
        j.prototype = this.prototype;
        var n = new j;
        n.constructor = m, m.prototype = n;
        for (var l in this) {
            this.hasOwnProperty(l) && "prototype" !== l && (m[l] = this[l])
        }
        k.statics && (g.extend(m, k.statics), delete k.statics), k.includes && (g.Util.extend.apply(null, [n].concat(k.includes)), delete k.includes), k.options && n.options && (k.options = g.extend({}, n.options, k.options)), g.extend(n, k), n._initHooks = [];
        var h = this;
        return n.callInitHooks = function () {
            if (!this._initHooksCalled) {
                h.prototype.callInitHooks && h.prototype.callInitHooks.call(this), this._initHooksCalled = !0;
                for (var i = 0, o = n._initHooks.length; o > i; i++) {
                    n._initHooks[i].call(this)
                }
            }
        }, m
    }, g.Class.include = function (e) {
        g.extend(this.prototype, e)
    }, g.Class.mergeOptions = function (e) {
        g.extend(this.prototype.options, e)
    }, g.Class.addInitHook = function (j) {
        var k = Array.prototype.slice.call(arguments, 1), h = "function" == typeof j ? j : function () {
            this[j].apply(this, k)
        };
        this.prototype._initHooks = this.prototype._initHooks || [], this.prototype._initHooks.push(h)
    };
    var c = "_leaflet_events";
    g.Mixin = {}, g.Mixin.Events = {
        addEventListener: function (l, p, k) {
            var q, j, n, m = this[c] = this[c] || {};
            if ("object" == typeof l) {
                for (q in l) {
                    l.hasOwnProperty(q) && this.addEventListener(q, l[q], p)
                }
                return this
            }
            for (l = g.Util.splitWords(l), j = 0, n = l.length; n > j; j++) {
                m[l[j]] = m[l[j]] || [], m[l[j]].push({action: p, context: k || this})
            }
            return this
        }, hasEventListeners: function (e) {
            return c in this && e in this[c] && this[c][e].length > 0
        }, removeEventListener: function (w, q, n) {
            var k, s, j, p, m, v = this[c];
            if ("object" == typeof w) {
                for (k in w) {
                    w.hasOwnProperty(k) && this.removeEventListener(k, w[k], q)
                }
                return this
            }
            for (w = g.Util.splitWords(w), s = 0, j = w.length; j > s; s++) {
                if (this.hasEventListeners(w[s])) {
                    for (p = v[w[s]], m = p.length - 1; m >= 0; m--) {
                        q && p[m].action !== q || n && p[m].context !== n || p.splice(m, 1)
                    }
                }
            }
            return this
        }, fireEvent: function (k, m) {
            if (!this.hasEventListeners(k)) {
                return this
            }
            for (var j = g.extend({
                type: k,
                target: this
            }, m), n = this[c][k].slice(), h = 0, l = n.length; l > h; h++) {
                n[h].action.call(n[h].context || this, j)
            }
            return this
        }
    }, g.Mixin.Events.on = g.Mixin.Events.addEventListener, g.Mixin.Events.off = g.Mixin.Events.removeEventListener, g.Mixin.Events.fire = g.Mixin.Events.fireEvent, function () {
        var x = !!b.ActiveXObject, q = x && !b.XMLHttpRequest, G = x && !d.querySelector, t = navigator.userAgent.toLowerCase(), B = -1 !== t.indexOf("webkit"), A = -1 !== t.indexOf("chrome"), n = -1 !== t.indexOf("android"), F = -1 !== t.search("android [23]"), H = typeof orientation != a + "", E = b.navigator && b.navigator.msPointerEnabled && b.navigator.msMaxTouchPoints, w = "devicePixelRatio" in b && b.devicePixelRatio > 1 || "matchMedia" in b && b.matchMedia("(min-resolution:144dpi)") && b.matchMedia("(min-resolution:144dpi)").matches, z = d.documentElement, D = x && "transition" in z.style, C = "WebKitCSSMatrix" in b && "m11" in new b.WebKitCSSMatrix, k = "MozPerspective" in z.style, j = "OTransition" in z.style, i = !b.L_DISABLE_3D && (D || C || k || j), e = !b.L_NO_TOUCH && function () {
                var l = "ontouchstart";
                if (E || l in z) {
                    return !0
                }
                var h = d.createElement("div"), m = !1;
                return h.setAttribute ? (h.setAttribute(l, "return;"), "function" == typeof h[l] && (m = !0), h.removeAttribute(l), h = null, m) : !1
            }();
        g.Browser = {
            ie: x,
            ie6: q,
            ie7: G,
            webkit: B,
            android: n,
            android23: F,
            chrome: A,
            ie3d: D,
            webkit3d: C,
            gecko3d: k,
            opera3d: j,
            any3d: i,
            mobile: H,
            mobileWebkit: H && B,
            mobileWebkit3d: H && C,
            mobileOpera: H && b.opera,
            touch: e,
            msTouch: E,
            retina: w
        }
    }(), g.Point = function (j, k, h) {
        this.x = h ? Math.round(j) : j, this.y = h ? Math.round(k) : k
    }, g.Point.prototype = {
        clone: function () {
            return new g.Point(this.x, this.y)
        }, add: function (e) {
            return this.clone()._add(g.point(e))
        }, _add: function (e) {
            return this.x += e.x, this.y += e.y, this
        }, subtract: function (e) {
            return this.clone()._subtract(g.point(e))
        }, _subtract: function (e) {
            return this.x -= e.x, this.y -= e.y, this
        }, divideBy: function (e) {
            return this.clone()._divideBy(e)
        }, _divideBy: function (e) {
            return this.x /= e, this.y /= e, this
        }, multiplyBy: function (e) {
            return this.clone()._multiplyBy(e)
        }, _multiplyBy: function (e) {
            return this.x *= e, this.y *= e, this
        }, round: function () {
            return this.clone()._round()
        }, _round: function () {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this
        }, floor: function () {
            return this.clone()._floor()
        }, _floor: function () {
            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
        }, distanceTo: function (j) {
            j = g.point(j);
            var k = j.x - this.x, h = j.y - this.y;
            return Math.sqrt(k * k + h * h)
        }, equals: function (e) {
            return e.x === this.x && e.y === this.y
        }, toString: function () {
            return "Point(" + g.Util.formatNum(this.x) + ", " + g.Util.formatNum(this.y) + ")"
        }
    }, g.point = function (j, k, h) {
        return j instanceof g.Point ? j : g.Util.isArray(j) ? new g.Point(j[0], j[1]) : isNaN(j) ? j : new g.Point(j, k, h)
    }, g.Bounds = function (j, k) {
        if (j) {
            for (var h = k ? [j, k] : j, m = 0, l = h.length; l > m; m++) {
                this.extend(h[m])
            }
        }
    }, g.Bounds.prototype = {
        extend: function (e) {
            return e = g.point(e), this.min || this.max ? (this.min.x = Math.min(e.x, this.min.x), this.max.x = Math.max(e.x, this.max.x), this.min.y = Math.min(e.y, this.min.y), this.max.y = Math.max(e.y, this.max.y)) : (this.min = e.clone(), this.max = e.clone()), this
        }, getCenter: function (e) {
            return new g.Point((this.min.x + this.max.x) / 2, (this.min.y + this.max.y) / 2, e)
        }, getBottomLeft: function () {
            return new g.Point(this.min.x, this.max.y)
        }, getTopRight: function () {
            return new g.Point(this.max.x, this.min.y)
        }, getSize: function () {
            return this.max.subtract(this.min)
        }, contains: function (j) {
            var k, h;
            return j = "number" == typeof j[0] || j instanceof g.Point ? g.point(j) : g.bounds(j), j instanceof g.Bounds ? (k = j.min, h = j.max) : k = h = j, k.x >= this.min.x && h.x <= this.max.x && k.y >= this.min.y && h.y <= this.max.y
        }, intersects: function (k) {
            k = g.bounds(k);
            var n = this.min, j = this.max, p = k.min, l = k.max, h = l.x >= n.x && p.x <= j.x, m = l.y >= n.y && p.y <= j.y;
            return h && m
        }, isValid: function () {
            return !(!this.min || !this.max)
        }
    }, g.bounds = function (h, i) {
        return !h || h instanceof g.Bounds ? h : new g.Bounds(h, i)
    }, g.Transformation = function (j, k, h, l) {
        this._a = j, this._b = k, this._c = h, this._d = l
    }, g.Transformation.prototype = {
        transform: function (h, i) {
            return this._transform(h.clone(), i)
        }, _transform: function (h, i) {
            return i = i || 1, h.x = i * (this._a * h.x + this._b), h.y = i * (this._c * h.y + this._d), h
        }, untransform: function (h, i) {
            return i = i || 1, new g.Point((h.x / i - this._b) / this._a, (h.y / i - this._d) / this._c)
        }
    }, g.DomUtil = {
        get: function (e) {
            return "string" == typeof e ? d.getElementById(e) : e
        }, getStyle: function (h, e) {
            var k = h.style[e];
            if (!k && h.currentStyle && (k = h.currentStyle[e]), (!k || "auto" === k) && d.defaultView) {
                var j = d.defaultView.getComputedStyle(h, null);
                k = j ? j[e] : null
            }
            return "auto" === k ? null : k
        }, getViewportOffset: function (k) {
            var j, p = 0, m = 0, e = k, n = d.body, l = g.Browser.ie7;
            do {
                if (p += e.offsetTop || 0, m += e.offsetLeft || 0, p += parseInt(g.DomUtil.getStyle(e, "borderTopWidth"), 10) || 0, m += parseInt(g.DomUtil.getStyle(e, "borderLeftWidth"), 10) || 0, j = g.DomUtil.getStyle(e, "position"), e.offsetParent === n && "absolute" === j) {
                    break
                }
                if ("fixed" === j) {
                    p += n.scrollTop || 0, m += n.scrollLeft || 0;
                    break
                }
                e = e.offsetParent
            } while (e);
            e = k;
            do {
                if (e === n) {
                    break
                }
                p -= e.scrollTop || 0, m -= e.scrollLeft || 0, g.DomUtil.documentIsLtr() || !g.Browser.webkit && !l || (m += e.scrollWidth - e.clientWidth, l && "hidden" !== g.DomUtil.getStyle(e, "overflow-y") && "hidden" !== g.DomUtil.getStyle(e, "overflow") && (m += 17)), e = e.parentNode
            } while (e);
            return new g.Point(m, p)
        }, documentIsLtr: function () {
            return g.DomUtil._docIsLtrCached || (g.DomUtil._docIsLtrCached = !0, g.DomUtil._docIsLtr = "ltr" === g.DomUtil.getStyle(d.body, "direction")), g.DomUtil._docIsLtr
        }, create: function (h, e, k) {
            var j = d.createElement(h);
            return j.className = e, k && k.appendChild(j), j
        }, disableTextSelection: function () {
            d.selection && d.selection.empty && d.selection.empty(), this._onselectstart || (this._onselectstart = d.onselectstart || null, d.onselectstart = g.Util.falseFn)
        }, enableTextSelection: function () {
            d.onselectstart === g.Util.falseFn && (d.onselectstart = this._onselectstart, this._onselectstart = null)
        }, hasClass: function (h, i) {
            return h.className.length > 0 && RegExp("(^|\\s)" + i + "(\\s|$)").test(h.className)
        }, addClass: function (h, i) {
            g.DomUtil.hasClass(h, i) || (h.className += (h.className ? " " : "") + i)
        }, removeClass: function (j, k) {
            function h(l, e) {
                return e === k ? "" : l
            }

            j.className = j.className.replace(/(\S+)\s*/g, h).replace(/(^\s+|\s+$)/, "")
        }, setOpacity: function (j, k) {
            if ("opacity" in j.style) {
                j.style.opacity = k
            } else {
                if ("filter" in j.style) {
                    var h = !1, m = "DXImageTransform.Microsoft.Alpha";
                    try {
                        h = j.filters.item(m)
                    } catch (l) {
                    }
                    k = Math.round(100 * k), h ? (h.Enabled = 100 !== k, h.Opacity = k) : j.style.filter += " progid:" + m + "(opacity=" + k + ")"
                }
            }
        }, testProp: function (h) {
            for (var e = d.documentElement.style, j = 0; h.length > j; j++) {
                if (h[j] in e) {
                    return h[j]
                }
            }
            return !1
        }, getTranslateString: function (j) {
            var k = g.Browser.webkit3d, h = "translate" + (k ? "3d" : "") + "(", l = (k ? ",0" : "") + ")";
            return h + j.x + "px," + j.y + "px" + l
        }, getScaleString: function (j, k) {
            var h = g.DomUtil.getTranslateString(k.add(k.multiplyBy(-1 * j))), l = " scale(" + j + ") ";
            return h + l
        }, setPosition: function (j, k, h) {
            j._leaflet_pos = k, !h && g.Browser.any3d ? (j.style[g.DomUtil.TRANSFORM] = g.DomUtil.getTranslateString(k), g.Browser.mobileWebkit3d && (j.style.WebkitBackfaceVisibility = "hidden")) : (j.style.left = k.x + "px", j.style.top = k.y + "px")
        }, getPosition: function (e) {
            return e._leaflet_pos
        }
    }, g.DomUtil.TRANSFORM = g.DomUtil.testProp(["transform", "WebkitTransform", "OTransform", "MozTransform", "msTransform"]), g.DomUtil.TRANSITION = g.DomUtil.testProp(["webkitTransition", "transition", "OTransition", "MozTransition", "msTransition"]), g.DomUtil.TRANSITION_END = "webkitTransition" === g.DomUtil.TRANSITION || "OTransition" === g.DomUtil.TRANSITION ? g.DomUtil.TRANSITION + "End" : "transitionend", g.LatLng = function (j, k) {
        var h = parseFloat(j), l = parseFloat(k);
        if (isNaN(h) || isNaN(l)) {
            throw Error("Invalid LatLng object: (" + j + ", " + k + ")")
        }
        this.lat = h, this.lng = l
    }, g.extend(g.LatLng, {
        DEG_TO_RAD: Math.PI / 180,
        RAD_TO_DEG: 180 / Math.PI,
        MAX_MARGIN: 1e-9
    }), g.LatLng.prototype = {
        equals: function (h) {
            if (!h) {
                return !1
            }
            h = g.latLng(h);
            var i = Math.max(Math.abs(this.lat - h.lat), Math.abs(this.lng - h.lng));
            return g.LatLng.MAX_MARGIN >= i
        }, toString: function (e) {
            return "LatLng(" + g.Util.formatNum(this.lat, e) + ", " + g.Util.formatNum(this.lng, e) + ")"
        }, distanceTo: function (x) {
            x = g.latLng(x);
            var q = 6378137, n = g.LatLng.DEG_TO_RAD, k = (x.lat - this.lat) * n, y = (x.lng - this.lng) * n, v = this.lat * n, j = x.lat * n, p = Math.sin(k / 2), m = Math.sin(y / 2), w = p * p + m * m * Math.cos(v) * Math.cos(j);
            return 2 * q * Math.atan2(Math.sqrt(w), Math.sqrt(1 - w))
        }, wrap: function (j, k) {
            var h = this.lng;
            return j = j || -180, k = k || 180, h = (h + k) % (k - j) + (j > h || h === k ? k : j), new g.LatLng(this.lat, h)
        }
    }, g.latLng = function (h, i) {
        return h instanceof g.LatLng ? h : g.Util.isArray(h) ? new g.LatLng(h[0], h[1]) : isNaN(h) ? h : new g.LatLng(h, i)
    }, g.LatLngBounds = function (j, k) {
        if (j) {
            for (var h = k ? [j, k] : j, m = 0, l = h.length; l > m; m++) {
                this.extend(h[m])
            }
        }
    }, g.LatLngBounds.prototype = {
        extend: function (e) {
            return e = "number" == typeof e[0] || "string" == typeof e[0] || e instanceof g.LatLng ? g.latLng(e) : g.latLngBounds(e), e instanceof g.LatLng ? this._southWest || this._northEast ? (this._southWest.lat = Math.min(e.lat, this._southWest.lat), this._southWest.lng = Math.min(e.lng, this._southWest.lng), this._northEast.lat = Math.max(e.lat, this._northEast.lat), this._northEast.lng = Math.max(e.lng, this._northEast.lng)) : (this._southWest = new g.LatLng(e.lat, e.lng), this._northEast = new g.LatLng(e.lat, e.lng)) : e instanceof g.LatLngBounds && (this.extend(e._southWest), this.extend(e._northEast)), this
        }, pad: function (j) {
            var l = this._southWest, h = this._northEast, m = Math.abs(l.lat - h.lat) * j, k = Math.abs(l.lng - h.lng) * j;
            return new g.LatLngBounds(new g.LatLng(l.lat - m, l.lng - k), new g.LatLng(h.lat + m, h.lng + k))
        }, getCenter: function () {
            return new g.LatLng((this._southWest.lat + this._northEast.lat) / 2, (this._southWest.lng + this._northEast.lng) / 2)
        }, getSouthWest: function () {
            return this._southWest
        }, getNorthEast: function () {
            return this._northEast
        }, getNorthWest: function () {
            return new g.LatLng(this._northEast.lat, this._southWest.lng)
        }, getSouthEast: function () {
            return new g.LatLng(this._southWest.lat, this._northEast.lng)
        }, contains: function (j) {
            j = "number" == typeof j[0] || j instanceof g.LatLng ? g.latLng(j) : g.latLngBounds(j);
            var l, h, m = this._southWest, k = this._northEast;
            return j instanceof g.LatLngBounds ? (l = j.getSouthWest(), h = j.getNorthEast()) : l = h = j, l.lat >= m.lat && h.lat <= k.lat && l.lng >= m.lng && h.lng <= k.lng
        }, intersects: function (k) {
            k = g.latLngBounds(k);
            var n = this._southWest, j = this._northEast, p = k.getSouthWest(), l = k.getNorthEast(), h = l.lat >= n.lat && p.lat <= j.lat, m = l.lng >= n.lng && p.lng <= j.lng;
            return h && m
        }, toBBoxString: function () {
            var h = this._southWest, i = this._northEast;
            return [h.lng, h.lat, i.lng, i.lat].join(",")
        }, equals: function (e) {
            return e ? (e = g.latLngBounds(e), this._southWest.equals(e.getSouthWest()) && this._northEast.equals(e.getNorthEast())) : !1
        }, isValid: function () {
            return !(!this._southWest || !this._northEast)
        }
    }, g.latLngBounds = function (h, i) {
        return !h || h instanceof g.LatLngBounds ? h : new g.LatLngBounds(h, i)
    }, g.Projection = {}, g.Projection.SphericalMercator = {
        MAX_LATITUDE: 85.0511287798, project: function (k) {
            var m = g.LatLng.DEG_TO_RAD, j = this.MAX_LATITUDE, n = Math.max(Math.min(j, k.lat), -j), l = k.lng * m, h = n * m;
            return h = Math.log(Math.tan(Math.PI / 4 + h / 2)), new g.Point(l, h)
        }, unproject: function (j) {
            var k = g.LatLng.RAD_TO_DEG, h = j.x * k, l = (2 * Math.atan(Math.exp(j.y)) - Math.PI / 2) * k;
            return new g.LatLng(l, h)
        }
    }, g.Projection.LonLat = {
        project: function (e) {
            return new g.Point(e.lng, e.lat)
        }, unproject: function (e) {
            return new g.LatLng(e.y, e.x)
        }
    }, g.CRS = {
        latLngToPoint: function (j, k) {
            var h = this.projection.project(j), l = this.scale(k);
            return this.transformation._transform(h, l)
        }, pointToLatLng: function (j, k) {
            var h = this.scale(k), l = this.transformation.untransform(j, h);
            return this.projection.unproject(l)
        }, project: function (e) {
            return this.projection.project(e)
        }, scale: function (e) {
            return 256 * Math.pow(2, e)
        }
    }, g.CRS.Simple = g.extend({}, g.CRS, {
        projection: g.Projection.LonLat,
        transformation: new g.Transformation(1, 0, -1, 0),
        scale: function (e) {
            return Math.pow(2, e)
        }
    }), g.CRS.EPSG3857 = g.extend({}, g.CRS, {
        code: "EPSG:3857",
        projection: g.Projection.SphericalMercator,
        transformation: new g.Transformation(0.5 / Math.PI, 0.5, -0.5 / Math.PI, 0.5),
        project: function (j) {
            var k = this.projection.project(j), h = 6378137;
            return k.multiplyBy(h)
        }
    }), g.CRS.EPSG900913 = g.extend({}, g.CRS.EPSG3857, {code: "EPSG:900913"}), g.CRS.EPSG4326 = g.extend({}, g.CRS, {
        code: "EPSG:4326",
        projection: g.Projection.LonLat,
        transformation: new g.Transformation(1 / 360, 0.5, -1 / 360, 0.5)
    }), g.Map = g.Class.extend({
        includes: g.Mixin.Events,
        options: {
            crs: g.CRS.EPSG3857,
            fadeAnimation: g.DomUtil.TRANSITION && !g.Browser.android23,
            trackResize: !0,
            markerZoomAnimation: g.DomUtil.TRANSITION && g.Browser.any3d
        },
        initialize: function (h, i) {
            i = g.setOptions(this, i), this._initContainer(h), this._initLayout(), this.callInitHooks(), this._initEvents(), i.maxBounds && this.setMaxBounds(i.maxBounds), i.center && i.zoom !== a && this.setView(g.latLng(i.center), i.zoom, !0), this._initLayers(i.layers)
        },
        setView: function (h, i) {
            return this._resetView(g.latLng(h), this._limitZoom(i)), this
        },
        setZoom: function (e) {
            return this.setView(this.getCenter(), e)
        },
        zoomIn: function (e) {
            return this.setZoom(this._zoom + (e || 1))
        },
        zoomOut: function (e) {
            return this.setZoom(this._zoom - (e || 1))
        },
        fitBounds: function (h) {
            var i = this.getBoundsZoom(h);
            return this.setView(g.latLngBounds(h).getCenter(), i)
        },
        fitWorld: function () {
            var h = new g.LatLng(-60, -170), i = new g.LatLng(85, 179);
            return this.fitBounds(new g.LatLngBounds(h, i))
        },
        panTo: function (e) {
            return this.setView(e, this._zoom)
        },
        panBy: function (e) {
            return this.fire("movestart"), this._rawPanBy(g.point(e)), this.fire("move"), this.fire("moveend")
        },
        setMaxBounds: function (h) {
            if (h = g.latLngBounds(h), this.options.maxBounds = h, !h) {
                return this._boundsMinZoom = null, this
            }
            var i = this.getBoundsZoom(h, !0);
            return this._boundsMinZoom = i, this._loaded && (i > this._zoom ? this.setView(h.getCenter(), i) : this.panInsideBounds(h)), this
        },
        panInsideBounds: function (l) {
            l = g.latLngBounds(l);
            var q = this.getBounds(), k = this.project(q.getSouthWest()), u = this.project(q.getNorthEast()), n = this.project(l.getSouthWest()), j = this.project(l.getNorthEast()), p = 0, m = 0;
            return u.y < j.y && (m = j.y - u.y), u.x > j.x && (p = j.x - u.x), k.y > n.y && (m = n.y - k.y), k.x < n.x && (p = n.x - k.x), this.panBy(new g.Point(p, m, !0))
        },
        addLayer: function (h) {
            var i = g.stamp(h);
            return this._layers[i] ? this : (this._layers[i] = h, !h.options || isNaN(h.options.maxZoom) && isNaN(h.options.minZoom) || (this._zoomBoundLayers[i] = h, this._updateZoomLevels()), this.options.zoomAnimation && g.TileLayer && h instanceof g.TileLayer && (this._tileLayersNum++, this._tileLayersToLoad++, h.on("load", this._onTileLayerLoad, this)), this.whenReady(function () {
                h.onAdd(this), this.fire("layeradd", {layer: h})
            }, this), this)
        },
        removeLayer: function (h) {
            var i = g.stamp(h);
            if (this._layers[i]) {
                return h.onRemove(this), delete this._layers[i], this._zoomBoundLayers[i] && (delete this._zoomBoundLayers[i], this._updateZoomLevels()), this.options.zoomAnimation && g.TileLayer && h instanceof g.TileLayer && (this._tileLayersNum--, this._tileLayersToLoad--, h.off("load", this._onTileLayerLoad, this)), this.fire("layerremove", {layer: h})
            }
        },
        hasLayer: function (h) {
            var i = g.stamp(h);
            return this._layers.hasOwnProperty(i)
        },
        invalidateSize: function (j) {
            var k = this.getSize();
            if (this._sizeChanged = !0, this.options.maxBounds && this.setMaxBounds(this.options.maxBounds), !this._loaded) {
                return this
            }
            var h = k._subtract(this.getSize())._divideBy(2)._round();
            return j === !0 ? this.panBy(h) : (this._rawPanBy(h), this.fire("move"), clearTimeout(this._sizeTimer), this._sizeTimer = setTimeout(g.bind(this.fire, this, "moveend"), 200)), this
        },
        addHandler: function (h, i) {
            return i ? (this[h] = new i(this), this.options[h] && this[h].enable(), this) : a
        },
        getCenter: function () {
            return this.layerPointToLatLng(this._getCenterLayerPoint())
        },
        getZoom: function () {
            return this._zoom
        },
        getBounds: function () {
            var j = this.getPixelBounds(), k = this.unproject(j.getBottomLeft()), h = this.unproject(j.getTopRight());
            return new g.LatLngBounds(k, h)
        },
        getMinZoom: function () {
            var j = this.options.minZoom || 0, k = this._layersMinZoom || 0, h = this._boundsMinZoom || 0;
            return Math.max(j, k, h)
        },
        getMaxZoom: function () {
            var h = this.options.maxZoom === a ? 1 / 0 : this.options.maxZoom, i = this._layersMaxZoom === a ? 1 / 0 : this._layersMaxZoom;
            return Math.min(h, i)
        },
        getBoundsZoom: function (y, q) {
            y = g.latLngBounds(y);
            var n, k, z, w = this.getSize(), j = this.options.minZoom || 0, p = this.getMaxZoom(), m = y.getNorthEast(), x = y.getSouthWest(), v = !0;
            q && j--;
            do {
                j++, k = this.project(m, j), z = this.project(x, j), n = new g.Point(Math.abs(k.x - z.x), Math.abs(z.y - k.y)), v = q ? n.x < w.x || n.y < w.y : n.x <= w.x && n.y <= w.y
            } while (v && p >= j);
            return v && q ? null : q ? j : j - 1
        },
        getSize: function () {
            return (!this._size || this._sizeChanged) && (this._size = new g.Point(this._container.clientWidth, this._container.clientHeight), this._sizeChanged = !1), this._size.clone()
        },
        getPixelBounds: function () {
            var e = this._getTopLeftPoint();
            return new g.Bounds(e, e.add(this.getSize()))
        },
        getPixelOrigin: function () {
            return this._initialTopLeftPoint
        },
        getPanes: function () {
            return this._panes
        },
        getContainer: function () {
            return this._container
        },
        getZoomScale: function (h) {
            var i = this.options.crs;
            return i.scale(h) / i.scale(this._zoom)
        },
        getScaleZoom: function (e) {
            return this._zoom + Math.log(e) / Math.LN2
        },
        project: function (h, i) {
            return i = i === a ? this._zoom : i, this.options.crs.latLngToPoint(g.latLng(h), i)
        },
        unproject: function (h, i) {
            return i = i === a ? this._zoom : i, this.options.crs.pointToLatLng(g.point(h), i)
        },
        layerPointToLatLng: function (h) {
            var i = g.point(h).add(this._initialTopLeftPoint);
            return this.unproject(i)
        },
        latLngToLayerPoint: function (h) {
            var i = this.project(g.latLng(h))._round();
            return i._subtract(this._initialTopLeftPoint)
        },
        containerPointToLayerPoint: function (e) {
            return g.point(e).subtract(this._getMapPanePos())
        },
        layerPointToContainerPoint: function (e) {
            return g.point(e).add(this._getMapPanePos())
        },
        containerPointToLatLng: function (h) {
            var i = this.containerPointToLayerPoint(g.point(h));
            return this.layerPointToLatLng(i)
        },
        latLngToContainerPoint: function (e) {
            return this.layerPointToContainerPoint(this.latLngToLayerPoint(g.latLng(e)))
        },
        mouseEventToContainerPoint: function (e) {
            return g.DomEvent.getMousePosition(e, this._container)
        },
        mouseEventToLayerPoint: function (e) {
            return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(e))
        },
        mouseEventToLatLng: function (e) {
            return this.layerPointToLatLng(this.mouseEventToLayerPoint(e))
        },
        _initContainer: function (h) {
            var i = this._container = g.DomUtil.get(h);
            if (i._leaflet) {
                throw Error("Map container is already initialized.")
            }
            i._leaflet = !0
        },
        _initLayout: function () {
            var h = this._container;
            g.DomUtil.addClass(h, "leaflet-container"), g.Browser.touch && g.DomUtil.addClass(h, "leaflet-touch"), this.options.fadeAnimation && g.DomUtil.addClass(h, "leaflet-fade-anim");
            var i = g.DomUtil.getStyle(h, "position");
            "absolute" !== i && "relative" !== i && "fixed" !== i && (h.style.position = "relative"), this._initPanes(), this._initControlPos && this._initControlPos()
        },
        _initPanes: function () {
            var h = this._panes = {};
            this._mapPane = h.mapPane = this._createPane("leaflet-map-pane", this._container), this._tilePane = h.tilePane = this._createPane("leaflet-tile-pane", this._mapPane), h.objectsPane = this._createPane("leaflet-objects-pane", this._mapPane), h.shadowPane = this._createPane("leaflet-shadow-pane"), h.overlayPane = this._createPane("leaflet-overlay-pane"), h.markerPane = this._createPane("leaflet-marker-pane"), h.popupPane = this._createPane("leaflet-popup-pane");
            var i = " leaflet-zoom-hide";
            this.options.markerZoomAnimation || (g.DomUtil.addClass(h.markerPane, i), g.DomUtil.addClass(h.shadowPane, i), g.DomUtil.addClass(h.popupPane, i))
        },
        _createPane: function (h, i) {
            return g.DomUtil.create("div", h, i || this._panes.objectsPane)
        },
        _initLayers: function (j) {
            j = j ? g.Util.isArray(j) ? j : [j] : [], this._layers = {}, this._zoomBoundLayers = {}, this._tileLayersNum = 0;
            var k, h;
            for (k = 0, h = j.length; h > k; k++) {
                this.addLayer(j[k])
            }
        },
        _resetView: function (k, m, j, n) {
            var l = this._zoom !== m;
            n || (this.fire("movestart"), l && this.fire("zoomstart")), this._zoom = m, this._initialTopLeftPoint = this._getNewTopLeftPoint(k), j ? this._initialTopLeftPoint._add(this._getMapPanePos()) : g.DomUtil.setPosition(this._mapPane, new g.Point(0, 0)), this._tileLayersToLoad = this._tileLayersNum;
            var h = !this._loaded;
            this._loaded = !0, this.fire("viewreset", {hard: !j}), this.fire("move"), (l || n) && this.fire("zoomend"), this.fire("moveend", {hard: !j}), h && this.fire("load")
        },
        _rawPanBy: function (e) {
            g.DomUtil.setPosition(this._mapPane, this._getMapPanePos().subtract(e))
        },
        _updateZoomLevels: function () {
            var h, i = 1 / 0, k = -1 / 0;
            for (h in this._zoomBoundLayers) {
                if (this._zoomBoundLayers.hasOwnProperty(h)) {
                    var j = this._zoomBoundLayers[h];
                    isNaN(j.options.minZoom) || (i = Math.min(i, j.options.minZoom)), isNaN(j.options.maxZoom) || (k = Math.max(k, j.options.maxZoom))
                }
            }
            h === a ? this._layersMaxZoom = this._layersMinZoom = a : (this._layersMaxZoom = k, this._layersMinZoom = i)
        },
        _initEvents: function () {
            if (g.DomEvent) {
                g.DomEvent.on(this._container, "click", this._onMouseClick, this);
                var j, h, k = ["dblclick", "mousedown", "mouseup", "mouseenter", "mouseleave", "mousemove", "contextmenu"];
                for (j = 0, h = k.length; h > j; j++) {
                    g.DomEvent.on(this._container, k[j], this._fireMouseEvent, this)
                }
                this.options.trackResize && g.DomEvent.on(b, "resize", this._onResize, this)
            }
        },
        _onResize: function () {
            g.Util.cancelAnimFrame(this._resizeRequest), this._resizeRequest = g.Util.requestAnimFrame(this.invalidateSize, this, !1, this._container)
        },
        _onMouseClick: function (e) {
            !this._loaded || this.dragging && this.dragging.moved() || (this.fire("preclick"), this._fireMouseEvent(e))
        },
        _fireMouseEvent: function (j) {
            if (this._loaded) {
                var l = j.type;
                if (l = "mouseenter" === l ? "mouseover" : "mouseleave" === l ? "mouseout" : l, this.hasEventListeners(l)) {
                    "contextmenu" === l && g.DomEvent.preventDefault(j);
                    var h = this.mouseEventToContainerPoint(j), m = this.containerPointToLayerPoint(h), k = this.layerPointToLatLng(m);
                    this.fire(l, {latlng: k, layerPoint: m, containerPoint: h, originalEvent: j})
                }
            }
        },
        _onTileLayerLoad: function () {
            this._tileLayersToLoad--, this._tileLayersNum && !this._tileLayersToLoad && this._tileBg && (clearTimeout(this._clearTileBgTimer), this._clearTileBgTimer = setTimeout(g.bind(this._clearTileBg, this), 500))
        },
        whenReady: function (h, i) {
            return this._loaded ? h.call(i || this, this) : this.on("load", h, i), this
        },
        _getMapPanePos: function () {
            return g.DomUtil.getPosition(this._mapPane)
        },
        _getTopLeftPoint: function () {
            if (!this._loaded) {
                throw Error("Set map center and zoom first.")
            }
            return this._initialTopLeftPoint.subtract(this._getMapPanePos())
        },
        _getNewTopLeftPoint: function (j, k) {
            var h = this.getSize()._divideBy(2);
            return this.project(j, k)._subtract(h)._round()
        },
        _latLngToNewLayerPoint: function (j, k, h) {
            var l = this._getNewTopLeftPoint(h, k).add(this._getMapPanePos());
            return this.project(j, k)._subtract(l)
        },
        _getCenterLayerPoint: function () {
            return this.containerPointToLayerPoint(this.getSize()._divideBy(2))
        },
        _getCenterOffset: function (e) {
            return this.latLngToLayerPoint(e).subtract(this._getCenterLayerPoint())
        },
        _limitZoom: function (j) {
            var k = this.getMinZoom(), h = this.getMaxZoom();
            return Math.max(k, Math.min(h, j))
        }
    }), g.map = function (h, i) {
        return new g.Map(h, i)
    }, g.Projection.Mercator = {
        MAX_LATITUDE: 85.0840591556,
        R_MINOR: 6356752.3142,
        R_MAJOR: 6378137,
        project: function (z) {
            var q = g.LatLng.DEG_TO_RAD, n = this.MAX_LATITUDE, k = Math.max(Math.min(n, z.lat), -n), A = this.R_MAJOR, w = this.R_MINOR, j = z.lng * q * A, p = k * q, m = w / A, y = Math.sqrt(1 - m * m), v = y * Math.sin(p);
            v = Math.pow((1 - v) / (1 + v), 0.5 * y);
            var x = Math.tan(0.5 * (0.5 * Math.PI - p)) / v;
            return p = -w * Math.log(x), new g.Point(j, p)
        },
        unproject: function (C) {
            for (var w, q = g.LatLng.RAD_TO_DEG, m = this.R_MAJOR, D = this.R_MINOR, z = C.x * q / m, j = D / m, v = Math.sqrt(1 - j * j), n = Math.exp(-C.y / D), B = Math.PI / 2 - 2 * Math.atan(n), y = 15, A = 1e-7, x = y, k = 0.1; Math.abs(k) > A && --x > 0;) {
                w = v * Math.sin(B), k = Math.PI / 2 - 2 * Math.atan(n * Math.pow((1 - w) / (1 + w), 0.5 * v)) - B, B += k
            }
            return new g.LatLng(B * q, z)
        }
    }, g.CRS.EPSG3395 = g.extend({}, g.CRS, {
        code: "EPSG:3395",
        projection: g.Projection.Mercator,
        transformation: function () {
            var j = g.Projection.Mercator, k = j.R_MAJOR, h = j.R_MINOR;
            return new g.Transformation(0.5 / (Math.PI * k), 0.5, -0.5 / (Math.PI * h), 0.5)
        }()
    }), g.TileLayer = g.Class.extend({
        includes: g.Mixin.Events,
        options: {
            minZoom: 0,
            maxZoom: 18,
            tileSize: 256,
            subdomains: "abc",
            errorTileUrl: "",
            attribution: "",
            zoomOffset: 0,
            opacity: 1,
            unloadInvisibleTiles: g.Browser.mobile,
            updateWhenIdle: g.Browser.mobile
        },
        initialize: function (j, k) {
            k = g.setOptions(this, k), k.detectRetina && g.Browser.retina && k.maxZoom > 0 && (k.tileSize = Math.floor(k.tileSize / 2), k.zoomOffset++, k.minZoom > 0 && k.minZoom--, this.options.maxZoom--), this._url = j;
            var h = this.options.subdomains;
            "string" == typeof h && (this.options.subdomains = h.split(""))
        },
        onAdd: function (e) {
            this._map = e, this._initContainer(), this._createTileProto(), e.on({
                viewreset: this._resetCallback,
                moveend: this._update
            }, this), this.options.updateWhenIdle || (this._limitedUpdate = g.Util.limitExecByInterval(this._update, 150, this), e.on("move", this._limitedUpdate, this)), this._reset(), this._update()
        },
        addTo: function (e) {
            return e.addLayer(this), this
        },
        onRemove: function (e) {
            this._container.parentNode.removeChild(this._container), e.off({
                viewreset: this._resetCallback,
                moveend: this._update
            }, this), this.options.updateWhenIdle || e.off("move", this._limitedUpdate, this), this._container = null, this._map = null
        },
        bringToFront: function () {
            var e = this._map._panes.tilePane;
            return this._container && (e.appendChild(this._container), this._setAutoZIndex(e, Math.max)), this
        },
        bringToBack: function () {
            var e = this._map._panes.tilePane;
            return this._container && (e.insertBefore(this._container, e.firstChild), this._setAutoZIndex(e, Math.min)), this
        },
        getAttribution: function () {
            return this.options.attribution
        },
        setOpacity: function (e) {
            return this.options.opacity = e, this._map && this._updateOpacity(), this
        },
        setZIndex: function (e) {
            return this.options.zIndex = e, this._updateZIndex(), this
        },
        setUrl: function (h, i) {
            return this._url = h, i || this.redraw(), this
        },
        redraw: function () {
            return this._map && (this._map._panes.tilePane.empty = !1, this._reset(!0), this._update()), this
        },
        _updateZIndex: function () {
            this._container && this.options.zIndex !== a && (this._container.style.zIndex = this.options.zIndex)
        },
        _setAutoZIndex: function (k, m) {
            var j, q, p, l = k.children, h = -m(1 / 0, -1 / 0);
            for (q = 0, p = l.length; p > q; q++) {
                l[q] !== this._container && (j = parseInt(l[q].style.zIndex, 10), isNaN(j) || (h = m(h, j)))
            }
            this.options.zIndex = this._container.style.zIndex = (isFinite(h) ? h : 0) + m(1, -1)
        },
        _updateOpacity: function () {
            g.DomUtil.setOpacity(this._container, this.options.opacity);
            var h, i = this._tiles;
            if (g.Browser.webkit) {
                for (h in i) {
                    i.hasOwnProperty(h) && (i[h].style.webkitTransform += " translate(0,0)")
                }
            }
        },
        _initContainer: function () {
            var e = this._map._panes.tilePane;
            (!this._container || e.empty) && (this._container = g.DomUtil.create("div", "leaflet-layer"), this._updateZIndex(), e.appendChild(this._container), 1 > this.options.opacity && this._updateOpacity())
        },
        _resetCallback: function (e) {
            this._reset(e.hard)
        },
        _reset: function (j) {
            var k = this._tiles;
            for (var h in k) {
                k.hasOwnProperty(h) && this.fire("tileunload", {tile: k[h]})
            }
            this._tiles = {}, this._tilesToLoad = 0, this.options.reuseTiles && (this._unusedTiles = []), j && this._container && (this._container.innerHTML = ""), this._initContainer()
        },
        _update: function () {
            if (this._map) {
                var k = this._map.getPixelBounds(), m = this._map.getZoom(), j = this.options.tileSize;
                if (!(m > this.options.maxZoom || this.options.minZoom > m)) {
                    var n = new g.Point(Math.floor(k.min.x / j), Math.floor(k.min.y / j)), l = new g.Point(Math.floor(k.max.x / j), Math.floor(k.max.y / j)), h = new g.Bounds(n, l);
                    this._addTilesFromCenterOut(h), (this.options.unloadInvisibleTiles || this.options.reuseTiles) && this._removeOtherTiles(h)
                }
            }
        },
        _addTilesFromCenterOut: function (m) {
            var k, u, p, j = [], q = m.getCenter();
            for (k = m.min.y; m.max.y >= k; k++) {
                for (u = m.min.x; m.max.x >= u; u++) {
                    p = new g.Point(u, k), this._tileShouldBeLoaded(p) && j.push(p)
                }
            }
            var n = j.length;
            if (0 !== n) {
                j.sort(function (h, i) {
                    return h.distanceTo(q) - i.distanceTo(q)
                });
                var e = d.createDocumentFragment();
                for (this._tilesToLoad || this.fire("loading"), this._tilesToLoad += n, u = 0; n > u; u++) {
                    this._addTile(j[u], e)
                }
                this._container.appendChild(e)
            }
        },
        _tileShouldBeLoaded: function (h) {
            if (h.x + ":" + h.y in this._tiles) {
                return !1
            }
            if (!this.options.continuousWorld) {
                var i = this._getWrapTileNum();
                if (this.options.noWrap && (0 > h.x || h.x >= i) || 0 > h.y || h.y >= i) {
                    return !1
                }
            }
            return !0
        },
        _removeOtherTiles: function (j) {
            var k, h, m, l;
            for (l in this._tiles) {
                this._tiles.hasOwnProperty(l) && (k = l.split(":"), h = parseInt(k[0], 10), m = parseInt(k[1], 10), (j.min.x > h || h > j.max.x || j.min.y > m || m > j.max.y) && this._removeTile(l))
            }
        },
        _removeTile: function (h) {
            var i = this._tiles[h];
            this.fire("tileunload", {
                tile: i,
                url: i.src
            }), this.options.reuseTiles ? (g.DomUtil.removeClass(i, "leaflet-tile-loaded"), this._unusedTiles.push(i)) : i.parentNode === this._container && this._container.removeChild(i), g.Browser.android || (i.src = g.Util.emptyImageUrl), delete this._tiles[h]
        },
        _addTile: function (j, k) {
            var h = this._getTilePos(j), l = this._getTile();
            g.DomUtil.setPosition(l, h, g.Browser.chrome || g.Browser.android23), this._tiles[j.x + ":" + j.y] = l, this._loadTile(l, j), l.parentNode !== this._container && k.appendChild(l)
        },
        _getZoomForUrl: function () {
            var h = this.options, i = this._map.getZoom();
            return h.zoomReverse && (i = h.maxZoom - i), i + h.zoomOffset
        },
        _getTilePos: function (j) {
            var k = this._map.getPixelOrigin(), h = this.options.tileSize;
            return j.multiplyBy(h).subtract(k)
        },
        getTileUrl: function (e) {
            return this._adjustTilePoint(e), g.Util.template(this._url, g.extend({
                s: this._getSubdomain(e),
                z: this._getZoomForUrl(),
                x: e.x,
                y: e.y
            }, this.options))
        },
        _getWrapTileNum: function () {
            return Math.pow(2, this._getZoomForUrl())
        },
        _adjustTilePoint: function (h) {
            var i = this._getWrapTileNum();
            this.options.continuousWorld || this.options.noWrap || (h.x = (h.x % i + i) % i), this.options.tms && (h.y = i - h.y - 1)
        },
        _getSubdomain: function (h) {
            var i = (h.x + h.y) % this.options.subdomains.length;
            return this.options.subdomains[i]
        },
        _createTileProto: function () {
            var e = this._tileImg = g.DomUtil.create("img", "leaflet-tile");
            e.style.width = e.style.height = this.options.tileSize + "px", e.galleryimg = "no"
        },
        _getTile: function () {
            if (this.options.reuseTiles && this._unusedTiles.length > 0) {
                var e = this._unusedTiles.pop();
                return this._resetTile(e), e
            }
            return this._createTile()
        },
        _resetTile: function () {
        },
        _createTile: function () {
            var e = this._tileImg.cloneNode(!1);
            return e.onselectstart = e.onmousemove = g.Util.falseFn, e
        },
        _loadTile: function (h, i) {
            h._layer = this, h.onload = this._tileOnLoad, h.onerror = this._tileOnError, h.src = this.getTileUrl(i)
        },
        _tileLoaded: function () {
            this._tilesToLoad--, this._tilesToLoad || this.fire("load")
        },
        _tileOnLoad: function () {
            var e = this._layer;
            this.src !== g.Util.emptyImageUrl && (g.DomUtil.addClass(this, "leaflet-tile-loaded"), e.fire("tileload", {
                tile: this,
                url: this.src
            })), e._tileLoaded()
        },
        _tileOnError: function () {
            var h = this._layer;
            h.fire("tileerror", {tile: this, url: this.src});
            var i = h.options.errorTileUrl;
            i && (this.src = i), h._tileLoaded()
        }
    }), g.tileLayer = function (h, i) {
        return new g.TileLayer(h, i)
    }, g.TileLayer.WMS = g.TileLayer.extend({
        defaultWmsParams: {
            service: "WMS",
            request: "GetMap",
            version: "1.1.1",
            layers: "",
            styles: "",
            format: "image/jpeg",
            transparent: !1
        }, initialize: function (j, k) {
            this._url = j;
            var h = g.extend({}, this.defaultWmsParams);
            h.width = h.height = k.detectRetina && g.Browser.retina ? 2 * this.options.tileSize : this.options.tileSize;
            for (var l in k) {
                this.options.hasOwnProperty(l) || (h[l] = k[l])
            }
            this.wmsParams = h, g.setOptions(this, k)
        }, onAdd: function (h) {
            var i = parseFloat(this.wmsParams.version) >= 1.3 ? "crs" : "srs";
            this.wmsParams[i] = h.options.crs.code, g.TileLayer.prototype.onAdd.call(this, h)
        }, getTileUrl: function (y, q) {
            this._adjustTilePoint(y);
            var n = this._map, k = n.options.crs, z = this.options.tileSize, w = y.multiplyBy(z), j = w.add(new g.Point(z, z)), p = k.project(n.unproject(w, q)), m = k.project(n.unproject(j, q)), x = [p.x, m.y, m.x, p.y].join(","), v = g.Util.template(this._url, {s: this._getSubdomain(y)});
            return v + g.Util.getParamString(this.wmsParams, v) + "&bbox=" + x
        }, setParams: function (h, i) {
            return g.extend(this.wmsParams, h), i || this.redraw(), this
        }
    }), g.tileLayer.wms = function (h, i) {
        return new g.TileLayer.WMS(h, i)
    }, g.TileLayer.Canvas = g.TileLayer.extend({
        options: {async: !1}, initialize: function (e) {
            g.setOptions(this, e)
        }, redraw: function () {
            var h = this._tiles;
            for (var i in h) {
                h.hasOwnProperty(i) && this._redrawTile(h[i])
            }
        }, _redrawTile: function (e) {
            this.drawTile(e, e._tilePoint, this._map._zoom)
        }, _createTileProto: function () {
            var e = this._canvasProto = g.DomUtil.create("canvas", "leaflet-tile");
            e.width = e.height = this.options.tileSize
        }, _createTile: function () {
            var e = this._canvasProto.cloneNode(!1);
            return e.onselectstart = e.onmousemove = g.Util.falseFn, e
        }, _loadTile: function (h, i) {
            h._layer = this, h._tilePoint = i, this._redrawTile(h), this.options.async || this.tileDrawn(h)
        }, drawTile: function () {
        }, tileDrawn: function (e) {
            this._tileOnLoad.call(e)
        }
    }), g.tileLayer.canvas = function (e) {
        return new g.TileLayer.Canvas(e)
    }, g.ImageOverlay = g.Class.extend({
        includes: g.Mixin.Events,
        options: {opacity: 1},
        initialize: function (j, k, h) {
            this._url = j, this._bounds = g.latLngBounds(k), g.setOptions(this, h)
        },
        onAdd: function (e) {
            this._map = e, this._image || this._initImage(), e._panes.overlayPane.appendChild(this._image), e.on("viewreset", this._reset, this), e.options.zoomAnimation && g.Browser.any3d && e.on("zoomanim", this._animateZoom, this), this._reset()
        },
        onRemove: function (e) {
            e.getPanes().overlayPane.removeChild(this._image), e.off("viewreset", this._reset, this), e.options.zoomAnimation && e.off("zoomanim", this._animateZoom, this)
        },
        addTo: function (e) {
            return e.addLayer(this), this
        },
        setOpacity: function (e) {
            return this.options.opacity = e, this._updateOpacity(), this
        },
        bringToFront: function () {
            return this._image && this._map._panes.overlayPane.appendChild(this._image), this
        },
        bringToBack: function () {
            var e = this._map._panes.overlayPane;
            return this._image && e.insertBefore(this._image, e.firstChild), this
        },
        _initImage: function () {
            this._image = g.DomUtil.create("img", "leaflet-image-layer"), this._map.options.zoomAnimation && g.Browser.any3d ? g.DomUtil.addClass(this._image, "leaflet-zoom-animated") : g.DomUtil.addClass(this._image, "leaflet-zoom-hide"), this._updateOpacity(), g.extend(this._image, {
                galleryimg: "no",
                onselectstart: g.Util.falseFn,
                onmousemove: g.Util.falseFn,
                onload: g.bind(this._onImageLoad, this),
                src: this._url
            })
        },
        _animateZoom: function (v) {
            var q = this._map, n = this._image, k = q.getZoomScale(v.zoom), w = this._bounds.getNorthWest(), u = this._bounds.getSouthEast(), j = q._latLngToNewLayerPoint(w, v.zoom, v.center), p = q._latLngToNewLayerPoint(u, v.zoom, v.center)._subtract(j), m = j._add(p._multiplyBy(0.5 * (1 - 1 / k)));
            n.style[g.DomUtil.TRANSFORM] = g.DomUtil.getTranslateString(m) + " scale(" + k + ") "
        },
        _reset: function () {
            var j = this._image, k = this._map.latLngToLayerPoint(this._bounds.getNorthWest()), h = this._map.latLngToLayerPoint(this._bounds.getSouthEast())._subtract(k);
            g.DomUtil.setPosition(j, k), j.style.width = h.x + "px", j.style.height = h.y + "px"
        },
        _onImageLoad: function () {
            this.fire("load")
        },
        _updateOpacity: function () {
            g.DomUtil.setOpacity(this._image, this.options.opacity)
        }
    }), g.imageOverlay = function (j, k, h) {
        return new g.ImageOverlay(j, k, h)
    }, g.Icon = g.Class.extend({
        options: {className: ""}, initialize: function (e) {
            g.setOptions(this, e)
        }, createIcon: function () {
            return this._createIcon("icon")
        }, createShadow: function () {
            return this._createIcon("shadow")
        }, _createIcon: function (j) {
            var k = this._getIconUrl(j);
            if (!k) {
                if ("icon" === j) {
                    throw Error("iconUrl not set in Icon options (see the docs).")
                }
                return null
            }
            var h = this._createImg(k);
            return this._setIconStyles(h, j), h
        }, _setIconStyles: function (j, l) {
            var h, m = this.options, k = g.point(m[l + "Size"]);
            h = "shadow" === l ? g.point(m.shadowAnchor || m.iconAnchor) : g.point(m.iconAnchor), !h && k && (h = k.divideBy(2, !0)), j.className = "leaflet-marker-" + l + " " + m.className, h && (j.style.marginLeft = -h.x + "px", j.style.marginTop = -h.y + "px"), k && (j.style.width = k.x + "px", j.style.height = k.y + "px")
        }, _createImg: function (h) {
            var e;
            return g.Browser.ie6 ? (e = d.createElement("div"), e.style.filter = 'progid:DXImageTransform.Microsoft.AlphaImageLoader(src="' + h + '")') : (e = d.createElement("img"), e.src = h), e
        }, _getIconUrl: function (e) {
            return g.Browser.retina && this.options[e + "RetinaUrl"] ? this.options[e + "RetinaUrl"] : this.options[e + "Url"]
        }
    }), g.icon = function (e) {
        return new g.Icon(e)
    }, g.Icon.Default = g.Icon.extend({
        options: {
            iconSize: new g.Point(25, 41),
            iconAnchor: new g.Point(12, 41),
            popupAnchor: new g.Point(1, -34),
            shadowSize: new g.Point(41, 41)
        }, _getIconUrl: function (j) {
            var k = j + "Url";
            if (this.options[k]) {
                return this.options[k]
            }
            g.Browser.retina && "icon" === j && (j += "@2x");
            var h = g.Icon.Default.imagePath;
            if (!h) {
                throw Error("Couldn't autodetect L.Icon.Default.imagePath, set it manually.")
            }
            return h + "/marker-" + j + ".png"
        }
    }), g.Icon.Default.imagePath = function () {
        var j, h, m, l, k = d.getElementsByTagName("script"), e = /\/?leaflet[\-\._]?([\w\-\._]*)\.js\??/;
        for (j = 0, h = k.length; h > j; j++) {
            if (m = k[j].src, l = m.match(e)) {
                return m.split(e)[0] + "/images"
            }
        }
    }(), g.Marker = g.Class.extend({
        includes: g.Mixin.Events,
        options: {
            icon: new g.Icon.Default,
            title: "",
            clickable: !0,
            draggable: !1,
            zIndexOffset: 0,
            opacity: 1,
            riseOnHover: !1,
            riseOffset: 250
        },
        initialize: function (h, i) {
            g.setOptions(this, i), this._latlng = g.latLng(h)
        },
        onAdd: function (e) {
            this._map = e, e.on("viewreset", this.update, this), this._initIcon(), this.update(), e.options.zoomAnimation && e.options.markerZoomAnimation && e.on("zoomanim", this._animateZoom, this)
        },
        addTo: function (e) {
            return e.addLayer(this), this
        },
        onRemove: function (e) {
            this._removeIcon(), this.fire("remove"), e.off({
                viewreset: this.update,
                zoomanim: this._animateZoom
            }, this), this._map = null
        },
        getLatLng: function () {
            return this._latlng
        },
        setLatLng: function (e) {
            return this._latlng = g.latLng(e), this.update(), this.fire("move", {latlng: this._latlng})
        },
        setZIndexOffset: function (e) {
            return this.options.zIndexOffset = e, this.update(), this
        },
        setIcon: function (e) {
            return this._map && this._removeIcon(), this.options.icon = e, this._map && (this._initIcon(), this.update()), this
        },
        update: function () {
            if (this._icon) {
                var e = this._map.latLngToLayerPoint(this._latlng).round();
                this._setPos(e)
            }
            return this
        },
        _initIcon: function () {
            var k = this.options, m = this._map, j = m.options.zoomAnimation && m.options.markerZoomAnimation, n = j ? "leaflet-zoom-animated" : "leaflet-zoom-hide", l = !1;
            this._icon || (this._icon = k.icon.createIcon(), k.title && (this._icon.title = k.title), this._initInteraction(), l = 1 > this.options.opacity, g.DomUtil.addClass(this._icon, n), k.riseOnHover && g.DomEvent.on(this._icon, "mouseover", this._bringToFront, this).on(this._icon, "mouseout", this._resetZIndex, this)), this._shadow || (this._shadow = k.icon.createShadow(), this._shadow && (g.DomUtil.addClass(this._shadow, n), l = 1 > this.options.opacity)), l && this._updateOpacity();
            var h = this._map._panes;
            h.markerPane.appendChild(this._icon), this._shadow && h.shadowPane.appendChild(this._shadow)
        },
        _removeIcon: function () {
            var e = this._map._panes;
            this.options.riseOnHover && g.DomEvent.off(this._icon, "mouseover", this._bringToFront).off(this._icon, "mouseout", this._resetZIndex), e.markerPane.removeChild(this._icon), this._shadow && e.shadowPane.removeChild(this._shadow), this._icon = this._shadow = null
        },
        _setPos: function (e) {
            g.DomUtil.setPosition(this._icon, e), this._shadow && g.DomUtil.setPosition(this._shadow, e), this._zIndex = e.y + this.options.zIndexOffset, this._resetZIndex()
        },
        _updateZIndex: function (e) {
            this._icon.style.zIndex = this._zIndex + e
        },
        _animateZoom: function (h) {
            var i = this._map._latLngToNewLayerPoint(this._latlng, h.zoom, h.center);
            this._setPos(i)
        },
        _initInteraction: function () {
            if (this.options.clickable) {
                var j = this._icon, k = ["dblclick", "mousedown", "mouseover", "mouseout", "contextmenu"];
                g.DomUtil.addClass(j, "leaflet-clickable"), g.DomEvent.on(j, "click", this._onMouseClick, this);
                for (var h = 0; k.length > h; h++) {
                    g.DomEvent.on(j, k[h], this._fireMouseEvent, this)
                }
                g.Handler.MarkerDrag && (this.dragging = new g.Handler.MarkerDrag(this), this.options.draggable && this.dragging.enable())
            }
        },
        _onMouseClick: function (h) {
            var i = this.dragging && this.dragging.moved();
            (this.hasEventListeners(h.type) || i) && g.DomEvent.stopPropagation(h), i || (this.dragging && this.dragging._enabled || !this._map.dragging || !this._map.dragging.moved()) && this.fire(h.type, {originalEvent: h})
        },
        _fireMouseEvent: function (e) {
            this.fire(e.type, {originalEvent: e}), "contextmenu" === e.type && this.hasEventListeners(e.type) && g.DomEvent.preventDefault(e), "mousedown" !== e.type && g.DomEvent.stopPropagation(e)
        },
        setOpacity: function (e) {
            this.options.opacity = e, this._map && this._updateOpacity()
        },
        _updateOpacity: function () {
            g.DomUtil.setOpacity(this._icon, this.options.opacity), this._shadow && g.DomUtil.setOpacity(this._shadow, this.options.opacity)
        },
        _bringToFront: function () {
            this._updateZIndex(this.options.riseOffset)
        },
        _resetZIndex: function () {
            this._updateZIndex(0)
        }
    }), g.marker = function (h, i) {
        return new g.Marker(h, i)
    }, g.DivIcon = g.Icon.extend({
        options: {iconSize: new g.Point(12, 12), className: "leaflet-div-icon"},
        createIcon: function () {
            var h = d.createElement("div"), e = this.options;
            return e.html && (h.innerHTML = e.html), e.bgPos && (h.style.backgroundPosition = -e.bgPos.x + "px " + -e.bgPos.y + "px"), this._setIconStyles(h, "icon"), h
        },
        createShadow: function () {
            return null
        }
    }), g.divIcon = function (e) {
        return new g.DivIcon(e)
    }, g.Map.mergeOptions({closePopupOnClick: !0}), g.Popup = g.Class.extend({
        includes: g.Mixin.Events,
        options: {
            minWidth: 50,
            maxWidth: 300,
            maxHeight: null,
            autoPan: !0,
            closeButton: !0,
            offset: new g.Point(0, 6),
            autoPanPadding: new g.Point(5, 5),
            className: "",
            zoomAnimation: !0
        },
        initialize: function (h, i) {
            g.setOptions(this, h), this._source = i, this._animated = g.Browser.any3d && this.options.zoomAnimation
        },
        onAdd: function (h) {
            this._map = h, this._container || this._initLayout(), this._updateContent();
            var i = h.options.fadeAnimation;
            i && g.DomUtil.setOpacity(this._container, 0), h._panes.popupPane.appendChild(this._container), h.on("viewreset", this._updatePosition, this), this._animated && h.on("zoomanim", this._zoomAnimation, this), h.options.closePopupOnClick && h.on("preclick", this._close, this), this._update(), i && g.DomUtil.setOpacity(this._container, 1)
        },
        addTo: function (e) {
            return e.addLayer(this), this
        },
        openOn: function (e) {
            return e.openPopup(this), this
        },
        onRemove: function (e) {
            e._panes.popupPane.removeChild(this._container), g.Util.falseFn(this._container.offsetWidth), e.off({
                viewreset: this._updatePosition,
                preclick: this._close,
                zoomanim: this._zoomAnimation
            }, this), e.options.fadeAnimation && g.DomUtil.setOpacity(this._container, 0), this._map = null
        },
        setLatLng: function (e) {
            return this._latlng = g.latLng(e), this._update(), this
        },
        setContent: function (e) {
            return this._content = e, this._update(), this
        },
        _close: function () {
            var e = this._map;
            e && (e._popup = null, e.removeLayer(this).fire("popupclose", {popup: this}))
        },
        _initLayout: function () {
            var j, l = "leaflet-popup", h = l + " " + this.options.className + " leaflet-zoom-" + (this._animated ? "animated" : "hide"), m = this._container = g.DomUtil.create("div", h);
            this.options.closeButton && (j = this._closeButton = g.DomUtil.create("a", l + "-close-button", m), j.href = "#close", j.innerHTML = "&#215;", g.DomEvent.on(j, "click", this._onCloseButtonClick, this));
            var k = this._wrapper = g.DomUtil.create("div", l + "-content-wrapper", m);
            g.DomEvent.disableClickPropagation(k), this._contentNode = g.DomUtil.create("div", l + "-content", k), g.DomEvent.on(this._contentNode, "mousewheel", g.DomEvent.stopPropagation), this._tipContainer = g.DomUtil.create("div", l + "-tip-container", m), this._tip = g.DomUtil.create("div", l + "-tip", this._tipContainer)
        },
        _update: function () {
            this._map && (this._container.style.visibility = "hidden", this._updateContent(), this._updateLayout(), this._updatePosition(), this._container.style.visibility = "", this._adjustPan())
        },
        _updateContent: function () {
            if (this._content) {
                if ("string" == typeof this._content) {
                    this._contentNode.innerHTML = this._content
                } else {
                    for (; this._contentNode.hasChildNodes();) {
                        this._contentNode.removeChild(this._contentNode.firstChild)
                    }
                    this._contentNode.appendChild(this._content)
                }
                this.fire("contentupdate")
            }
        },
        _updateLayout: function () {
            var k = this._contentNode, m = k.style;
            m.width = "", m.whiteSpace = "nowrap";
            var j = k.offsetWidth;
            j = Math.min(j, this.options.maxWidth), j = Math.max(j, this.options.minWidth), m.width = j + 1 + "px", m.whiteSpace = "", m.height = "";
            var n = k.offsetHeight, l = this.options.maxHeight, h = "leaflet-popup-scrolled";
            l && n > l ? (m.height = l + "px", g.DomUtil.addClass(k, h)) : g.DomUtil.removeClass(k, h), this._containerWidth = this._container.offsetWidth
        },
        _updatePosition: function () {
            if (this._map) {
                var j = this._map.latLngToLayerPoint(this._latlng), k = this._animated, h = this.options.offset;
                k && g.DomUtil.setPosition(this._container, j), this._containerBottom = -h.y - (k ? 0 : j.y), this._containerLeft = -Math.round(this._containerWidth / 2) + h.x + (k ? 0 : j.x), this._container.style.bottom = this._containerBottom + "px", this._container.style.left = this._containerLeft + "px"
            }
        },
        _zoomAnimation: function (h) {
            var i = this._map._latLngToNewLayerPoint(this._latlng, h.zoom, h.center);
            g.DomUtil.setPosition(this._container, i)
        },
        _adjustPan: function () {
            if (this.options.autoPan) {
                var v = this._map, q = this._container.offsetHeight, n = this._containerWidth, k = new g.Point(this._containerLeft, -q - this._containerBottom);
                this._animated && k._add(g.DomUtil.getPosition(this._container));
                var w = v.layerPointToContainerPoint(k), u = this.options.autoPanPadding, j = v.getSize(), p = 0, m = 0;
                0 > w.x && (p = w.x - u.x), w.x + n > j.x && (p = w.x + n - j.x + u.x), 0 > w.y && (m = w.y - u.y), w.y + q > j.y && (m = w.y + q - j.y + u.y), (p || m) && v.panBy(new g.Point(p, m))
            }
        },
        _onCloseButtonClick: function (e) {
            this._close(), g.DomEvent.stop(e)
        }
    }), g.popup = function (h, i) {
        return new g.Popup(h, i)
    }, g.Marker.include({
        openPopup: function () {
            return this._popup && this._map && (this._popup.setLatLng(this._latlng), this._map.openPopup(this._popup)), this
        }, closePopup: function () {
            return this._popup && this._popup._close(), this
        }, bindPopup: function (j, k) {
            var h = g.point(this.options.icon.options.popupAnchor) || new g.Point(0, 0);
            return h = h.add(g.Popup.prototype.options.offset), k && k.offset && (h = h.add(k.offset)), k = g.extend({offset: h}, k), this._popup || this.on("click", this.openPopup, this).on("remove", this.closePopup, this).on("move", this._movePopup, this), this._popup = new g.Popup(k, this).setContent(j), this
        }, unbindPopup: function () {
            return this._popup && (this._popup = null, this.off("click", this.openPopup).off("remove", this.closePopup).off("move", this._movePopup)), this
        }, _movePopup: function (e) {
            this._popup.setLatLng(e.latlng)
        }
    }), g.Map.include({
        openPopup: function (e) {
            return this.closePopup(), this._popup = e, this.addLayer(e).fire("popupopen", {popup: this._popup})
        }, closePopup: function () {
            return this._popup && this._popup._close(), this
        }
    }), g.LayerGroup = g.Class.extend({
        initialize: function (j) {
            this._layers = {};
            var k, h;
            if (j) {
                for (k = 0, h = j.length; h > k; k++) {
                    this.addLayer(j[k])
                }
            }
        }, addLayer: function (h) {
            var i = g.stamp(h);
            return this._layers[i] = h, this._map && this._map.addLayer(h), this
        }, removeLayer: function (h) {
            var i = g.stamp(h);
            return delete this._layers[i], this._map && this._map.removeLayer(h), this
        }, clearLayers: function () {
            return this.eachLayer(this.removeLayer, this), this
        }, invoke: function (j) {
            var k, h, l = Array.prototype.slice.call(arguments, 1);
            for (k in this._layers) {
                this._layers.hasOwnProperty(k) && (h = this._layers[k], h[j] && h[j].apply(h, l))
            }
            return this
        }, onAdd: function (e) {
            this._map = e, this.eachLayer(e.addLayer, e)
        }, onRemove: function (e) {
            this.eachLayer(e.removeLayer, e), this._map = null
        }, addTo: function (e) {
            return e.addLayer(this), this
        }, eachLayer: function (j, k) {
            for (var h in this._layers) {
                this._layers.hasOwnProperty(h) && j.call(k, this._layers[h])
            }
        }, setZIndex: function (e) {
            return this.invoke("setZIndex", e)
        }
    }), g.layerGroup = function (e) {
        return new g.LayerGroup(e)
    }, g.FeatureGroup = g.LayerGroup.extend({
        includes: g.Mixin.Events,
        statics: {EVENTS: "click dblclick mouseover mouseout mousemove contextmenu"},
        addLayer: function (e) {
            return this._layers[g.stamp(e)] ? this : (e.on(g.FeatureGroup.EVENTS, this._propagateEvent, this), g.LayerGroup.prototype.addLayer.call(this, e), this._popupContent && e.bindPopup && e.bindPopup(this._popupContent, this._popupOptions), this.fire("layeradd", {layer: e}))
        },
        removeLayer: function (e) {
            return e.off(g.FeatureGroup.EVENTS, this._propagateEvent, this), g.LayerGroup.prototype.removeLayer.call(this, e), this._popupContent && this.invoke("unbindPopup"), this.fire("layerremove", {layer: e})
        },
        bindPopup: function (h, i) {
            return this._popupContent = h, this._popupOptions = i, this.invoke("bindPopup", h, i)
        },
        setStyle: function (e) {
            return this.invoke("setStyle", e)
        },
        bringToFront: function () {
            return this.invoke("bringToFront")
        },
        bringToBack: function () {
            return this.invoke("bringToBack")
        },
        getBounds: function () {
            var e = new g.LatLngBounds;
            return this.eachLayer(function (h) {
                e.extend(h instanceof g.Marker ? h.getLatLng() : h.getBounds())
            }), e
        },
        _propagateEvent: function (e) {
            e.layer = e.target, e.target = this, this.fire(e.type, e)
        }
    }), g.featureGroup = function (e) {
        return new g.FeatureGroup(e)
    }, g.Path = g.Class.extend({
        includes: [g.Mixin.Events],
        statics: {CLIP_PADDING: g.Browser.mobile ? Math.max(0, Math.min(0.5, (1280 / Math.max(b.innerWidth, b.innerHeight) - 1) / 2)) : 0.5},
        options: {
            stroke: !0,
            color: "#0033ff",
            dashArray: null,
            weight: 5,
            opacity: 0.5,
            fill: !1,
            fillColor: null,
            fillOpacity: 0.2,
            clickable: !0
        },
        initialize: function (e) {
            g.setOptions(this, e)
        },
        onAdd: function (e) {
            this._map = e, this._container || (this._initElements(), this._initEvents()), this.projectLatlngs(), this._updatePath(), this._container && this._map._pathRoot.appendChild(this._container), this.fire("add"), e.on({
                viewreset: this.projectLatlngs,
                moveend: this._updatePath
            }, this)
        },
        addTo: function (e) {
            return e.addLayer(this), this
        },
        onRemove: function (e) {
            e._pathRoot.removeChild(this._container), this.fire("remove"), this._map = null, g.Browser.vml && (this._container = null, this._stroke = null, this._fill = null), e.off({
                viewreset: this.projectLatlngs,
                moveend: this._updatePath
            }, this)
        },
        projectLatlngs: function () {
        },
        setStyle: function (e) {
            return g.setOptions(this, e), this._container && this._updateStyle(), this
        },
        redraw: function () {
            return this._map && (this.projectLatlngs(), this._updatePath()), this
        }
    }), g.Map.include({
        _updatePathViewport: function () {
            var j = g.Path.CLIP_PADDING, l = this.getSize(), h = g.DomUtil.getPosition(this._mapPane), m = h.multiplyBy(-1)._subtract(l.multiplyBy(j)._round()), k = m.add(l.multiplyBy(1 + 2 * j)._round());
            this._pathViewport = new g.Bounds(m, k)
        }
    }), g.Path.SVG_NS = "http://www.w3.org/2000/svg", g.Browser.svg = !(!d.createElementNS || !d.createElementNS(g.Path.SVG_NS, "svg").createSVGRect), g.Path = g.Path.extend({
        statics: {SVG: g.Browser.svg},
        bringToFront: function () {
            var h = this._map._pathRoot, i = this._container;
            return i && h.lastChild !== i && h.appendChild(i), this
        },
        bringToBack: function () {
            var j = this._map._pathRoot, k = this._container, h = j.firstChild;
            return k && h !== k && j.insertBefore(k, h), this
        },
        getPathString: function () {
        },
        _createElement: function (e) {
            return d.createElementNS(g.Path.SVG_NS, e)
        },
        _initElements: function () {
            this._map._initPathRoot(), this._initPath(), this._initStyle()
        },
        _initPath: function () {
            this._container = this._createElement("g"), this._path = this._createElement("path"), this._container.appendChild(this._path)
        },
        _initStyle: function () {
            this.options.stroke && (this._path.setAttribute("stroke-linejoin", "round"), this._path.setAttribute("stroke-linecap", "round")), this.options.fill && this._path.setAttribute("fill-rule", "evenodd"), this._updateStyle()
        },
        _updateStyle: function () {
            this.options.stroke ? (this._path.setAttribute("stroke", this.options.color), this._path.setAttribute("stroke-opacity", this.options.opacity), this._path.setAttribute("stroke-width", this.options.weight), this.options.dashArray ? this._path.setAttribute("stroke-dasharray", this.options.dashArray) : this._path.removeAttribute("stroke-dasharray")) : this._path.setAttribute("stroke", "none"), this.options.fill ? (this._path.setAttribute("fill", this.options.fillColor || this.options.color), this._path.setAttribute("fill-opacity", this.options.fillOpacity)) : this._path.setAttribute("fill", "none")
        },
        _updatePath: function () {
            var e = this.getPathString();
            e || (e = "M0 0"), this._path.setAttribute("d", e)
        },
        _initEvents: function () {
            if (this.options.clickable) {
                (g.Browser.svg || !g.Browser.vml) && this._path.setAttribute("class", "leaflet-clickable"), g.DomEvent.on(this._container, "click", this._onMouseClick, this);
                for (var h = ["dblclick", "mousedown", "mouseover", "mouseout", "mousemove", "contextmenu"], i = 0; h.length > i; i++) {
                    g.DomEvent.on(this._container, h[i], this._fireMouseEvent, this)
                }
            }
        },
        _onMouseClick: function (e) {
            this._map.dragging && this._map.dragging.moved() || this._fireMouseEvent(e)
        },
        _fireMouseEvent: function (j) {
            if (this.hasEventListeners(j.type)) {
                var l = this._map, h = l.mouseEventToContainerPoint(j), m = l.containerPointToLayerPoint(h), k = l.layerPointToLatLng(m);
                this.fire(j.type, {
                    latlng: k,
                    layerPoint: m,
                    containerPoint: h,
                    originalEvent: j
                }), "contextmenu" === j.type && g.DomEvent.preventDefault(j), "mousemove" !== j.type && g.DomEvent.stopPropagation(j)
            }
        }
    }), g.Map.include({
        _initPathRoot: function () {
            this._pathRoot || (this._pathRoot = g.Path.prototype._createElement("svg"), this._panes.overlayPane.appendChild(this._pathRoot), this.options.zoomAnimation && g.Browser.any3d ? (this._pathRoot.setAttribute("class", " leaflet-zoom-animated"), this.on({
                zoomanim: this._animatePathZoom,
                zoomend: this._endPathZoom
            })) : this._pathRoot.setAttribute("class", " leaflet-zoom-hide"), this.on("moveend", this._updateSvgViewport), this._updateSvgViewport())
        }, _animatePathZoom: function (j) {
            var k = this.getZoomScale(j.zoom), h = this._getCenterOffset(j.center)._multiplyBy(-k)._add(this._pathViewport.min);
            this._pathRoot.style[g.DomUtil.TRANSFORM] = g.DomUtil.getTranslateString(h) + " scale(" + k + ") ", this._pathZooming = !0
        }, _endPathZoom: function () {
            this._pathZooming = !1
        }, _updateSvgViewport: function () {
            if (!this._pathZooming) {
                this._updatePathViewport();
                var k = this._pathViewport, n = k.min, j = k.max, p = j.x - n.x, l = j.y - n.y, h = this._pathRoot, m = this._panes.overlayPane;
                g.Browser.mobileWebkit && m.removeChild(h), g.DomUtil.setPosition(h, n), h.setAttribute("width", p), h.setAttribute("height", l), h.setAttribute("viewBox", [n.x, n.y, p, l].join(" ")), g.Browser.mobileWebkit && m.appendChild(h)
            }
        }
    }), g.Path.include({
        bindPopup: function (h, i) {
            return (!this._popup || i) && (this._popup = new g.Popup(i, this)), this._popup.setContent(h), this._popupHandlersAdded || (this.on("click", this._openPopup, this).on("remove", this.closePopup, this), this._popupHandlersAdded = !0), this
        }, unbindPopup: function () {
            return this._popup && (this._popup = null, this.off("click", this._openPopup).off("remove", this.closePopup), this._popupHandlersAdded = !1), this
        }, openPopup: function (e) {
            return this._popup && (e = e || this._latlng || this._latlngs[Math.floor(this._latlngs.length / 2)], this._openPopup({latlng: e})), this
        }, closePopup: function () {
            return this._popup && this._popup._close(), this
        }, _openPopup: function (e) {
            this._popup.setLatLng(e.latlng), this._map.openPopup(this._popup)
        }
    }), g.Browser.vml = !g.Browser.svg && function () {
            try {
                var h = d.createElement("div");
                h.innerHTML = '<v:shape adj="1"/>';
                var e = h.firstChild;
                return e.style.behavior = "url(#default#VML)", e && "object" == typeof e.adj
            } catch (j) {
                return !1
            }
        }(), g.Path = g.Browser.svg || !g.Browser.vml ? g.Path : g.Path.extend({
        statics: {VML: !0, CLIP_PADDING: 0.02},
        _createElement: function () {
            try {
                return d.namespaces.add("lvml", "urn:schemas-microsoft-com:vml"), function (h) {
                    return d.createElement("<lvml:" + h + ' class="lvml">')
                }
            } catch (e) {
                return function (h) {
                    return d.createElement("<" + h + ' xmlns="urn:schemas-microsoft.com:vml" class="lvml">')
                }
            }
        }(),
        _initPath: function () {
            var e = this._container = this._createElement("shape");
            g.DomUtil.addClass(e, "leaflet-vml-shape"), this.options.clickable && g.DomUtil.addClass(e, "leaflet-clickable"), e.coordsize = "1 1", this._path = this._createElement("path"), e.appendChild(this._path), this._map._pathRoot.appendChild(e)
        },
        _initStyle: function () {
            this._updateStyle()
        },
        _updateStyle: function () {
            var j = this._stroke, k = this._fill, h = this.options, l = this._container;
            l.stroked = h.stroke, l.filled = h.fill, h.stroke ? (j || (j = this._stroke = this._createElement("stroke"), j.endcap = "round", l.appendChild(j)), j.weight = h.weight + "px", j.color = h.color, j.opacity = h.opacity, j.dashStyle = h.dashArray ? h.dashArray instanceof Array ? h.dashArray.join(" ") : h.dashArray.replace(/ *, */g, " ") : "") : j && (l.removeChild(j), this._stroke = null), h.fill ? (k || (k = this._fill = this._createElement("fill"), l.appendChild(k)), k.color = h.fillColor || h.color, k.opacity = h.fillOpacity) : k && (l.removeChild(k), this._fill = null)
        },
        _updatePath: function () {
            var e = this._container.style;
            e.display = "none", this._path.v = this.getPathString() + " ", e.display = ""
        }
    }), g.Map.include(g.Browser.svg || !g.Browser.vml ? {} : {
        _initPathRoot: function () {
            if (!this._pathRoot) {
                var e = this._pathRoot = d.createElement("div");
                e.className = "leaflet-vml-container", this._panes.overlayPane.appendChild(e), this.on("moveend", this._updatePathViewport), this._updatePathViewport()
            }
        }
    }), g.Browser.canvas = function () {
        return !!d.createElement("canvas").getContext
    }(), g.Path = g.Path.SVG && !b.L_PREFER_CANVAS || !g.Browser.canvas ? g.Path : g.Path.extend({
        statics: {
            CANVAS: !0,
            SVG: !1
        }, redraw: function () {
            return this._map && (this.projectLatlngs(), this._requestUpdate()), this
        }, setStyle: function (e) {
            return g.setOptions(this, e), this._map && (this._updateStyle(), this._requestUpdate()), this
        }, onRemove: function (e) {
            e.off("viewreset", this.projectLatlngs, this).off("moveend", this._updatePath, this), this.options.clickable && this._map.off("click", this._onClick, this), this._requestUpdate(), this._map = null
        }, _requestUpdate: function () {
            this._map && !g.Path._updateRequest && (g.Path._updateRequest = g.Util.requestAnimFrame(this._fireMapMoveEnd, this._map))
        }, _fireMapMoveEnd: function () {
            g.Path._updateRequest = null, this.fire("moveend")
        }, _initElements: function () {
            this._map._initPathRoot(), this._ctx = this._map._canvasCtx
        }, _updateStyle: function () {
            var e = this.options;
            e.stroke && (this._ctx.lineWidth = e.weight, this._ctx.strokeStyle = e.color), e.fill && (this._ctx.fillStyle = e.fillColor || e.color)
        }, _drawPath: function () {
            var k, m, j, n, l, h;
            for (this._ctx.beginPath(), k = 0, j = this._parts.length; j > k; k++) {
                for (m = 0, n = this._parts[k].length; n > m; m++) {
                    l = this._parts[k][m], h = (0 === m ? "move" : "line") + "To", this._ctx[h](l.x, l.y)
                }
                this instanceof g.Polygon && this._ctx.closePath()
            }
        }, _checkIfEmpty: function () {
            return !this._parts.length
        }, _updatePath: function () {
            if (!this._checkIfEmpty()) {
                var h = this._ctx, i = this.options;
                this._drawPath(), h.save(), this._updateStyle(), i.fill && (h.globalAlpha = i.fillOpacity, h.fill()), i.stroke && (h.globalAlpha = i.opacity, h.stroke()), h.restore()
            }
        }, _initEvents: function () {
            this.options.clickable && this._map.on("click", this._onClick, this)
        }, _onClick: function (e) {
            this._containsPoint(e.layerPoint) && this.fire("click", {
                latlng: e.latlng,
                layerPoint: e.layerPoint,
                containerPoint: e.containerPoint,
                originalEvent: e
            })
        }
    }), g.Map.include(g.Path.SVG && !b.L_PREFER_CANVAS || !g.Browser.canvas ? {} : {
        _initPathRoot: function () {
            var h, e = this._pathRoot;
            e || (e = this._pathRoot = d.createElement("canvas"), e.style.position = "absolute", h = this._canvasCtx = e.getContext("2d"), h.lineCap = "round", h.lineJoin = "round", this._panes.overlayPane.appendChild(e), this.options.zoomAnimation && (this._pathRoot.className = "leaflet-zoom-animated", this.on("zoomanim", this._animatePathZoom), this.on("zoomend", this._endPathZoom)), this.on("moveend", this._updateCanvasViewport), this._updateCanvasViewport())
        }, _updateCanvasViewport: function () {
            if (!this._pathZooming) {
                this._updatePathViewport();
                var j = this._pathViewport, k = j.min, h = j.max.subtract(k), l = this._pathRoot;
                g.DomUtil.setPosition(l, k), l.width = h.x, l.height = h.y, l.getContext("2d").translate(-k.x, -k.y)
            }
        }
    }), g.LineUtil = {
        simplify: function (j, k) {
            if (!k || !j.length) {
                return j.slice()
            }
            var h = k * k;
            return j = this._reducePoints(j, h), j = this._simplifyDP(j, h)
        }, pointToSegmentDistance: function (j, k, h) {
            return Math.sqrt(this._sqClosestPointOnSegment(j, k, h, !0))
        }, closestPointOnSegment: function (j, k, h) {
            return this._sqClosestPointOnSegment(j, k, h)
        }, _simplifyDP: function (i, l) {
            var p = i.length, m = typeof Uint8Array != a + "" ? Uint8Array : Array, j = new m(p);
            j[0] = j[p - 1] = 1, this._simplifyDPStep(i, j, l, 0, p - 1);
            var h, k = [];
            for (h = 0; p > h; h++) {
                j[h] && k.push(i[h])
            }
            return k
        }, _simplifyDPStep: function (v, q, m, l, k) {
            var w, u, j, p = 0;
            for (u = l + 1; k - 1 >= u; u++) {
                j = this._sqClosestPointOnSegment(v[u], v[l], v[k], !0), j > p && (w = u, p = j)
            }
            p > m && (q[w] = 1, this._simplifyDPStep(v, q, m, l, w), this._simplifyDPStep(v, q, m, w, k))
        }, _reducePoints: function (j, l) {
            for (var h = [j[0]], p = 1, m = 0, k = j.length; k > p; p++) {
                this._sqDist(j[p], j[m]) > l && (h.push(j[p]), m = p)
            }
            return k - 1 > m && h.push(j[k - 1]), h
        }, clipSegment: function (v, q, m, l) {
            var k, w, u, j = l ? this._lastCode : this._getBitCode(v, m), p = this._getBitCode(q, m);
            for (this._lastCode = p; ;) {
                if (!(j | p)) {
                    return [v, q]
                }
                if (j & p) {
                    return !1
                }
                k = j || p, w = this._getEdgeIntersection(v, q, k, m), u = this._getBitCode(w, m), k === j ? (v = w, j = u) : (q = w, p = u)
            }
        }, _getEdgeIntersection: function (k, q, u, n) {
            var j = q.x - k.x, p = q.y - k.y, m = n.min, i = n.max;
            return 8 & u ? new g.Point(k.x + j * (i.y - k.y) / p, i.y) : 4 & u ? new g.Point(k.x + j * (m.y - k.y) / p, m.y) : 2 & u ? new g.Point(i.x, k.y + p * (i.x - k.x) / j) : 1 & u ? new g.Point(m.x, k.y + p * (m.x - k.x) / j) : a
        }, _getBitCode: function (j, k) {
            var h = 0;
            return j.x < k.min.x ? h |= 1 : j.x > k.max.x && (h |= 2), j.y < k.min.y ? h |= 4 : j.y > k.max.y && (h |= 8), h
        }, _sqDist: function (j, k) {
            var h = k.x - j.x, l = k.y - j.y;
            return h * h + l * l
        }, _sqClosestPointOnSegment: function (x, q, n, k) {
            var y, v = q.x, j = q.y, p = n.x - v, m = n.y - j, w = p * p + m * m;
            return w > 0 && (y = ((x.x - v) * p + (x.y - j) * m) / w, y > 1 ? (v = n.x, j = n.y) : y > 0 && (v += p * y, j += m * y)), p = x.x - v, m = x.y - j, k ? p * p + m * m : new g.Point(v, j)
        }
    }, g.Polyline = g.Path.extend({
        initialize: function (h, i) {
            g.Path.prototype.initialize.call(this, i), this._latlngs = this._convertLatLngs(h)
        }, options: {smoothFactor: 1, noClip: !1}, projectLatlngs: function () {
            this._originalPoints = [];
            for (var h = 0, i = this._latlngs.length; i > h; h++) {
                this._originalPoints[h] = this._map.latLngToLayerPoint(this._latlngs[h])
            }
        }, getPathString: function () {
            for (var j = 0, k = this._parts.length, h = ""; k > j; j++) {
                h += this._getPathPartStr(this._parts[j])
            }
            return h
        }, getLatLngs: function () {
            return this._latlngs
        }, setLatLngs: function (e) {
            return this._latlngs = this._convertLatLngs(e), this.redraw()
        }, addLatLng: function (e) {
            return this._latlngs.push(g.latLng(e)), this.redraw()
        }, spliceLatLngs: function () {
            var e = [].splice.apply(this._latlngs, arguments);
            return this._convertLatLngs(this._latlngs), this.redraw(), e
        }, closestLayerPoint: function (z) {
            for (var q, n, k = 1 / 0, A = this._parts, w = null, j = 0, p = A.length; p > j; j++) {
                for (var m = A[j], y = 1, v = m.length; v > y; y++) {
                    q = m[y - 1], n = m[y];
                    var x = g.LineUtil._sqClosestPointOnSegment(z, q, n, !0);
                    k > x && (k = x, w = g.LineUtil._sqClosestPointOnSegment(z, q, n))
                }
            }
            return w && (w.distance = Math.sqrt(k)), w
        }, getBounds: function () {
            var j, k, h = new g.LatLngBounds, l = this.getLatLngs();
            for (j = 0, k = l.length; k > j; j++) {
                h.extend(l[j])
            }
            return h
        }, _convertLatLngs: function (j) {
            var k, h;
            for (k = 0, h = j.length; h > k; k++) {
                if (g.Util.isArray(j[k]) && "number" != typeof j[k][0]) {
                    return
                }
                j[k] = g.latLng(j[k])
            }
            return j
        }, _initEvents: function () {
            g.Path.prototype._initEvents.call(this)
        }, _getPathPartStr: function (k) {
            for (var m, j = g.Path.VML, n = 0, l = k.length, h = ""; l > n; n++) {
                m = k[n], j && m._round(), h += (n ? "L" : "M") + m.x + " " + m.y
            }
            return h
        }, _clipPoints: function () {
            var k, q, u, n = this._originalPoints, j = n.length;
            if (this.options.noClip) {
                return this._parts = [n], a
            }
            this._parts = [];
            var p = this._parts, m = this._map._pathViewport, i = g.LineUtil;
            for (k = 0, q = 0; j - 1 > k; k++) {
                u = i.clipSegment(n[k], n[k + 1], m, k), u && (p[q] = p[q] || [], p[q].push(u[0]), (u[1] !== n[k + 1] || k === j - 2) && (p[q].push(u[1]), q++))
            }
        }, _simplifyPoints: function () {
            for (var j = this._parts, k = g.LineUtil, h = 0, l = j.length; l > h; h++) {
                j[h] = k.simplify(j[h], this.options.smoothFactor)
            }
        }, _updatePath: function () {
            this._map && (this._clipPoints(), this._simplifyPoints(), g.Path.prototype._updatePath.call(this))
        }
    }), g.polyline = function (h, i) {
        return new g.Polyline(h, i)
    }, g.PolyUtil = {}, g.PolyUtil.clipPolygon = function (A, q) {
        var n, k, B, x, j, p, m, z, w, y = [1, 4, 2, 8], v = g.LineUtil;
        for (k = 0, m = A.length; m > k; k++) {
            A[k]._code = v._getBitCode(A[k], q)
        }
        for (x = 0; 4 > x; x++) {
            for (z = y[x], n = [], k = 0, m = A.length, B = m - 1; m > k; B = k++) {
                j = A[k], p = A[B], j._code & z ? p._code & z || (w = v._getEdgeIntersection(p, j, z, q), w._code = v._getBitCode(w, q), n.push(w)) : (p._code & z && (w = v._getEdgeIntersection(p, j, z, q), w._code = v._getBitCode(w, q), n.push(w)), n.push(j))
            }
            A = n
        }
        return A
    }, g.Polygon = g.Polyline.extend({
        options: {fill: !0}, initialize: function (h, i) {
            g.Polyline.prototype.initialize.call(this, h, i), h && g.Util.isArray(h[0]) && "number" != typeof h[0][0] && (this._latlngs = this._convertLatLngs(h[0]), this._holes = h.slice(1))
        }, projectLatlngs: function () {
            if (g.Polyline.prototype.projectLatlngs.call(this), this._holePoints = [], this._holes) {
                var j, k, h, l;
                for (j = 0, h = this._holes.length; h > j; j++) {
                    for (this._holePoints[j] = [], k = 0, l = this._holes[j].length; l > k; k++) {
                        this._holePoints[j][k] = this._map.latLngToLayerPoint(this._holes[j][k])
                    }
                }
            }
        }, _clipPoints: function () {
            var j = this._originalPoints, l = [];
            if (this._parts = [j].concat(this._holePoints), !this.options.noClip) {
                for (var h = 0, m = this._parts.length; m > h; h++) {
                    var k = g.PolyUtil.clipPolygon(this._parts[h], this._map._pathViewport);
                    k.length && l.push(k)
                }
                this._parts = l
            }
        }, _getPathPartStr: function (h) {
            var i = g.Polyline.prototype._getPathPartStr.call(this, h);
            return i + (g.Browser.svg ? "z" : "x")
        }
    }), g.polygon = function (h, i) {
        return new g.Polygon(h, i)
    }, function () {
        function e(h) {
            return g.FeatureGroup.extend({
                initialize: function (i, j) {
                    this._layers = {}, this._options = j, this.setLatLngs(i)
                }, setLatLngs: function (k) {
                    var j = 0, l = k.length;
                    for (this.eachLayer(function (i) {
                        l > j ? i.setLatLngs(k[j++]) : this.removeLayer(i)
                    }, this); l > j;) {
                        this.addLayer(new h(k[j++], this._options))
                    }
                    return this
                }
            })
        }

        g.MultiPolyline = e(g.Polyline), g.MultiPolygon = e(g.Polygon), g.multiPolyline = function (h, i) {
            return new g.MultiPolyline(h, i)
        }, g.multiPolygon = function (h, i) {
            return new g.MultiPolygon(h, i)
        }
    }(), g.Rectangle = g.Polygon.extend({
        initialize: function (h, i) {
            g.Polygon.prototype.initialize.call(this, this._boundsToLatLngs(h), i)
        }, setBounds: function (e) {
            this.setLatLngs(this._boundsToLatLngs(e))
        }, _boundsToLatLngs: function (e) {
            return e = g.latLngBounds(e), [e.getSouthWest(), e.getNorthWest(), e.getNorthEast(), e.getSouthEast()]
        }
    }), g.rectangle = function (h, i) {
        return new g.Rectangle(h, i)
    }, g.Circle = g.Path.extend({
        initialize: function (j, k, h) {
            g.Path.prototype.initialize.call(this, h), this._latlng = g.latLng(j), this._mRadius = k
        }, options: {fill: !0}, setLatLng: function (e) {
            return this._latlng = g.latLng(e), this.redraw()
        }, setRadius: function (e) {
            return this._mRadius = e, this.redraw()
        }, projectLatlngs: function () {
            var j = this._getLngRadius(), k = new g.LatLng(this._latlng.lat, this._latlng.lng - j), h = this._map.latLngToLayerPoint(k);
            this._point = this._map.latLngToLayerPoint(this._latlng), this._radius = Math.max(Math.round(this._point.x - h.x), 1)
        }, getBounds: function () {
            var j = this._getLngRadius(), l = 360 * (this._mRadius / 40075017), h = this._latlng, m = new g.LatLng(h.lat - l, h.lng - j), k = new g.LatLng(h.lat + l, h.lng + j);
            return new g.LatLngBounds(m, k)
        }, getLatLng: function () {
            return this._latlng
        }, getPathString: function () {
            var h = this._point, i = this._radius;
            return this._checkIfEmpty() ? "" : g.Browser.svg ? "M" + h.x + "," + (h.y - i) + "A" + i + "," + i + ",0,1,1," + (h.x - 0.1) + "," + (h.y - i) + " z" : (h._round(), i = Math.round(i), "AL " + h.x + "," + h.y + " " + i + "," + i + " 0," + 23592600)
        }, getRadius: function () {
            return this._mRadius
        }, _getLatRadius: function () {
            return 360 * (this._mRadius / 40075017)
        }, _getLngRadius: function () {
            return this._getLatRadius() / Math.cos(g.LatLng.DEG_TO_RAD * this._latlng.lat)
        }, _checkIfEmpty: function () {
            if (!this._map) {
                return !1
            }
            var j = this._map._pathViewport, k = this._radius, h = this._point;
            return h.x - k > j.max.x || h.y - k > j.max.y || h.x + k < j.min.x || h.y + k < j.min.y
        }
    }), g.circle = function (j, k, h) {
        return new g.Circle(j, k, h)
    }, g.CircleMarker = g.Circle.extend({
        options: {radius: 10, weight: 2}, initialize: function (h, i) {
            g.Circle.prototype.initialize.call(this, h, null, i), this._radius = this.options.radius
        }, projectLatlngs: function () {
            this._point = this._map.latLngToLayerPoint(this._latlng)
        }, _updateStyle: function () {
            g.Circle.prototype._updateStyle.call(this), this.setRadius(this.options.radius)
        }, setRadius: function (e) {
            return this.options.radius = this._radius = e, this.redraw()
        }
    }), g.circleMarker = function (h, i) {
        return new g.CircleMarker(h, i)
    }, g.Polyline.include(g.Path.CANVAS ? {
        _containsPoint: function (x, q) {
            var n, k, y, v, j, p, m, w = this.options.weight / 2;
            for (g.Browser.touch && (w += 10), n = 0, v = this._parts.length; v > n; n++) {
                for (m = this._parts[n], k = 0, j = m.length, y = j - 1; j > k; y = k++) {
                    if ((q || 0 !== k) && (p = g.LineUtil.pointToSegmentDistance(x, m[y], m[k]), w >= p)) {
                        return !0
                    }
                }
            }
            return !1
        }
    } : {}), g.Polygon.include(g.Path.CANVAS ? {
        _containsPoint: function (x) {
            var q, n, k, y, v, j, p, m, w = !1;
            if (g.Polyline.prototype._containsPoint.call(this, x, !0)) {
                return !0
            }
            for (y = 0, p = this._parts.length; p > y; y++) {
                for (q = this._parts[y], v = 0, m = q.length, j = m - 1; m > v; j = v++) {
                    n = q[v], k = q[j], n.y > x.y != k.y > x.y && x.x < (k.x - n.x) * (x.y - n.y) / (k.y - n.y) + n.x && (w = !w)
                }
            }
            return w
        }
    } : {}), g.Circle.include(g.Path.CANVAS ? {
        _drawPath: function () {
            var e = this._point;
            this._ctx.beginPath(), this._ctx.arc(e.x, e.y, this._radius, 0, 2 * Math.PI, !1)
        }, _containsPoint: function (j) {
            var k = this._point, h = this.options.stroke ? this.options.weight / 2 : 0;
            return j.distanceTo(k) <= this._radius + h
        }
    } : {}), g.GeoJSON = g.FeatureGroup.extend({
        initialize: function (h, i) {
            g.setOptions(this, i), this._layers = {}, h && this.addData(h)
        }, addData: function (k) {
            var m, j, n = g.Util.isArray(k) ? k : k.features;
            if (n) {
                for (m = 0, j = n.length; j > m; m++) {
                    (n[m].geometries || n[m].geometry || n[m].features) && this.addData(n[m])
                }
                return this
            }
            var l = this.options;
            if (!l.filter || l.filter(k)) {
                var h = g.GeoJSON.geometryToLayer(k, l.pointToLayer);
                return h.feature = k, h.defaultOptions = h.options, this.resetStyle(h), l.onEachFeature && l.onEachFeature(k, h), this.addLayer(h)
            }
        }, resetStyle: function (h) {
            var i = this.options.style;
            i && (g.Util.extend(h.options, h.defaultOptions), this._setLayerStyle(h, i))
        }, setStyle: function (e) {
            this.eachLayer(function (h) {
                this._setLayerStyle(h, e)
            }, this)
        }, _setLayerStyle: function (h, i) {
            "function" == typeof i && (i = i(h.feature)), h.setStyle && h.setStyle(i)
        }
    }), g.extend(g.GeoJSON, {
        geometryToLayer: function (x, q) {
            var n, k, y, v, j, p = "Feature" === x.type ? x.geometry : x, m = p.coordinates, w = [];
            switch (p.type) {
                case"Point":
                    return n = this.coordsToLatLng(m), q ? q(x, n) : new g.Marker(n);
                case"MultiPoint":
                    for (y = 0, v = m.length; v > y; y++) {
                        n = this.coordsToLatLng(m[y]), j = q ? q(x, n) : new g.Marker(n), w.push(j)
                    }
                    return new g.FeatureGroup(w);
                case"LineString":
                    return k = this.coordsToLatLngs(m), new g.Polyline(k);
                case"Polygon":
                    return k = this.coordsToLatLngs(m, 1), new g.Polygon(k);
                case"MultiLineString":
                    return k = this.coordsToLatLngs(m, 1), new g.MultiPolyline(k);
                case"MultiPolygon":
                    return k = this.coordsToLatLngs(m, 2), new g.MultiPolygon(k);
                case"GeometryCollection":
                    for (y = 0, v = p.geometries.length; v > y; y++) {
                        j = this.geometryToLayer({
                            geometry: p.geometries[y],
                            type: "Feature",
                            properties: x.properties
                        }, q), w.push(j)
                    }
                    return new g.FeatureGroup(w);
                default:
                    throw Error("Invalid GeoJSON object.")
            }
        }, coordsToLatLng: function (j, k) {
            var h = parseFloat(j[k ? 0 : 1]), l = parseFloat(j[k ? 1 : 0]);
            return new g.LatLng(h, l)
        }, coordsToLatLngs: function (k, m, j) {
            var q, p, l, h = [];
            for (p = 0, l = k.length; l > p; p++) {
                q = m ? this.coordsToLatLngs(k[p], m - 1, j) : this.coordsToLatLng(k[p], j), h.push(q)
            }
            return h
        }
    }), g.geoJson = function (h, i) {
        return new g.GeoJSON(h, i)
    }, g.DomEvent = {
        addListener: function (v, n, j, w) {
            var p, i, m, k = g.stamp(j), q = "_leaflet_" + n + k;
            return v[q] ? this : (p = function (h) {
                return j.call(w || v, h || g.DomEvent._getEvent())
            }, g.Browser.msTouch && 0 === n.indexOf("touch") ? this.addMsTouchListener(v, n, p, k) : (g.Browser.touch && "dblclick" === n && this.addDoubleTapListener && this.addDoubleTapListener(v, p, k), "addEventListener" in v ? "mousewheel" === n ? (v.addEventListener("DOMMouseScroll", p, !1), v.addEventListener(n, p, !1)) : "mouseenter" === n || "mouseleave" === n ? (i = p, m = "mouseenter" === n ? "mouseover" : "mouseout", p = function (h) {
                return g.DomEvent._checkMouse(v, h) ? i(h) : a
            }, v.addEventListener(m, p, !1)) : v.addEventListener(n, p, !1) : "attachEvent" in v && v.attachEvent("on" + n, p), v[q] = p, this))
        }, removeListener: function (k, m, j) {
            var n = g.stamp(j), l = "_leaflet_" + m + n, h = k[l];
            if (h) {
                return g.Browser.msTouch && 0 === m.indexOf("touch") ? this.removeMsTouchListener(k, m, n) : g.Browser.touch && "dblclick" === m && this.removeDoubleTapListener ? this.removeDoubleTapListener(k, n) : "removeEventListener" in k ? "mousewheel" === m ? (k.removeEventListener("DOMMouseScroll", h, !1), k.removeEventListener(m, h, !1)) : "mouseenter" === m || "mouseleave" === m ? k.removeEventListener("mouseenter" === m ? "mouseover" : "mouseout", h, !1) : k.removeEventListener(m, h, !1) : "detachEvent" in k && k.detachEvent("on" + m, h), k[l] = null, this
            }
        }, stopPropagation: function (e) {
            return e.stopPropagation ? e.stopPropagation() : e.cancelBubble = !0, this
        }, disableClickPropagation: function (j) {
            for (var k = g.DomEvent.stopPropagation, h = g.Draggable.START.length - 1; h >= 0; h--) {
                g.DomEvent.addListener(j, g.Draggable.START[h], k)
            }
            return g.DomEvent.addListener(j, "click", k).addListener(j, "dblclick", k)
        }, preventDefault: function (e) {
            return e.preventDefault ? e.preventDefault() : e.returnValue = !1, this
        }, stop: function (e) {
            return g.DomEvent.preventDefault(e).stopPropagation(e)
        }, getMousePosition: function (k, j) {
            var p = d.body, m = d.documentElement, e = k.pageX ? k.pageX : k.clientX + p.scrollLeft + m.scrollLeft, n = k.pageY ? k.pageY : k.clientY + p.scrollTop + m.scrollTop, l = new g.Point(e, n);
            return j ? l._subtract(g.DomUtil.getViewportOffset(j)) : l
        }, getWheelDelta: function (h) {
            var i = 0;
            return h.wheelDelta && (i = h.wheelDelta / 120), h.detail && (i = -h.detail / 3), i
        }, _checkMouse: function (j, k) {
            var h = k.relatedTarget;
            if (!h) {
                return !0
            }
            try {
                for (; h && h !== j;) {
                    h = h.parentNode
                }
            } catch (l) {
                return !1
            }
            return h !== j
        }, _getEvent: function () {
            var j = b.event;
            if (!j) {
                for (var h = arguments.callee.caller; h && (j = h.arguments[0], !j || b.Event !== j.constructor);) {
                    h = h.caller
                }
            }
            return j
        }
    }, g.DomEvent.on = g.DomEvent.addListener, g.DomEvent.off = g.DomEvent.removeListener, g.Draggable = g.Class.extend({
        includes: g.Mixin.Events,
        statics: {
            START: g.Browser.touch ? ["touchstart", "mousedown"] : ["mousedown"],
            END: {mousedown: "mouseup", touchstart: "touchend", MSPointerDown: "touchend"},
            MOVE: {mousedown: "mousemove", touchstart: "touchmove", MSPointerDown: "touchmove"},
            TAP_TOLERANCE: 15
        },
        initialize: function (j, k, h) {
            this._element = j, this._dragStartTarget = k || j, this._longPress = h && !g.Browser.msTouch
        },
        enable: function () {
            if (!this._enabled) {
                for (var e = g.Draggable.START.length - 1; e >= 0; e--) {
                    g.DomEvent.on(this._dragStartTarget, g.Draggable.START[e], this._onDown, this)
                }
                this._enabled = !0
            }
        },
        disable: function () {
            if (this._enabled) {
                for (var e = g.Draggable.START.length - 1; e >= 0; e--) {
                    g.DomEvent.off(this._dragStartTarget, g.Draggable.START[e], this._onDown, this)
                }
                this._enabled = !1, this._moved = !1
            }
        },
        _onDown: function (e) {
            if (!(!g.Browser.touch && e.shiftKey || 1 !== e.which && 1 !== e.button && !e.touches || (g.DomEvent.preventDefault(e), g.DomEvent.stopPropagation(e), g.Draggable._disabled))) {
                if (this._simulateClick = !0, e.touches && e.touches.length > 1) {
                    return this._simulateClick = !1, clearTimeout(this._longPressTimeout), a
                }
                var i = e.touches && 1 === e.touches.length ? e.touches[0] : e, h = i.target;
                g.Browser.touch && "a" === h.tagName.toLowerCase() && g.DomUtil.addClass(h, "leaflet-active"), this._moved = !1, this._moving || (this._startPoint = new g.Point(i.clientX, i.clientY), this._startPos = this._newPos = g.DomUtil.getPosition(this._element), e.touches && 1 === e.touches.length && g.Browser.touch && this._longPress && (this._longPressTimeout = setTimeout(g.bind(function () {
                    var j = this._newPos && this._newPos.distanceTo(this._startPos) || 0;
                    g.Draggable.TAP_TOLERANCE > j && (this._simulateClick = !1, this._onUp(), this._simulateEvent("contextmenu", i))
                }, this), 1000)), g.DomEvent.on(d, g.Draggable.MOVE[e.type], this._onMove, this), g.DomEvent.on(d, g.Draggable.END[e.type], this._onUp, this))
            }
        },
        _onMove: function (j) {
            if (!(j.touches && j.touches.length > 1)) {
                var k = j.touches && 1 === j.touches.length ? j.touches[0] : j, h = new g.Point(k.clientX, k.clientY), l = h.subtract(this._startPoint);
                (l.x || l.y) && (g.DomEvent.preventDefault(j), this._moved || (this.fire("dragstart"), this._moved = !0, this._startPos = g.DomUtil.getPosition(this._element).subtract(l), g.Browser.touch || (g.DomUtil.disableTextSelection(), this._setMovingCursor())), this._newPos = this._startPos.add(l), this._moving = !0, g.Util.cancelAnimFrame(this._animRequest), this._animRequest = g.Util.requestAnimFrame(this._updatePosition, this, !0, this._dragStartTarget))
            }
        },
        _updatePosition: function () {
            this.fire("predrag"), g.DomUtil.setPosition(this._element, this._newPos), this.fire("drag")
        },
        _onUp: function (j) {
            var h;
            if (clearTimeout(this._longPressTimeout), this._simulateClick && j.changedTouches) {
                var m = j.changedTouches[0], k = m.target, e = this._newPos && this._newPos.distanceTo(this._startPos) || 0;
                "a" === k.tagName.toLowerCase() && g.DomUtil.removeClass(k, "leaflet-active"), g.Draggable.TAP_TOLERANCE > e && (h = m)
            }
            g.Browser.touch || (g.DomUtil.enableTextSelection(), this._restoreCursor());
            for (var l in g.Draggable.MOVE) {
                g.Draggable.MOVE.hasOwnProperty(l) && (g.DomEvent.off(d, g.Draggable.MOVE[l], this._onMove), g.DomEvent.off(d, g.Draggable.END[l], this._onUp))
            }
            this._moved && (g.Util.cancelAnimFrame(this._animRequest), this.fire("dragend")), this._moving = !1, h && (this._moved = !1, this._simulateEvent("click", h))
        },
        _setMovingCursor: function () {
            g.DomUtil.addClass(d.body, "leaflet-dragging")
        },
        _restoreCursor: function () {
            g.DomUtil.removeClass(d.body, "leaflet-dragging")
        },
        _simulateEvent: function (e, j) {
            var h = d.createEvent("MouseEvents");
            h.initMouseEvent(e, !0, !0, b, 1, j.screenX, j.screenY, j.clientX, j.clientY, !1, !1, !1, !1, 0, null), j.target.dispatchEvent(h)
        }
    }), g.Handler = g.Class.extend({
        initialize: function (e) {
            this._map = e
        }, enable: function () {
            this._enabled || (this._enabled = !0, this.addHooks())
        }, disable: function () {
            this._enabled && (this._enabled = !1, this.removeHooks())
        }, enabled: function () {
            return !!this._enabled
        }
    }), g.Map.mergeOptions({
        dragging: !0,
        inertia: !g.Browser.android23,
        inertiaDeceleration: 3400,
        inertiaMaxSpeed: 1 / 0,
        inertiaThreshold: g.Browser.touch ? 32 : 18,
        easeLinearity: 0.25,
        longPress: !0,
        worldCopyJump: !1
    }),g.Map.Drag = g.Handler.extend({
        addHooks: function () {
            if (!this._draggable) {
                var e = this._map;
                this._draggable = new g.Draggable(e._mapPane, e._container, e.options.longPress), this._draggable.on({
                    dragstart: this._onDragStart,
                    drag: this._onDrag,
                    dragend: this._onDragEnd
                }, this), e.options.worldCopyJump && (this._draggable.on("predrag", this._onPreDrag, this), e.on("viewreset", this._onViewReset, this))
            }
            this._draggable.enable()
        }, removeHooks: function () {
            this._draggable.disable()
        }, moved: function () {
            return this._draggable && this._draggable._moved
        }, _onDragStart: function () {
            var e = this._map;
            e._panAnim && e._panAnim.stop(), e.fire("movestart").fire("dragstart"), e.options.inertia && (this._positions = [], this._times = [])
        }, _onDrag: function () {
            if (this._map.options.inertia) {
                var h = this._lastTime = +new Date, i = this._lastPos = this._draggable._newPos;
                this._positions.push(i), this._times.push(h), h - this._times[0] > 200 && (this._positions.shift(), this._times.shift())
            }
            this._map.fire("move").fire("drag")
        }, _onViewReset: function () {
            var h = this._map.getSize()._divideBy(2), i = this._map.latLngToLayerPoint(new g.LatLng(0, 0));
            this._initialWorldOffset = i.subtract(h).x, this._worldWidth = this._map.project(new g.LatLng(0, 180)).x
        }, _onPreDrag: function () {
            var k = this._worldWidth, m = Math.round(k / 2), j = this._initialWorldOffset, q = this._draggable._newPos.x, p = (q - m + j) % k + m - j, l = (q + m + j) % k - m - j, h = Math.abs(p + j) < Math.abs(l + j) ? p : l;
            this._draggable._newPos.x = h
        }, _onDragEnd: function () {
            var A = this._map, q = A.options, n = +new Date - this._lastTime, k = !q.inertia || n > q.inertiaThreshold || !this._positions[0];
            if (k) {
                A.fire("moveend")
            } else {
                var B = this._lastPos.subtract(this._positions[0]), x = (this._lastTime + n - this._times[0]) / 1000, j = q.easeLinearity, p = B.multiplyBy(j / x), m = p.distanceTo(new g.Point(0, 0)), z = Math.min(q.inertiaMaxSpeed, m), w = p.multiplyBy(z / m), y = z / (q.inertiaDeceleration * j), v = w.multiplyBy(-y / 2).round();
                g.Util.requestAnimFrame(function () {
                    A.panBy(v, y, j)
                })
            }
            A.fire("dragend"), q.maxBounds && g.Util.requestAnimFrame(this._panInsideMaxBounds, A, !0, A._container)
        }, _panInsideMaxBounds: function () {
            this.panInsideBounds(this.options.maxBounds)
        }
    }),g.Map.addInitHook("addHandler", "dragging", g.Map.Drag),g.Map.mergeOptions({doubleClickZoom: !0}),g.Map.DoubleClickZoom = g.Handler.extend({
        addHooks: function () {
            this._map.on("dblclick", this._onDoubleClick)
        }, removeHooks: function () {
            this._map.off("dblclick", this._onDoubleClick)
        }, _onDoubleClick: function (e) {
            this.setView(e.latlng, this._zoom + 1)
        }
    }),g.Map.addInitHook("addHandler", "doubleClickZoom", g.Map.DoubleClickZoom),g.Map.mergeOptions({scrollWheelZoom: !0}),g.Map.ScrollWheelZoom = g.Handler.extend({
        addHooks: function () {
            g.DomEvent.on(this._map._container, "mousewheel", this._onWheelScroll, this), this._delta = 0
        }, removeHooks: function () {
            g.DomEvent.off(this._map._container, "mousewheel", this._onWheelScroll)
        }, _onWheelScroll: function (j) {
            var k = g.DomEvent.getWheelDelta(j);
            this._delta += k, this._lastMousePos = this._map.mouseEventToContainerPoint(j), this._startTime || (this._startTime = +new Date);
            var h = Math.max(40 - (+new Date - this._startTime), 0);
            clearTimeout(this._timer), this._timer = setTimeout(g.bind(this._performZoom, this), h), g.DomEvent.preventDefault(j), g.DomEvent.stopPropagation(j)
        }, _performZoom: function () {
            var j = this._map, k = this._delta, h = j.getZoom();
            if (k = k > 0 ? Math.ceil(k) : Math.round(k), k = Math.max(Math.min(k, 4), -4), k = j._limitZoom(h + k) - h, this._delta = 0, this._startTime = null, k) {
                var m = h + k, l = this._getCenterForScrollWheelZoom(m);
                j.setView(l, m)
            }
        }, _getCenterForScrollWheelZoom: function (j) {
            var l = this._map, h = l.getZoomScale(j), p = l.getSize()._divideBy(2), m = this._lastMousePos._subtract(p)._multiplyBy(1 - 1 / h), k = l._getTopLeftPoint()._add(p)._add(m);
            return l.unproject(k)
        }
    }),g.Map.addInitHook("addHandler", "scrollWheelZoom", g.Map.ScrollWheelZoom),g.extend(g.DomEvent, {
        _touchstart: g.Browser.msTouch ? "MSPointerDown" : "touchstart",
        _touchend: g.Browser.msTouch ? "MSPointerUp" : "touchend",
        addDoubleTapListener: function (C, v, k) {
            function D(l) {
                var m;
                if (g.Browser.msTouch ? (j.push(l.pointerId), m = j.length) : m = l.touches.length, !(m > 1)) {
                    var h = Date.now(), p = h - (e || h);
                    w = l.touches ? l.touches[0] : l, q = p > 0 && B >= p, e = h
                }
            }

            function z(i) {
                if (g.Browser.msTouch) {
                    var m = j.indexOf(i.pointerId);
                    if (-1 === m) {
                        return
                    }
                    j.splice(m, 1)
                }
                if (q) {
                    if (g.Browser.msTouch) {
                        var p, l = {};
                        for (var h in w) {
                            p = w[h], l[h] = "function" == typeof p ? p.bind(w) : p
                        }
                        w = l
                    }
                    w.type = "dblclick", v(w), e = null
                }
            }

            var e, w, q = !1, B = 250, y = "_leaflet_", A = this._touchstart, x = this._touchend, j = [];
            C[y + A + k] = D, C[y + x + k] = z;
            var n = g.Browser.msTouch ? d.documentElement : C;
            return C.addEventListener(A, D, !1), n.addEventListener(x, z, !1), g.Browser.msTouch && n.addEventListener("MSPointerCancel", z, !1), this
        },
        removeDoubleTapListener: function (h, e) {
            var j = "_leaflet_";
            return h.removeEventListener(this._touchstart, h[j + this._touchstart + e], !1), (g.Browser.msTouch ? d.documentElement : h).removeEventListener(this._touchend, h[j + this._touchend + e], !1), g.Browser.msTouch && d.documentElement.removeEventListener("MSPointerCancel", h[j + this._touchend + e], !1), this
        }
    }),g.extend(g.DomEvent, {
        _msTouches: [], _msDocumentListener: !1, addMsTouchListener: function (j, k, h, l) {
            switch (k) {
                case"touchstart":
                    return this.addMsTouchListenerStart(j, k, h, l);
                case"touchend":
                    return this.addMsTouchListenerEnd(j, k, h, l);
                case"touchmove":
                    return this.addMsTouchListenerMove(j, k, h, l);
                default:
                    throw"Unknown touch event type"
            }
        }, addMsTouchListenerStart: function (k, j, u, q) {
            var m = "_leaflet_", e = this._msTouches, p = function (n) {
                for (var o = !1, h = 0; e.length > h; h++) {
                    if (e[h].pointerId === n.pointerId) {
                        o = !0;
                        break
                    }
                }
                o || e.push(n), n.touches = e.slice(), n.changedTouches = [n], u(n)
            };
            if (k[m + "touchstart" + q] = p, k.addEventListener("MSPointerDown", p, !1), !this._msDocumentListener) {
                var l = function (h) {
                    for (var i = 0; e.length > i; i++) {
                        if (e[i].pointerId === h.pointerId) {
                            e.splice(i, 1);
                            break
                        }
                    }
                };
                d.documentElement.addEventListener("MSPointerUp", l, !1), d.documentElement.addEventListener("MSPointerCancel", l, !1), this._msDocumentListener = !0
            }
            return this
        }, addMsTouchListenerMove: function (k, m, j, q) {
            function p(i) {
                if (i.pointerType !== i.MSPOINTER_TYPE_MOUSE || 0 !== i.buttons) {
                    for (var n = 0; h.length > n; n++) {
                        if (h[n].pointerId === i.pointerId) {
                            h[n] = i;
                            break
                        }
                    }
                    i.touches = h.slice(), i.changedTouches = [i], j(i)
                }
            }

            var l = "_leaflet_", h = this._msTouches;
            return k[l + "touchmove" + q] = p, k.addEventListener("MSPointerMove", p, !1), this
        }, addMsTouchListenerEnd: function (k, m, j, q) {
            var p = "_leaflet_", l = this._msTouches, h = function (i) {
                for (var n = 0; l.length > n; n++) {
                    if (l[n].pointerId === i.pointerId) {
                        l.splice(n, 1);
                        break
                    }
                }
                i.touches = l.slice(), i.changedTouches = [i], j(i)
            };
            return k[p + "touchend" + q] = h, k.addEventListener("MSPointerUp", h, !1), k.addEventListener("MSPointerCancel", h, !1), this
        }, removeMsTouchListener: function (j, k, h) {
            var m = "_leaflet_", l = j[m + k + h];
            switch (k) {
                case"touchstart":
                    j.removeEventListener("MSPointerDown", l, !1);
                    break;
                case"touchmove":
                    j.removeEventListener("MSPointerMove", l, !1);
                    break;
                case"touchend":
                    j.removeEventListener("MSPointerUp", l, !1), j.removeEventListener("MSPointerCancel", l, !1)
            }
            return this
        }
    }),g.Map.mergeOptions({touchZoom: g.Browser.touch && !g.Browser.android23}),g.Map.TouchZoom = g.Handler.extend({
        addHooks: function () {
            g.DomEvent.on(this._map._container, "touchstart", this._onTouchStart, this)
        }, removeHooks: function () {
            g.DomEvent.off(this._map._container, "touchstart", this._onTouchStart, this)
        }, _onTouchStart: function (j) {
            var h = this._map;
            if (j.touches && 2 === j.touches.length && !h._animatingZoom && !this._zooming) {
                var l = h.mouseEventToLayerPoint(j.touches[0]), k = h.mouseEventToLayerPoint(j.touches[1]), e = h._getCenterLayerPoint();
                this._startCenter = l.add(k)._divideBy(2), this._startDist = l.distanceTo(k), this._moved = !1, this._zooming = !0, this._centerOffset = e.subtract(this._startCenter), h._panAnim && h._panAnim.stop(), g.DomEvent.on(d, "touchmove", this._onTouchMove, this).on(d, "touchend", this._onTouchEnd, this), g.DomEvent.preventDefault(j)
            }
        }, _onTouchMove: function (j) {
            if (j.touches && 2 === j.touches.length) {
                var k = this._map, h = k.mouseEventToLayerPoint(j.touches[0]), l = k.mouseEventToLayerPoint(j.touches[1]);
                this._scale = h.distanceTo(l) / this._startDist, this._delta = h._add(l)._divideBy(2)._subtract(this._startCenter), 1 !== this._scale && (this._moved || (g.DomUtil.addClass(k._mapPane, "leaflet-zoom-anim leaflet-touching"), k.fire("movestart").fire("zoomstart")._prepareTileBg(), this._moved = !0), g.Util.cancelAnimFrame(this._animRequest), this._animRequest = g.Util.requestAnimFrame(this._updateOnMove, this, !0, this._map._container), g.DomEvent.preventDefault(j))
            }
        }, _updateOnMove: function () {
            var j = this._map, k = this._getScaleOrigin(), h = j.layerPointToLatLng(k);
            j.fire("zoomanim", {
                center: h,
                zoom: j.getScaleZoom(this._scale)
            }), j._tileBg.style[g.DomUtil.TRANSFORM] = g.DomUtil.getTranslateString(this._delta) + " " + g.DomUtil.getScaleString(this._scale, this._startCenter)
        }, _onTouchEnd: function () {
            if (this._moved && this._zooming) {
                var k = this._map;
                this._zooming = !1, g.DomUtil.removeClass(k._mapPane, "leaflet-touching"), g.DomEvent.off(d, "touchmove", this._onTouchMove).off(d, "touchend", this._onTouchEnd);
                var j = this._getScaleOrigin(), p = k.layerPointToLatLng(j), m = k.getZoom(), e = k.getScaleZoom(this._scale) - m, n = e > 0 ? Math.ceil(e) : Math.floor(e), l = k._limitZoom(m + n);
                k.fire("zoomanim", {center: p, zoom: l}), k._runAnimation(p, l, k.getZoomScale(l) / this._scale, j, !0)
            }
        }, _getScaleOrigin: function () {
            var e = this._centerOffset.subtract(this._delta).divideBy(this._scale);
            return this._startCenter.add(e)
        }
    }),g.Map.addInitHook("addHandler", "touchZoom", g.Map.TouchZoom),g.Map.mergeOptions({boxZoom: !0}),g.Map.BoxZoom = g.Handler.extend({
        initialize: function (e) {
            this._map = e, this._container = e._container, this._pane = e._panes.overlayPane
        }, addHooks: function () {
            g.DomEvent.on(this._container, "mousedown", this._onMouseDown, this)
        }, removeHooks: function () {
            g.DomEvent.off(this._container, "mousedown", this._onMouseDown)
        }, _onMouseDown: function (e) {
            return !e.shiftKey || 1 !== e.which && 1 !== e.button ? !1 : (g.DomUtil.disableTextSelection(), this._startLayerPoint = this._map.mouseEventToLayerPoint(e), this._box = g.DomUtil.create("div", "leaflet-zoom-box", this._pane), g.DomUtil.setPosition(this._box, this._startLayerPoint), this._container.style.cursor = "crosshair", g.DomEvent.on(d, "mousemove", this._onMouseMove, this).on(d, "mouseup", this._onMouseUp, this).preventDefault(e), this._map.fire("boxzoomstart"), a)
        }, _onMouseMove: function (k) {
            var m = this._startLayerPoint, j = this._box, n = this._map.mouseEventToLayerPoint(k), l = n.subtract(m), h = new g.Point(Math.min(n.x, m.x), Math.min(n.y, m.y));
            g.DomUtil.setPosition(j, h), j.style.width = Math.max(0, Math.abs(l.x) - 4) + "px", j.style.height = Math.max(0, Math.abs(l.y) - 4) + "px"
        }, _onMouseUp: function (h) {
            this._pane.removeChild(this._box), this._container.style.cursor = "", g.DomUtil.enableTextSelection(), g.DomEvent.off(d, "mousemove", this._onMouseMove).off(d, "mouseup", this._onMouseUp);
            var e = this._map, k = e.mouseEventToLayerPoint(h);
            if (!this._startLayerPoint.equals(k)) {
                var j = new g.LatLngBounds(e.layerPointToLatLng(this._startLayerPoint), e.layerPointToLatLng(k));
                e.fitBounds(j), e.fire("boxzoomend", {boxZoomBounds: j})
            }
        }
    }),g.Map.addInitHook("addHandler", "boxZoom", g.Map.BoxZoom),g.Map.mergeOptions({
        keyboard: !0,
        keyboardPanOffset: 80,
        keyboardZoomOffset: 1
    }),g.Map.Keyboard = g.Handler.extend({
        keyCodes: {
            left: [37],
            right: [39],
            down: [40],
            up: [38],
            zoomIn: [187, 107, 61],
            zoomOut: [189, 109, 173]
        }, initialize: function (e) {
            this._map = e, this._setPanOffset(e.options.keyboardPanOffset), this._setZoomOffset(e.options.keyboardZoomOffset)
        }, addHooks: function () {
            var e = this._map._container;
            -1 === e.tabIndex && (e.tabIndex = "0"), g.DomEvent.on(e, "focus", this._onFocus, this).on(e, "blur", this._onBlur, this).on(e, "mousedown", this._onMouseDown, this), this._map.on("focus", this._addHooks, this).on("blur", this._removeHooks, this)
        }, removeHooks: function () {
            this._removeHooks();
            var e = this._map._container;
            g.DomEvent.off(e, "focus", this._onFocus, this).off(e, "blur", this._onBlur, this).off(e, "mousedown", this._onMouseDown, this), this._map.off("focus", this._addHooks, this).off("blur", this._removeHooks, this)
        }, _onMouseDown: function () {
            this._focused || this._map._container.focus()
        }, _onFocus: function () {
            this._focused = !0, this._map.fire("focus")
        }, _onBlur: function () {
            this._focused = !1, this._map.fire("blur")
        }, _setPanOffset: function (j) {
            var k, h, m = this._panKeys = {}, l = this.keyCodes;
            for (k = 0, h = l.left.length; h > k; k++) {
                m[l.left[k]] = [-1 * j, 0]
            }
            for (k = 0, h = l.right.length; h > k; k++) {
                m[l.right[k]] = [j, 0]
            }
            for (k = 0, h = l.down.length; h > k; k++) {
                m[l.down[k]] = [0, j]
            }
            for (k = 0, h = l.up.length; h > k; k++) {
                m[l.up[k]] = [0, -1 * j]
            }
        }, _setZoomOffset: function (j) {
            var k, h, m = this._zoomKeys = {}, l = this.keyCodes;
            for (k = 0, h = l.zoomIn.length; h > k; k++) {
                m[l.zoomIn[k]] = j
            }
            for (k = 0, h = l.zoomOut.length; h > k; k++) {
                m[l.zoomOut[k]] = -j
            }
        }, _addHooks: function () {
            g.DomEvent.on(d, "keydown", this._onKeyDown, this)
        }, _removeHooks: function () {
            g.DomEvent.off(d, "keydown", this._onKeyDown, this)
        }, _onKeyDown: function (j) {
            var k = j.keyCode, h = this._map;
            if (this._panKeys.hasOwnProperty(k)) {
                h.panBy(this._panKeys[k]), h.options.maxBounds && h.panInsideBounds(h.options.maxBounds)
            } else {
                if (!this._zoomKeys.hasOwnProperty(k)) {
                    return
                }
                h.setZoom(h.getZoom() + this._zoomKeys[k])
            }
            g.DomEvent.stop(j)
        }
    }),g.Map.addInitHook("addHandler", "keyboard", g.Map.Keyboard),g.Handler.MarkerDrag = g.Handler.extend({
        initialize: function (e) {
            this._marker = e
        }, addHooks: function () {
            var e = this._marker._icon;
            this._draggable || (this._draggable = new g.Draggable(e, e).on("dragstart", this._onDragStart, this).on("drag", this._onDrag, this).on("dragend", this._onDragEnd, this)), this._draggable.enable()
        }, removeHooks: function () {
            this._draggable.disable()
        }, moved: function () {
            return this._draggable && this._draggable._moved
        }, _onDragStart: function () {
            this._marker.closePopup().fire("movestart").fire("dragstart")
        }, _onDrag: function () {
            var j = this._marker, k = j._shadow, h = g.DomUtil.getPosition(j._icon), l = j._map.layerPointToLatLng(h);
            k && g.DomUtil.setPosition(k, h), j._latlng = l, j.fire("move", {latlng: l}).fire("drag")
        }, _onDragEnd: function () {
            this._marker.fire("moveend").fire("dragend")
        }
    }),g.Handler.PolyEdit = g.Handler.extend({
        options: {
            icon: new g.DivIcon({
                iconSize: new g.Point(8, 8),
                className: "leaflet-div-icon leaflet-editing-icon"
            })
        }, initialize: function (h, i) {
            this._poly = h, g.setOptions(this, i)
        }, addHooks: function () {
            this._poly._map && (this._markerGroup || this._initMarkers(), this._poly._map.addLayer(this._markerGroup))
        }, removeHooks: function () {
            this._poly._map && (this._poly._map.removeLayer(this._markerGroup), delete this._markerGroup, delete this._markers)
        }, updateMarkers: function () {
            this._markerGroup.clearLayers(), this._initMarkers()
        }, _initMarkers: function () {
            this._markerGroup || (this._markerGroup = new g.LayerGroup), this._markers = [];
            var k, n, j, p, l = this._poly._latlngs;
            for (k = 0, j = l.length; j > k; k++) {
                p = this._createMarker(l[k], k), p.on("click", this._onMarkerClick, this), this._markers.push(p)
            }
            var h, m;
            for (k = 0, n = j - 1; j > k; n = k++) {
                (0 !== k || g.Polygon && this._poly instanceof g.Polygon) && (h = this._markers[n], m = this._markers[k], this._createMiddleMarker(h, m), this._updatePrevNext(h, m))
            }
        }, _createMarker: function (j, k) {
            var h = new g.Marker(j, {draggable: !0, icon: this.options.icon});
            return h._origLatLng = j, h._index = k, h.on("drag", this._onMarkerDrag, this), h.on("dragend", this._fireEdit, this), this._markerGroup.addLayer(h), h
        }, _fireEdit: function () {
            this._poly.fire("edit")
        }, _onMarkerDrag: function (h) {
            var i = h.target;
            g.extend(i._origLatLng, i._latlng), i._middleLeft && i._middleLeft.setLatLng(this._getMiddleLatLng(i._prev, i)), i._middleRight && i._middleRight.setLatLng(this._getMiddleLatLng(i, i._next)), this._poly.redraw()
        }, _onMarkerClick: function (j) {
            if (!(3 > this._poly._latlngs.length)) {
                var k = j.target, h = k._index;
                this._markerGroup.removeLayer(k), this._markers.splice(h, 1), this._poly.spliceLatLngs(h, 1), this._updateIndexes(h, -1), this._updatePrevNext(k._prev, k._next), k._middleLeft && this._markerGroup.removeLayer(k._middleLeft), k._middleRight && this._markerGroup.removeLayer(k._middleRight), k._prev && k._next ? this._createMiddleMarker(k._prev, k._next) : k._prev ? k._next || (k._prev._middleRight = null) : k._next._middleLeft = null, this._poly.fire("edit")
            }
        }, _updateIndexes: function (h, i) {
            this._markerGroup.eachLayer(function (e) {
                e._index > h && (e._index += i)
            })
        }, _createMiddleMarker: function (k, m) {
            var j, q, p, l = this._getMiddleLatLng(k, m), h = this._createMarker(l);
            h.setOpacity(0.6), k._middleRight = m._middleLeft = h, q = function () {
                var e = m._index;
                h._index = e, h.off("click", j).on("click", this._onMarkerClick, this), l.lat = h.getLatLng().lat, l.lng = h.getLatLng().lng, this._poly.spliceLatLngs(e, 0, l), this._markers.splice(e, 0, h), h.setOpacity(1), this._updateIndexes(e, 1), m._index++, this._updatePrevNext(k, h), this._updatePrevNext(h, m)
            }, p = function () {
                h.off("dragstart", q, this), h.off("dragend", p, this), this._createMiddleMarker(k, h), this._createMiddleMarker(h, m)
            }, j = function () {
                q.call(this), p.call(this), this._poly.fire("edit")
            }, h.on("click", j, this).on("dragstart", q, this).on("dragend", p, this), this._markerGroup.addLayer(h)
        }, _updatePrevNext: function (h, i) {
            h && (h._next = i), i && (i._prev = h)
        }, _getMiddleLatLng: function (j, k) {
            var h = this._poly._map, m = h.latLngToLayerPoint(j.getLatLng()), l = h.latLngToLayerPoint(k.getLatLng());
            return h.layerPointToLatLng(m._add(l)._divideBy(2))
        }
    }),g.Polyline.addInitHook(function () {
        g.Handler.PolyEdit && (this.editing = new g.Handler.PolyEdit(this), this.options.editable && this.editing.enable()), this.on("add", function () {
            this.editing && this.editing.enabled() && this.editing.addHooks()
        }), this.on("remove", function () {
            this.editing && this.editing.enabled() && this.editing.removeHooks()
        })
    }),g.Control = g.Class.extend({
        options: {position: "topright"}, initialize: function (e) {
            g.setOptions(this, e)
        }, getPosition: function () {
            return this.options.position
        }, setPosition: function (h) {
            var i = this._map;
            return i && i.removeControl(this), this.options.position = h, i && i.addControl(this), this
        }, addTo: function (j) {
            this._map = j;
            var k = this._container = this.onAdd(j), h = this.getPosition(), l = j._controlCorners[h];
            return g.DomUtil.addClass(k, "leaflet-control"), -1 !== h.indexOf("bottom") ? l.insertBefore(k, l.firstChild) : l.appendChild(k), this
        }, removeFrom: function (j) {
            var k = this.getPosition(), h = j._controlCorners[k];
            return h.removeChild(this._container), this._map = null, this.onRemove && this.onRemove(j), this
        }
    }),g.control = function (e) {
        return new g.Control(e)
    },g.Map.include({
        addControl: function (e) {
            return e.addTo(this), this
        }, removeControl: function (e) {
            return e.removeFrom(this), this
        }, _initControlPos: function () {
            function j(i, m) {
                var e = h + i + " " + h + m;
                k[i + m] = g.DomUtil.create("div", e, l)
            }

            var k = this._controlCorners = {}, h = "leaflet-", l = this._controlContainer = g.DomUtil.create("div", h + "control-container", this._container);
            j("top", "left"), j("top", "right"), j("bottom", "left"), j("bottom", "right")
        }
    }),g.Control.Zoom = g.Control.extend({
        options: {position: "topleft"}, onAdd: function (j) {
            var l = "leaflet-control-zoom", h = "leaflet-bar", m = h + "-part", k = g.DomUtil.create("div", l + " " + h);
            return this._map = j, this._zoomInButton = this._createButton("+", "Zoom in", l + "-in " + m + " " + m + "-top", k, this._zoomIn, this), this._zoomOutButton = this._createButton("-", "Zoom out", l + "-out " + m + " " + m + "-bottom", k, this._zoomOut, this), j.on("zoomend", this._updateDisabled, this), k
        }, onRemove: function (e) {
            e.off("zoomend", this._updateDisabled, this)
        }, _zoomIn: function (e) {
            this._map.zoomIn(e.shiftKey ? 3 : 1)
        }, _zoomOut: function (e) {
            this._map.zoomOut(e.shiftKey ? 3 : 1)
        }, _createButton: function (l, q, k, u, n, j) {
            var p = g.DomUtil.create("a", k, u);
            p.innerHTML = l, p.href = "#", p.title = q;
            var m = g.DomEvent.stopPropagation;
            return g.DomEvent.on(p, "click", m).on(p, "mousedown", m).on(p, "dblclick", m).on(p, "click", g.DomEvent.preventDefault).on(p, "click", n, j), p
        }, _updateDisabled: function () {
            var h = this._map, i = "leaflet-control-zoom-disabled";
            g.DomUtil.removeClass(this._zoomInButton, i), g.DomUtil.removeClass(this._zoomOutButton, i), h._zoom === h.getMinZoom() && g.DomUtil.addClass(this._zoomOutButton, i), h._zoom === h.getMaxZoom() && g.DomUtil.addClass(this._zoomInButton, i)
        }
    }),g.Map.mergeOptions({zoomControl: !0}),g.Map.addInitHook(function () {
        this.options.zoomControl && (this.zoomControl = new g.Control.Zoom, this.addControl(this.zoomControl))
    }),g.control.zoom = function (e) {
        return new g.Control.Zoom(e)
    },g.Control.Attribution = g.Control.extend({
        options: {
            position: "bottomright",
            prefix: 'Powered by <a href="http://leafletjs.com">Leaflet</a>'
        }, initialize: function (e) {
            g.setOptions(this, e), this._attributions = {}
        }, onAdd: function (e) {
            return this._container = g.DomUtil.create("div", "leaflet-control-attribution"), g.DomEvent.disableClickPropagation(this._container), e.on("layeradd", this._onLayerAdd, this).on("layerremove", this._onLayerRemove, this), this._update(), this._container
        }, onRemove: function (e) {
            e.off("layeradd", this._onLayerAdd).off("layerremove", this._onLayerRemove)
        }, setPrefix: function (e) {
            return this.options.prefix = e, this._update(), this
        }, addAttribution: function (e) {
            return e ? (this._attributions[e] || (this._attributions[e] = 0), this._attributions[e]++, this._update(), this) : a
        }, removeAttribution: function (e) {
            return e ? (this._attributions[e]--, this._update(), this) : a
        }, _update: function () {
            if (this._map) {
                var j = [];
                for (var k in this._attributions) {
                    this._attributions.hasOwnProperty(k) && this._attributions[k] && j.push(k)
                }
                var h = [];
                this.options.prefix && h.push(this.options.prefix), j.length && h.push(j.join(", ")), this._container.innerHTML = h.join(" &#8212; ")
            }
        }, _onLayerAdd: function (e) {
            e.layer.getAttribution && this.addAttribution(e.layer.getAttribution())
        }, _onLayerRemove: function (e) {
            e.layer.getAttribution && this.removeAttribution(e.layer.getAttribution())
        }
    }),g.Map.mergeOptions({attributionControl: !0}),g.Map.addInitHook(function () {
        this.options.attributionControl && (this.attributionControl = (new g.Control.Attribution).addTo(this))
    }),g.control.attribution = function (e) {
        return new g.Control.Attribution(e)
    },g.Control.Scale = g.Control.extend({
        options: {
            position: "bottomleft",
            maxWidth: 100,
            metric: !0,
            imperial: !0,
            updateWhenIdle: !1
        }, onAdd: function (j) {
            this._map = j;
            var k = "leaflet-control-scale", h = g.DomUtil.create("div", k), l = this.options;
            return this._addScales(l, k, h), j.on(l.updateWhenIdle ? "moveend" : "move", this._update, this), j.whenReady(this._update, this), h
        }, onRemove: function (e) {
            e.off(this.options.updateWhenIdle ? "moveend" : "move", this._update, this)
        }, _addScales: function (j, k, h) {
            j.metric && (this._mScale = g.DomUtil.create("div", k + "-line", h)), j.imperial && (this._iScale = g.DomUtil.create("div", k + "-line", h))
        }, _update: function () {
            var k = this._map.getBounds(), m = k.getCenter().lat, j = 6378137 * Math.PI * Math.cos(m * Math.PI / 180), q = j * (k.getNorthEast().lng - k.getSouthWest().lng) / 180, p = this._map.getSize(), l = this.options, h = 0;
            p.x > 0 && (h = q * (l.maxWidth / p.x)), this._updateScales(l, h)
        }, _updateScales: function (h, i) {
            h.metric && i && this._updateMetric(i), h.imperial && i && this._updateImperial(i)
        }, _updateMetric: function (h) {
            var i = this._getRoundNum(h);
            this._mScale.style.width = this._getScaleWidth(i / h) + "px", this._mScale.innerHTML = 1000 > i ? i + " m" : i / 1000 + " km"
        }, _updateImperial: function (j) {
            var l, h, p, m = 3.2808399 * j, k = this._iScale;
            m > 5280 ? (l = m / 5280, h = this._getRoundNum(l), k.style.width = this._getScaleWidth(h / l) + "px", k.innerHTML = h + " mi") : (p = this._getRoundNum(m), k.style.width = this._getScaleWidth(p / m) + "px", k.innerHTML = p + " ft")
        }, _getScaleWidth: function (e) {
            return Math.round(this.options.maxWidth * e) - 10
        }, _getRoundNum: function (j) {
            var k = Math.pow(10, (Math.floor(j) + "").length - 1), h = j / k;
            return h = h >= 10 ? 10 : h >= 5 ? 5 : h >= 3 ? 3 : h >= 2 ? 2 : 1, k * h
        }
    }),g.control.scale = function (e) {
        return new g.Control.Scale(e)
    },g.Control.Layers = g.Control.extend({
        options: {collapsed: !0, position: "topright", autoZIndex: !0},
        initialize: function (j, k, h) {
            g.setOptions(this, h), this._layers = {}, this._lastZIndex = 0, this._handlingClick = !1;
            for (var l in j) {
                j.hasOwnProperty(l) && this._addLayer(j[l], l)
            }
            for (l in k) {
                k.hasOwnProperty(l) && this._addLayer(k[l], l, !0)
            }
        },
        onAdd: function (e) {
            return this._initLayout(), this._update(), e.on("layeradd", this._onLayerChange, this).on("layerremove", this._onLayerChange, this), this._container
        },
        onRemove: function (e) {
            e.off("layeradd", this._onLayerChange).off("layerremove", this._onLayerChange)
        },
        addBaseLayer: function (h, i) {
            return this._addLayer(h, i), this._update(), this
        },
        addOverlay: function (h, i) {
            return this._addLayer(h, i, !0), this._update(), this
        },
        removeLayer: function (h) {
            var i = g.stamp(h);
            return delete this._layers[i], this._update(), this
        },
        _initLayout: function () {
            var j = "leaflet-control-layers", k = this._container = g.DomUtil.create("div", j);
            g.Browser.touch ? g.DomEvent.on(k, "click", g.DomEvent.stopPropagation) : (g.DomEvent.disableClickPropagation(k), g.DomEvent.on(k, "mousewheel", g.DomEvent.stopPropagation));
            var h = this._form = g.DomUtil.create("form", j + "-list");
            if (this.options.collapsed) {
                g.DomEvent.on(k, "mouseover", this._expand, this).on(k, "mouseout", this._collapse, this);
                var l = this._layersLink = g.DomUtil.create("a", j + "-toggle", k);
                l.href = "#", l.title = "Layers", g.Browser.touch ? g.DomEvent.on(l, "click", g.DomEvent.stopPropagation).on(l, "click", g.DomEvent.preventDefault).on(l, "click", this._expand, this) : g.DomEvent.on(l, "focus", this._expand, this), this._map.on("movestart", this._collapse, this)
            } else {
                this._expand()
            }
            this._baseLayersList = g.DomUtil.create("div", j + "-base", h), this._separator = g.DomUtil.create("div", j + "-separator", h), this._overlaysList = g.DomUtil.create("div", j + "-overlays", h), k.appendChild(h)
        },
        _addLayer: function (j, k, h) {
            var l = g.stamp(j);
            this._layers[l] = {
                layer: j,
                name: k,
                overlay: h
            }, this.options.autoZIndex && j.setZIndex && (this._lastZIndex++, j.setZIndex(this._lastZIndex))
        },
        _update: function () {
            if (this._container) {
                this._baseLayersList.innerHTML = "", this._overlaysList.innerHTML = "";
                var j = !1, k = !1;
                for (var h in this._layers) {
                    if (this._layers.hasOwnProperty(h)) {
                        var l = this._layers[h];
                        this._addItem(l), k = k || l.overlay, j = j || !l.overlay
                    }
                }
                this._separator.style.display = k && j ? "" : "none"
            }
        },
        _onLayerChange: function (h) {
            var i = g.stamp(h.layer);
            this._layers[i] && !this._handlingClick && this._update()
        },
        _createRadioElement: function (h, e) {
            var k = '<input type="radio" class="leaflet-control-layers-selector" name="' + h + '"';
            e && (k += ' checked="checked"'), k += "/>";
            var j = d.createElement("div");
            return j.innerHTML = k, j.firstChild
        },
        _addItem: function (j) {
            var h, m = d.createElement("label"), k = this._map.hasLayer(j.layer);
            j.overlay ? (h = d.createElement("input"), h.type = "checkbox", h.className = "leaflet-control-layers-selector", h.defaultChecked = k) : h = this._createRadioElement("leaflet-base-layers", k), h.layerId = g.stamp(j.layer), g.DomEvent.on(h, "click", this._onInputClick, this);
            var e = d.createElement("span");
            e.innerHTML = " " + j.name, m.appendChild(h), m.appendChild(e);
            var l = j.overlay ? this._overlaysList : this._baseLayersList;
            return l.appendChild(m), m
        },
        _onInputClick: function () {
            var j, l, h, p, m = this._form.getElementsByTagName("input"), k = m.length;
            for (this._handlingClick = !0, j = 0; k > j; j++) {
                l = m[j], h = this._layers[l.layerId], l.checked && !this._map.hasLayer(h.layer) ? (this._map.addLayer(h.layer), h.overlay || (p = h.layer)) : !l.checked && this._map.hasLayer(h.layer) && this._map.removeLayer(h.layer)
            }
            p && (this._map.setZoom(this._map.getZoom()), this._map.fire("baselayerchange", {layer: p})), this._handlingClick = !1
        },
        _expand: function () {
            g.DomUtil.addClass(this._container, "leaflet-control-layers-expanded")
        },
        _collapse: function () {
            this._container.className = this._container.className.replace(" leaflet-control-layers-expanded", "")
        }
    }),g.control.layers = function (j, k, h) {
        return new g.Control.Layers(j, k, h)
    },g.PosAnimation = g.Class.extend({
        includes: g.Mixin.Events, run: function (j, k, h, l) {
            this.stop(), this._el = j, this._inProgress = !0, this.fire("start"), j.style[g.DomUtil.TRANSITION] = "all " + (h || 0.25) + "s cubic-bezier(0,0," + (l || 0.5) + ",1)", g.DomEvent.on(j, g.DomUtil.TRANSITION_END, this._onTransitionEnd, this), g.DomUtil.setPosition(j, k), g.Util.falseFn(j.offsetWidth), this._stepTimer = setInterval(g.bind(this.fire, this, "step"), 50)
        }, stop: function () {
            this._inProgress && (g.DomUtil.setPosition(this._el, this._getPos()), this._onTransitionEnd(), g.Util.falseFn(this._el.offsetWidth))
        }, _transformRe: /(-?[\d\.]+), (-?[\d\.]+)\)/, _getPos: function () {
            var l, j, m, k = this._el, h = b.getComputedStyle(k);
            return g.Browser.any3d ? (m = h[g.DomUtil.TRANSFORM].match(this._transformRe), l = parseFloat(m[1]), j = parseFloat(m[2])) : (l = parseFloat(h.left), j = parseFloat(h.top)), new g.Point(l, j, !0)
        }, _onTransitionEnd: function () {
            g.DomEvent.off(this._el, g.DomUtil.TRANSITION_END, this._onTransitionEnd, this), this._inProgress && (this._inProgress = !1, this._el.style[g.DomUtil.TRANSITION] = "", clearInterval(this._stepTimer), this.fire("step").fire("end"))
        }
    }),g.Map.include({
        setView: function (j, k, h) {
            k = this._limitZoom(k);
            var m = this._zoom !== k;
            if (this._loaded && !h && this._layers) {
                this._panAnim && this._panAnim.stop();
                var l = m ? this._zoomToIfClose && this._zoomToIfClose(j, k) : this._panByIfClose(j);
                if (l) {
                    return clearTimeout(this._sizeTimer), this
                }
            }
            return this._resetView(j, k), this
        }, panBy: function (j, k, h) {
            if (j = g.point(j), !j.x && !j.y) {
                return this
            }
            this._panAnim || (this._panAnim = new g.PosAnimation, this._panAnim.on({
                step: this._onPanTransitionStep,
                end: this._onPanTransitionEnd
            }, this)), this.fire("movestart"), g.DomUtil.addClass(this._mapPane, "leaflet-pan-anim");
            var l = g.DomUtil.getPosition(this._mapPane).subtract(j)._round();
            return this._panAnim.run(this._mapPane, l, k || 0.25, h), this
        }, _onPanTransitionStep: function () {
            this.fire("move")
        }, _onPanTransitionEnd: function () {
            g.DomUtil.removeClass(this._mapPane, "leaflet-pan-anim"), this.fire("moveend")
        }, _panByIfClose: function (h) {
            var i = this._getCenterOffset(h)._floor();
            return this._offsetIsWithinView(i) ? (this.panBy(i), !0) : !1
        }, _offsetIsWithinView: function (j, k) {
            var h = k || 1, l = this.getSize();
            return Math.abs(j.x) <= l.x * h && Math.abs(j.y) <= l.y * h
        }
    }),g.PosAnimation = g.DomUtil.TRANSITION ? g.PosAnimation : g.PosAnimation.extend({
        run: function (j, k, h, l) {
            this.stop(), this._el = j, this._inProgress = !0, this._duration = h || 0.25, this._easeOutPower = 1 / Math.max(l || 0.5, 0.2), this._startPos = g.DomUtil.getPosition(j), this._offset = k.subtract(this._startPos), this._startTime = +new Date, this.fire("start"), this._animate()
        }, stop: function () {
            this._inProgress && (this._step(), this._complete())
        }, _animate: function () {
            this._animId = g.Util.requestAnimFrame(this._animate, this), this._step()
        }, _step: function () {
            var h = +new Date - this._startTime, i = 1000 * this._duration;
            i > h ? this._runFrame(this._easeOut(h / i)) : (this._runFrame(1), this._complete())
        }, _runFrame: function (h) {
            var i = this._startPos.add(this._offset.multiplyBy(h));
            g.DomUtil.setPosition(this._el, i), this.fire("step")
        }, _complete: function () {
            g.Util.cancelAnimFrame(this._animId), this._inProgress = !1, this.fire("end")
        }, _easeOut: function (e) {
            return 1 - Math.pow(1 - e, this._easeOutPower)
        }
    }),g.Map.mergeOptions({zoomAnimation: g.DomUtil.TRANSITION && !g.Browser.android23 && !g.Browser.mobileOpera}),g.DomUtil.TRANSITION && g.Map.addInitHook(function () {
        g.DomEvent.on(this._mapPane, g.DomUtil.TRANSITION_END, this._catchTransitionEnd, this)
    }),g.Map.include(g.DomUtil.TRANSITION ? {
        _zoomToIfClose: function (j, l) {
            if (this._animatingZoom) {
                return !0
            }
            if (!this.options.zoomAnimation) {
                return !1
            }
            var h = this.getZoomScale(l), m = this._getCenterOffset(j)._divideBy(1 - 1 / h);
            if (!this._offsetIsWithinView(m, 1)) {
                return !1
            }
            g.DomUtil.addClass(this._mapPane, "leaflet-zoom-anim"), this.fire("movestart").fire("zoomstart"), this.fire("zoomanim", {
                center: j,
                zoom: l
            });
            var k = this._getCenterLayerPoint().add(m);
            return this._prepareTileBg(), this._runAnimation(j, l, h, k), !0
        }, _catchTransitionEnd: function () {
            this._animatingZoom && this._onZoomTransitionEnd()
        }, _runAnimation: function (v, q, n, k, w) {
            this._animateToCenter = v, this._animateToZoom = q, this._animatingZoom = !0, g.Draggable && (g.Draggable._disabled = !0);
            var u = g.DomUtil.TRANSFORM, j = this._tileBg;
            clearTimeout(this._clearTileBgTimer), g.Util.falseFn(j.offsetWidth);
            var p = g.DomUtil.getScaleString(n, k), m = j.style[u];
            j.style[u] = w ? m + " " + p : p + " " + m
        }, _prepareTileBg: function () {
            var h = this._tilePane, i = this._tileBg;
            if (i && this._getLoadedTilesPercentage(i) > 0.5 && 0.5 > this._getLoadedTilesPercentage(h)) {
                return h.style.visibility = "hidden", h.empty = !0, this._stopLoadingImages(h), a
            }
            i || (i = this._tileBg = this._createPane("leaflet-tile-pane", this._mapPane), i.style.zIndex = 1), i.style[g.DomUtil.TRANSFORM] = "", i.style.visibility = "hidden", i.empty = !0, h.empty = !1, this._tilePane = this._panes.tilePane = i;
            var j = this._tileBg = h;
            g.DomUtil.addClass(j, "leaflet-zoom-animated"), this._stopLoadingImages(j)
        }, _getLoadedTilesPercentage: function (j) {
            var k, h, m = j.getElementsByTagName("img"), l = 0;
            for (k = 0, h = m.length; h > k; k++) {
                m[k].complete && l++
            }
            return l / h
        }, _stopLoadingImages: function (j) {
            var l, h, m, k = Array.prototype.slice.call(j.getElementsByTagName("img"));
            for (l = 0, h = k.length; h > l; l++) {
                m = k[l], m.complete || (m.onload = g.Util.falseFn, m.onerror = g.Util.falseFn, m.src = g.Util.emptyImageUrl, m.parentNode.removeChild(m))
            }
        }, _onZoomTransitionEnd: function () {
            this._restoreTileFront(), g.DomUtil.removeClass(this._mapPane, "leaflet-zoom-anim"), g.Util.falseFn(this._tileBg.offsetWidth), this._animatingZoom = !1, this._resetView(this._animateToCenter, this._animateToZoom, !0, !0), g.Draggable && (g.Draggable._disabled = !1)
        }, _restoreTileFront: function () {
            this._tilePane.innerHTML = "", this._tilePane.style.visibility = "", this._tilePane.style.zIndex = 2, this._tileBg.style.zIndex = 1
        }, _clearTileBg: function () {
            this._animatingZoom || this.touchZoom._zooming || (this._tileBg.innerHTML = "")
        }
    } : {}),g.Map.include({
        _defaultLocateOptions: {
            watch: !1,
            setView: !1,
            maxZoom: 1 / 0,
            timeout: 10000,
            maximumAge: 0,
            enableHighAccuracy: !1
        }, locate: function (j) {
            if (j = this._locationOptions = g.extend(this._defaultLocateOptions, j), !navigator.geolocation) {
                return this._handleGeolocationError({code: 0, message: "Geolocation not supported."}), this
            }
            var k = g.bind(this._handleGeolocationResponse, this), h = g.bind(this._handleGeolocationError, this);
            return j.watch ? this._locationWatchId = navigator.geolocation.watchPosition(k, h, j) : navigator.geolocation.getCurrentPosition(k, h, j), this
        }, stopLocate: function () {
            return navigator.geolocation && navigator.geolocation.clearWatch(this._locationWatchId), this
        }, _handleGeolocationError: function (j) {
            var k = j.code, h = j.message || (1 === k ? "permission denied" : 2 === k ? "position unavailable" : "timeout");
            this._locationOptions.setView && !this._loaded && this.fitWorld(), this.fire("locationerror", {
                code: k,
                message: "Geolocation error: " + h + "."
            })
        }, _handleGeolocationResponse: function (y) {
            var q = 180 * y.coords.accuracy / 40000000, n = 2 * q, k = y.coords.latitude, z = y.coords.longitude, w = new g.LatLng(k, z), j = new g.LatLng(k - q, z - n), p = new g.LatLng(k + q, z + n), m = new g.LatLngBounds(j, p), x = this._locationOptions;
            if (x.setView) {
                var v = Math.min(this.getBoundsZoom(m), x.maxZoom);
                this.setView(w, v)
            }
            this.fire("locationfound", {latlng: w, bounds: m, accuracy: y.coords.accuracy})
        }
    })
})(this, document);