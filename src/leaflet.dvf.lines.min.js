L.CalloutLine = L.Path.extend({
    statics: {
        LINESTYLE: {ARC: "arc", ANGLE: "angle", STRAIGHT: "straight"},
        DIRECTION: {NE: "ne", NW: "nw", SE: "se", SW: "sw"}
    }
});
L.CalloutLine = L.CalloutLine.extend({
    initialize: function (b, a) {
        L.Util.setOptions(this, a);
        L.Path.prototype.initialize.call(this, a);
        this._latlng = b
    },
    options: {
        size: new L.Point(60, 30),
        position: new L.Point(0, 0),
        color: "#FFFFFF",
        opacity: 1,
        weight: 2,
        fillColor: "#000000",
        fill: false,
        gradient: false,
        dropShadow: false,
        direction: L.CalloutLine.DIRECTION.NE,
        lineStyle: L.CalloutLine.LINESTYLE.ANGLE,
        lineCap: "butt",
        lineJoin: "miter",
        arrow: false
    },
    projectLatlngs: function () {
        this._point = this._map.latLngToLayerPoint(this._latlng);
        this._points = this._getPoints()
    },
    getEndPoint: function () {
        this.projectLatlngs();
        return this._points[this._points.length - 1]
    },
    _getPathAngle: function () {
        return new L.SVGPathBuilder(this._points, [], {closePath: false}).build(6)
    },
    _getPathArc: function () {
        var f = (this.options.direction || L.CalloutLine.DIRECTION.NE).toLowerCase();
        var e = f[0];
        var a = e === "n" ? -1 : 1;
        var c = this._points[0];
        var b = this._points[this._points.length - 1];
        var d = ["M", c.x, ",", c.y, " Q", c.x, ",", c.y + a * this.options.size.y, " ", b.x, ",", b.y];
        return d.join(" ")
    },
    _getPoints: function () {
        var k = this._point.x + this.options.position.x;
        var i = this._point.y + this.options.position.y;
        var a = this.options.size.x;
        var o = this.options.size.y;
        var j = (this.options.direction || L.CalloutLine.DIRECTION.NE).toLowerCase();
        var n = [];
        var c = j[1];
        var g = j[0];
        var f = c === "w" ? -1 : 1;
        var b = g === "n" ? -1 : 1;
        n.push(new L.Point(k, i));
        var l = i + b * o;
        var e = a / 2;
        var d = Math.atan(o / e);
        if (this.options.lineStyle === L.CalloutLine.LINESTYLE.ARC) {
            d = Math.atan(Math.pow(o, 2) / e)
        } else {
            if (this.options.lineStyle === L.CalloutLine.LINESTYLE.STRAIGHT) {
                d = Math.atan(o / a)
            }
        }
        this._angle = d;
        if (this.options.lineStyle !== L.CalloutLine.LINESTYLE.STRAIGHT) {
            var m = new L.Point(k + f * e, l);
            n.push(m)
        }
        var h = new L.Point(k + f * a, l);
        n.push(h);
        return n
    },
    getBounds: function () {
        var f = this._map, b = f.project(this._latlng), c = new L.Point(b.x + this.options.position.x, b.y + this.options.position.y), e = new L.Point(c.x + this.options.size.x, c.y - this.options.size.y), a = f.unproject(c), d = f.unproject(e);
        return new L.LatLngBounds(a, d)
    },
    setLatLng: function (a) {
        this._latlng = a;
        this.redraw()
    },
    getLatLng: function () {
        return this._latlng
    },
    getPathString: function () {
        this._path.setAttribute("shape-rendering", "geometricPrecision");
        var a = this.options.lineStyle || L.CalloutLine.LINESTYLE.ANGLE;
        var b = "";
        if (a === L.CalloutLine.LINESTYLE.ANGLE || a === L.CalloutLine.LINESTYLE.STRAIGHT) {
            b += this._getPathAngle()
        } else {
            b += this._getPathArc()
        }
        return b
    }
});
L.calloutLine = function (b, a) {
    return new L.CalloutLine(b, a)
};
L.Callout = L.LayerGroup.extend({
    options: {color: "#FFFFFF", fillColor: "#FFFFFF"}, initialize: function (b, a) {
        L.Util.setOptions(this, a);
        L.LayerGroup.prototype.initialize.call(this, a);
        this._latlng = b
    }, onAdd: function (a) {
        L.LayerGroup.prototype.onAdd.call(this, a);
        this.addLayers()
    }, onRemove: function (a) {
        L.LayerGroup.prototype.onRemove.call(this, a);
        this.clearLayers()
    }, addArrow: function (b, g, e) {
        if (this.options.arrow) {
            b = L.LatLng.RAD_TO_DEG * b;
            var d = this.options.numberOfSides || 3;
            var f = this.options.radius || 6;
            var a = 180 / d;
            var c = {se: a + b, sw: 180 + a - b, nw: 180 + a + b, ne: a - b};
            var i = c[g];
            var h = new L.RegularPolygonMarker(this._latlng, {
                position: e,
                numberOfSides: d,
                rotation: i,
                fillColor: this.options.fillColor,
                color: this.options.color,
                gradient: this.options.gradient,
                weight: this.options.weight,
                opacity: this.options.opacity,
                fillOpacity: this.options.fillOpacity,
                radius: f,
                lineCap: "butt",
                lineJoin: "miter"
            });
            this.addLayer(h)
        }
    }, addLine: function () {
        var a = {};
        for (var b in this.options) {
            if (b !== "icon") {
                a[b] = this.options[b]
            }
        }
        var c = new L.CalloutLine(this._latlng, a);
        this.addLayer(c);
        return c
    }, addIcon: function (i, d) {
        var j = this.options.size;
        var h = this.options.icon;
        var f = h.options.iconSize;
        var g = i[0];
        var c = i[1];
        var e = c === "w" ? f.x + j.x - d.x : -1 * (j.x + d.x);
        var a = g === "n" ? f.y / 2 + j.y - d.y : -1 * (-f.y / 2 + j.y + d.y);
        h.options.iconAnchor = new L.Point(e, a);
        var b = new L.Marker(this._latlng, {icon: h});
        this.addLayer(b)
    }, addLayers: function () {
        var b = (this.options.direction || "ne").toLowerCase();
        var a = this.options.position || new L.Point(0, 0);
        var c;
        c = this.addLine();
        this.addIcon(b, a);
        this.addArrow(c._angle, b, a)
    }
});
L.callout = function (b, a) {
    return new L.Callout(b, a)
};
L.FlowLine = L.DataLayer.extend({
    statics: {
        LINE_FUNCTION: function (a, c, b) {
            return new L.Polyline([a, c], b)
        }, LINE_FUNCTION_INTERPOLATED: function (a, h, c) {
            var g = this._map.latlngToLayerPoint(a);
            var d = this._map.latlngToLayerPoint(h);
            var b = new L.LinearFunction(g, d);
            var f = Math.ceil(g.distanceTo(d) / c.interpolationOptions.segmentLength);
            var e = b.samplePoints(f)
        }
    }
});
L.FlowLine = L.FlowLine.extend({
    initialize: function (b, a) {
        L.Util.setOptions(this, a);
        L.DataLayer.prototype.initialize.call(this, b, a)
    }, options: {
        getLine: L.FlowLine.LINE_FUNCTION, showLegendTooltips: true, setHighlight: function (a) {
            a.opacity = a.opacity || 1;
            a.opacity /= 1.5;
            return a
        }, unsetHighlight: function (a) {
            a.opacity = a.opacity || 0.66;
            a.opacity *= 1.5;
            return a
        }
    }, onEachSegment: function (d, c, i) {
        var g = {};
        if (this.options.timeField) {
            var q = L.Util.getFieldValue(d, this.options.timeField);
            var p = L.Util.getFieldValue(c, this.options.timeField);
            var o = this.options.timeFormat;
            var n = o ? moment(q, o) : moment(q);
            var m = o ? moment(p, o) : moment(p);
            var e = m.valueOf() - n.valueOf();
            g.time = e
        }
        for (var r in this.options.displayOptions) {
            var l = L.Util.getFieldValue(d, r);
            var k = L.Util.getFieldValue(c, r);
            var j = k - l;
            var a = (j / l) * 100;
            g[r] = {from: l, to: k, change: j, percentChange: a};
            if (g.time) {
                g[r].changeOverTime = j / g.time
            }
        }
        var b = i.getLatLngs();
        var f = b[0].distanceTo(b[1]);
        var h;
        if (g.time) {
            h = f / (g.time * 1000)
        }
        if (this.options.onEachSegment) {
            this.options.onEachSegment.call(this, d, c, i, g, f, h)
        }
    }, _loadRecords: function (c) {
        var d = [];
        this._lastRecord = null;
        for (var b in c) {
            if (c.hasOwnProperty(b)) {
                var a = c[b];
                a = this.options.deriveProperties ? this.options.deriveProperties(a) : a;
                d = this._addRecord(a, b, d)
            }
        }
        while (d.length > 0) {
            this.addLayer(d.pop())
        }
    }, addRecord: function (a) {
        this._addRecord(a);
        return this
    }, _addRecord: function (d, e, h) {
        var c = this._getLocation(d, e);
        var f = this.options.layerOptions;
        if (c) {
            var b = this._getLayer(c, f, d);
            var a;
            var g = true;
            if (this.options.includeLayer) {
                g = this.options.includeLayer(d)
            }
            if (this._lastRecord && g) {
                f = this._getDynamicOptions(this._lastRecord);
                a = this.options.getLine.call(this, this._lastMarker.getLatLng(), b.getLatLng(), f.layerOptions);
                this.addLayer(a);
                if (this.options.showLegendTooltips) {
                    this._bindMouseEvents(a, f.layerOptions, f.legendDetails)
                }
                this.onEachSegment(this._lastRecord, d, a)
            }
            if (g) {
                this._lastRecord = d;
                this._lastMarker = b
            }
        }
        return h
    }
});
L.flowLine = function (b, a) {
    return new L.FlowLine(b, a)
};
L.ArcedFlowLine = L.FlowLine.extend({
    options: {
        getLine: function (a, c, b) {
            return new L.ArcedPolyline([a, c], b)
        }
    }, initialize: function (b, a) {
        L.FlowLine.prototype.initialize.call(this, b, a)
    }
});
L.arcedFlowLine = function (b, a) {
    return new L.ArcedFlowLine(b, a)
};
L.ArcedPolyline = L.Path.extend({
    includes: TextFunctions,
    initialize: function (a, b) {
        L.Path.prototype.initialize.call(this, b);
        this._latlngs = a
    },
    options: {
        distanceToHeight: new L.LinearFunction([0, 5], [1000, 200]),
        color: "#FFFFFF",
        opacity: 1,
        weight: 1,
        fillColor: "#000000",
        fill: false,
        gradient: false,
        dropShadow: false,
        optimizeSpeed: false
    },
    projectLatlngs: function () {
        this._points = [];
        for (var a = 0; a < this._latlngs.length; ++a) {
            this._points.push(this._map.latLngToLayerPoint(this._latlngs[a]))
        }
    },
    getBounds: function () {
        var b = new L.LatLngBounds();
        for (var a = 0; a < this._latlngs.length; ++a) {
            b.extend(this._latlngs[a])
        }
        return b
    },
    setLatLngs: function (a) {
        this._latlngs = a;
        this.redraw()
    },
    getLatLngs: function () {
        return this._latlngs
    },
    drawSegment: function (b, a) {
        var e = Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));
        var d = this.options.distanceToHeight.evaluate(e);
        var c = ["M", b.x, ",", b.y, " C", b.x, ",", b.y - d, " ", a.x, ",", a.y - d, " ", a.x, ",", a.y];
        return c.join(" ")
    },
    getPathString: function () {
        if (this.options.optimizeSpeed) {
            this._path.setAttribute("shape-rendering", "optimizeSpeed")
        }
        var b = [];
        for (var a = 0; a < this._points.length - 1; ++a) {
            b.push(this.drawSegment(this._points[a], this._points[a + 1]))
        }
        return b.join("")
    }
});
L.arcedPolyline = function (a, b) {
    return new L.ArcedPolyline(a, b)
};