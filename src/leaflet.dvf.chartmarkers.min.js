L.BarMarker = L.Path.extend({
    initialize: function (b, a) {
        L.Path.prototype.initialize.call(this, a);
        this._latlng = b
    },
    options: {
        fill: true,
        width: 2,
        maxHeight: 10,
        position: {x: 0, y: 0},
        weight: 1,
        color: "#000",
        opacity: 1,
        gradient: true,
        dropShadow: false,
        lineCap: "square",
        lineJoin: "miter"
    },
    setLatLng: function (a) {
        this._latlng = a;
        return this.redraw()
    },
    projectLatlngs: function () {
        this._point = this._map.latLngToLayerPoint(this._latlng);
        this._points = this._getPoints()
    },
    getBounds: function () {
        var f = this._map, b = f.project(this._latlng), g = this.options.width / 2, c = new L.Point(b.x - g, b.y), e = new L.Point(b.x + g, b.y - this.options.maxHeight), a = f.unproject(c), d = f.unproject(e);
        return new L.LatLngBounds(a, d)
    },
    getLatLng: function () {
        return this._latlng
    },
    getPathString: function () {
        this._path.setAttribute("shape-rendering", "crispEdges");
        return new L.SVGPathBuilder(this._points).build()
    },
    _getPoints: function () {
        var f = [];
        var d = this._point.x + this.options.position.x;
        var c = this._point.y + this.options.position.y;
        var b = this.options.width / 2;
        var g, a, i, e;
        var h = this.options.value / this.options.maxValue * this.options.maxHeight;
        g = new L.Point(d + b, c);
        a = new L.Point(d + b, c - h);
        i = new L.Point(d - b, c - h);
        e = new L.Point(d - b, c);
        f = [g, a, i, e];
        return f
    }
});
L.barMarker = function (b, a) {
    return new L.BarMarker(b, a)
};
L.ChartMarker = L.FeatureGroup.extend({
    initialize: function (b, a) {
        L.Util.setOptions(this, a);
        this._layers = {};
        this._latlng = b;
        this._loadComponents()
    }, setLatLng: function (a) {
        this._latlng = a;
        return this.redraw()
    }, getLatLng: function () {
        return this._latlng
    }, _loadComponents: function () {
    }, _highlight: function (a) {
        if (a.weight) {
            a.weight *= 2
        }
        return a
    }, _unhighlight: function (a) {
        if (a.weight) {
            a.weight /= 2
        }
        return a
    }, _bindMouseEvents: function (c) {
        var a = this;
        var b = this.options.tooltipOptions;
        c.on("mouseover", function (j) {
            var f = this.options;
            var p = f.key;
            var o = f.value;
            var q = j.layerPoint;
            var n = q.x - this._point.x;
            var m = q.y - this._point.y;
            var k = f.iconSize;
            var d = n;
            var s = m;
            var g;
            var h = 5;
            d = n < 0 ? k.x - n + h : -n - h;
            s = m < 0 ? k.y - m + h : -m - h;
            g = new L.Point(d, s);
            var r = {};
            var i = f.displayText ? f.displayText(o) : o;
            r[p] = {name: f.displayName, value: i};
            var l = new L.LegendIcon(r, f, {
                className: "leaflet-div-icon",
                iconSize: b ? b.iconSize : k,
                iconAnchor: g
            });
            f.marker = new L.Marker(a._latlng, {icon: l});
            f = a._highlight(f);
            this.initialize(a._latlng, f);
            this.redraw();
            this.setStyle(f);
            a.addLayer(f.marker)
        });
        c.on("mouseout", function (f) {
            var d = this.options;
            d = a._unhighlight(d);
            this.initialize(a._latlng, d);
            this.redraw();
            this.setStyle(d);
            a.removeLayer(d.marker)
        })
    }, bindPopup: function (b, a) {
        this.eachLayer(function (c) {
            c.bindPopup(b, a)
        })
    }, openPopup: function (c) {
        for (var b in this._layers) {
            var a = this._layers[b];
            c = c || this._latlng;
            a.openPopup(c);
            break
        }
    }, closePopup: function () {
        for (var b in this._layers) {
            var a = this._layers[b];
            latlng = latlng || this._latlng;
            a.closePopup();
            break
        }
    }, redraw: function () {
        this.clearLayers();
        this._loadComponents()
    }, toGeoJSON: function () {
        return L.Util.pointToGeoJSON.call(this)
    }
});
L.BarChartMarker = L.ChartMarker.extend({
    initialize: function (b, a) {
        L.Util.setOptions(this, a);
        L.ChartMarker.prototype.initialize.call(this, b, a)
    },
    options: {
        weight: 1,
        opacity: 1,
        color: "#000",
        fill: true,
        position: {x: 0, y: 0},
        width: 10,
        offset: 0,
        iconSize: new L.Point(50, 40)
    },
    _loadComponents: function () {
        var k, i, f;
        var g;
        var o = this.options;
        var j;
        var h;
        var n = Object.keys(this.options.data);
        var e = n.length;
        var a = this.options.width;
        var c = this.options.offset || 0;
        var d = this.options.data;
        var b = this.options.chartOptions;
        var m;
        j = -((a * e) + (c * (e - 1))) / 2 + a / 2;
        h = 0;
        for (var l in d) {
            k = d[l];
            m = b[l];
            i = m.minValue || 0;
            f = m.maxValue || 100;
            o.fillColor = m.fillColor || this.options.fillColor;
            o.value = k;
            o.minValue = i;
            o.maxValue = f;
            o.position = {x: j, y: h};
            o.width = a;
            o.maxHeight = m.maxHeight || 10;
            o.key = l;
            o.value = k;
            o.displayName = m.displayName;
            o.opacity = this.options.opacity || 1;
            o.fillOpacity = this.options.fillOpacity || 0.7;
            o.weight = this.options.weight || 1;
            o.color = m.color || this.options.color;
            o.displayText = m.displayText;
            g = new L.BarMarker(this._latlng, o);
            this._bindMouseEvents(g);
            this.addLayer(g);
            j += a + c
        }
    }
});
L.RadialBarMarker = L.Path.extend({
    initialize: function (b, a) {
        L.Path.prototype.initialize.call(this, a);
        this._latlng = b
    },
    options: {
        fill: true,
        radius: 10,
        rotation: 0,
        numberOfSides: 30,
        position: {x: 0, y: 0},
        gradient: true,
        dropShadow: false
    },
    setLatLng: function (a) {
        this._latlng = a;
        return this.redraw()
    },
    projectLatlngs: function () {
        this._point = this._map.latLngToLayerPoint(this._latlng);
        this._points = this._getPoints()
    },
    getBounds: function () {
        var a = this._map, c = this.options.radiusX || this.options.radius, b = this.options.radiusY || this.options.radius, g = c * Math.cos(Math.PI / 4), f = b * Math.sin(Math.PI / 4), j = a.project(this._latlng), h = new L.Point(j.x - g, j.y + f), d = new L.Point(j.x + g, j.y - f), i = a.unproject(h), e = a.unproject(d);
        return new L.LatLngBounds(i, e)
    },
    getLatLng: function () {
        return this._latlng
    },
    getPathString: function () {
        var e = this.options.endAngle - this.options.startAngle;
        var c = e >= 180 ? "1" : "0";
        var d = this.options.radiusX || this.options.radius;
        var b = this.options.radiusY || this.options.radius;
        var a = "M" + this._points[0].x.toFixed(2) + "," + this._points[0].y.toFixed(2) + "A" + d.toFixed(2) + "," + b.toFixed(2) + " 0 " + c + ",1 " + this._points[1].x.toFixed(2) + "," + this._points[1].y.toFixed(2) + "L";
        if (this._innerPoints) {
            a = a + this._innerPoints[0].x.toFixed(2) + "," + this._innerPoints[0].y.toFixed(2);
            a = a + "A" + (d - this.options.barThickness).toFixed(2) + "," + (b - this.options.barThickness).toFixed(2) + " 0 " + c + ",0 " + this._innerPoints[1].x.toFixed(2) + "," + this._innerPoints[1].y.toFixed(2) + "z"
        } else {
            a = a + this._point.x.toFixed(2) + "," + this._point.y.toFixed(2) + "z"
        }
        if (L.Browser.vml) {
            a = Core.SVG.path(a)
        }
        this._path.setAttribute("shape-rendering", "geometricPrecision");
        return a
    },
    _getPoints: function () {
        var d = this.options.endAngle - this.options.startAngle;
        var e = this.options.endAngle + this.options.rotation;
        var f = this.options.startAngle + this.options.rotation;
        var i = [];
        var c = "radiusX" in this.options ? this.options.radiusX : this.options.radius;
        var b = "radiusY" in this.options ? this.options.radiusY : this.options.radius;
        var g = function (j) {
            return j * L.LatLng.DEG_TO_RAD
        };
        e = e || 0;
        if (d === 360) {
            e = e - 0.1
        }
        var h = g(f);
        var a = g(e);
        i.push(this._getPoint(h, c, b));
        i.push(this._getPoint(a, c, b));
        if (this.options.barThickness) {
            this._innerPoints = [];
            this._innerPoints.push(this._getPoint(a, c - this.options.barThickness, b - this.options.barThickness));
            this._innerPoints.push(this._getPoint(h, c - this.options.barThickness, b - this.options.barThickness))
        }
        return i
    },
    _getPoint: function (c, b, a) {
        return new L.Point(this._point.x + this.options.position.x + b * Math.cos(c), this._point.y + this.options.position.y + a * Math.sin(c))
    }
});
L.radialBarMarker = function (b, a) {
    return new L.RadialBarMarker(b, a)
};
L.PieChartMarker = L.ChartMarker.extend({
    initialize: function (b, a) {
        L.Util.setOptions(this, a);
        L.ChartMarker.prototype.initialize.call(this, b, a)
    },
    options: {
        weight: 1,
        opacity: 1,
        color: "#000",
        fill: true,
        radius: 10,
        rotation: 0,
        numberOfSides: 50,
        mouseOverExaggeration: 1.2,
        maxDegrees: 360,
        iconSize: new L.Point(50, 40)
    },
    _highlight: function (b) {
        var d = b.radiusX;
        var c = b.radiusY;
        var a = b.barThickness;
        b.oldBarThickness = a;
        b.oldRadiusX = d;
        b.oldRadiusY = c;
        b.radiusX *= b.mouseOverExaggeration;
        b.radiusY *= b.mouseOverExaggeration;
        b.barThickness = b.radiusX - d + a;
        return b
    },
    _unhighlight: function (a) {
        a.radiusX = a.oldRadiusX;
        a.radiusY = a.oldRadiusY;
        a.barThickness = a.oldBarThickness;
        return a
    },
    _loadComponents: function () {
        var i;
        var g = 0;
        var c = 0;
        var l = 0;
        var a = this.options.maxDegrees || 360;
        var b = this.options.rotation;
        var h;
        var m = this.options;
        var f = this.options.data;
        var e = this.options.chartOptions;
        var k;
        var j;
        var d = function (p, n) {
            var o = 0;
            if (p[n]) {
                o = parseFloat(p[n])
            }
            return o
        };
        for (j in f) {
            i = d(f, j);
            g += i
        }
        if (g > 0) {
            for (j in f) {
                i = parseFloat(f[j]) || 0;
                k = e[j];
                l = i / g;
                c = l * a;
                m.startAngle = b;
                m.endAngle = b + c;
                m.fillColor = k.fillColor;
                m.color = k.color || "#000";
                m.radiusX = this.options.radiusX || this.options.radius;
                m.radiusY = this.options.radiusY || this.options.radius;
                m.rotation = 0;
                m.key = j;
                m.value = i;
                m.displayName = k.displayName;
                m.displayText = k.displayText;
                h = new L.RadialBarMarker(this._latlng, m);
                this._bindMouseEvents(h);
                b = m.endAngle;
                this.addLayer(h)
            }
        }
    }
});
L.pieChartMarker = function (b, a) {
    return new L.PieChartMarker(b, a)
};
L.CoxcombChartMarker = L.PieChartMarker.extend({statics: {SIZE_MODE_RADIUS: "radius", SIZE_MODE_AREA: "area"}});
L.CoxcombChartMarker = L.CoxcombChartMarker.extend({
    initialize: function (b, a) {
        L.Util.setOptions(this, a);
        L.PieChartMarker.prototype.initialize.call(this, b, a)
    },
    options: {
        weight: 1,
        opacity: 1,
        color: "#000",
        fill: true,
        radius: 10,
        rotation: 0,
        numberOfSides: 50,
        mouseOverExaggeration: 1.2,
        maxDegrees: 360,
        iconSize: new L.Point(50, 40),
        sizeMode: L.CoxcombChartMarker.SIZE_MODE_AREA
    },
    _loadComponents: function () {
        var l, k, s;
        var r = 0;
        var t = this.options.maxDegrees || 360;
        var f = this.options.rotation;
        var q;
        var a = this.options;
        var g = "radiusX" in this.options ? this.options.radiusX : this.options.radius;
        var d = "radiusY" in this.options ? this.options.radiusY : this.options.radius;
        var j = Object.keys(this.options.data);
        var e = j.length;
        var u = this.options.data;
        var m = this.options.chartOptions;
        var c;
        r = t / e;
        var n = function (w) {
            return Math.sqrt(e * w / Math.PI)
        };
        for (var v in u) {
            l = parseFloat(u[v]) || 0;
            c = m[v];
            k = c.minValue || 0;
            s = c.maxValue;
            if (this.options.sizeMode === L.CoxcombChartMarker.SIZE_MODE_RADIUS) {
                var p = new L.LinearFunction(new L.Point(k, 0), new L.Point(s, g));
                var o = new L.LinearFunction(new L.Point(k, 0), new L.Point(s, d));
                a.radiusX = p.evaluate(l);
                a.radiusY = o.evaluate(l)
            } else {
                var b = Math.max(g, d);
                var h = (Math.PI * Math.pow(b, 2)) / e;
                var i = new L.LinearFunction(new L.Point(k, 0), new L.Point(s, h), {postProcess: n});
                a.radiusX = i.evaluate(l);
                a.radiusY = a.radiusX
            }
            a.startAngle = f;
            a.endAngle = f + r;
            a.fillColor = c.fillColor;
            a.color = c.color || "#000";
            a.rotation = 0;
            a.key = v;
            a.value = l;
            a.displayName = c.displayName;
            a.displayText = c.displayText;
            q = new L.RadialBarMarker(this._latlng, a);
            this._bindMouseEvents(q);
            f = a.endAngle;
            this.addLayer(q)
        }
    }
});
L.coxcombChartMarker = function (b, a) {
    return new L.CoxcombChartMarker(b, a)
};
L.RadialBarChartMarker = L.ChartMarker.extend({
    initialize: function (b, a) {
        L.Util.setOptions(this, a);
        L.ChartMarker.prototype.initialize.call(this, b, a)
    },
    options: {
        weight: 1,
        opacity: 1,
        color: "#000",
        fill: true,
        radius: 10,
        rotation: 0,
        numberOfSides: 30,
        offset: 2,
        barThickness: 5,
        maxDegrees: 360,
        iconSize: new L.Point(50, 40)
    },
    _loadComponents: function () {
        var m, l, j;
        var d = this.options.rotation;
        var c = this.options.maxDegrees || 360;
        var k;
        var p = this.options;
        var e = this.options.radiusX || this.options.radius;
        var b = this.options.radiusY || this.options.radius;
        var h = this.options.data;
        var g = this.options.chartOptions;
        var o;
        var a = this.options.barThickness || 4;
        var f = this.options.offset || 2;
        for (var n in h) {
            m = parseFloat(h[n]);
            o = g[n];
            l = o.minValue || 0;
            j = o.maxValue || 100;
            var i = new L.LinearFunction(new L.Point(l, 0), new L.Point(j, c));
            d = i.evaluate(m);
            p.startAngle = this.options.rotation;
            p.endAngle = this.options.rotation + d;
            p.fillColor = o.fillColor;
            p.radiusX = e;
            p.radiusY = b;
            p.barThickness = a;
            p.rotation = 0;
            p.key = n;
            p.value = m;
            p.displayName = o.displayName;
            p.displayText = o.displayText;
            p.weight = this.options.weight || 1;
            k = new L.RadialBarMarker(this._latlng, p);
            this._bindMouseEvents(k);
            this.addLayer(k);
            e += a + f;
            b += a + f
        }
    }
});
L.radialBarChartMarker = function (b, a) {
    return new L.RadialBarChartMarker(b, a)
};
L.StackedRegularPolygonMarker = L.ChartMarker.extend({
    options: {iconSize: new L.Point(50, 40)},
    initialize: function (b, a) {
        L.Util.setOptions(this, a);
        L.ChartMarker.prototype.initialize.call(this, b, a)
    },
    _loadComponents: function () {
        var h;
        var c = 0;
        var b = 0;
        var g;
        var m = this.options;
        var f = this.options.data;
        var e = this.options.chartOptions;
        var k;
        var j;
        var i = [];
        for (j in f) {
            h = parseFloat(f[j]);
            k = e[j];
            minValue = k.minValue || 0;
            maxValue = k.maxValue || 100;
            minRadius = k.minRadius || 0;
            maxRadius = k.maxRadius || 10;
            m.fillColor = k.fillColor || this.options.fillColor;
            m.value = h;
            m.minValue = minValue;
            m.maxValue = maxValue;
            var d = new L.LinearFunction(new L.Point(minValue, minRadius), new L.Point(maxValue, maxRadius));
            var a = d.evaluate(h);
            m.radiusX = c + a;
            m.radiusY = b + a;
            m.innerRadiusX = c;
            m.innerRadiusY = b;
            m.key = j;
            m.displayName = k.displayName;
            m.opacity = this.options.opacity || 1;
            m.fillOpacity = this.options.fillOpacity || 0.7;
            m.weight = this.options.weight || 1;
            m.color = k.color || this.options.color;
            m.displayText = k.displayText;
            g = new L.RegularPolygonMarker(this._latlng, m);
            this._bindMouseEvents(g);
            c = m.radiusX;
            b = m.radiusY;
            if (this.options.drawReverse) {
                i.push(g)
            } else {
                this.addLayer(g)
            }
        }
        if (this.options.drawReverse) {
            var l = i.pop();
            while (l) {
                this.addLayer(l);
                l = i.pop()
            }
        }
    }
});
L.RadialMeterMarker = L.ChartMarker.extend({
    initialize: function (b, a) {
        L.Util.setOptions(this, a);
        L.ChartMarker.prototype.initialize.call(this, b, a)
    },
    options: {
        weight: 1,
        opacity: 1,
        color: "#000",
        fill: true,
        radius: 10,
        rotation: 180,
        numberOfSides: 30,
        offset: 2,
        barThickness: 5,
        maxDegrees: 180,
        iconSize: new L.Point(50, 40),
        backgroundStyle: {fill: true, fillColor: "#707070", fillOpacity: 0.2, opacity: 0.8, color: "#505050"}
    },
    _loadComponents: function () {
        var q, n, v;
        var r = this.options.rotation;
        var x = this.options.maxDegrees || 360;
        var t;
        var b = this.options;
        var g = this.options.radiusX || this.options.radius;
        var d = this.options.radiusY || this.options.radius;
        var y = this.options.data;
        var s = this.options.chartOptions;
        var c;
        var i = this.options.barThickness || 4;
        var f = r;
        var o = this.options.numSegments || 10;
        var m = x / o;
        var k;
        for (var A in y) {
            q = parseFloat(y[A]);
            c = s[A];
            k = this.options.displayOptions ? this.options.displayOptions[A] : {};
            n = c.minValue || 0;
            v = c.maxValue || 100;
            var l = v - n;
            var u = (x / l) * (q - n);
            var p = r + u;
            var z = r + x;
            var h = new L.LinearFunction(new L.Point(r, n), new L.Point(z, v));
            var w, j;
            while (f < p) {
                b.startAngle = f;
                w = Math.min(m, p - f);
                b.endAngle = f + w;
                b.fillColor = c.fillColor;
                b.radiusX = g;
                b.radiusY = d;
                b.barThickness = i;
                b.rotation = 0;
                b.key = A;
                b.value = q;
                b.displayName = c.displayName;
                b.displayText = c.displayText;
                j = h.evaluate(f + w);
                for (var a in k) {
                    b[a] = k[a].evaluate ? k[a].evaluate(j) : k[a]
                }
                t = new L.RadialBarMarker(this._latlng, b);
                this._bindMouseEvents(t);
                this.addLayer(t);
                f += w
            }
            if (this.options.backgroundStyle) {
                if (f < z) {
                    w = z - f;
                    b.endAngle = f + w;
                    b.radiusX = g;
                    b.radiusY = d;
                    b.barThickness = i;
                    b.rotation = 0;
                    b.key = A;
                    b.value = q;
                    b.displayName = c.displayName;
                    b.displayText = c.displayText;
                    b.fillColor = null;
                    b.fill = false;
                    b.gradient = false;
                    for (var e in this.options.backgroundStyle) {
                        b[e] = this.options.backgroundStyle[e]
                    }
                    j = h.evaluate(f + w);
                    t = new L.RadialBarMarker(this._latlng, b);
                    this.addLayer(t)
                }
            }
        }
    }
});