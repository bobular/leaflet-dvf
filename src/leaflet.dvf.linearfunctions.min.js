L.LinearFunction = L.Class.extend({
    options: {constrainX: false}, initialize: function (a, b, c) {
        this.setOptions(c);
        this.setRange(a, b)
    }, _calculateParameters: function (a, b) {
        if (this._xRange === 0) {
            this._slope = 0;
            this._b = a.y
        } else {
            this._slope = (b.y - a.y) / this._xRange;
            this._b = a.y - this._slope * a.x
        }
    }, _arrayToPoint: function (a) {
        return {x: a[0], y: a[1]}
    }, setOptions: function (a) {
        L.Util.setOptions(this, a);
        this._preProcess = this.options.preProcess;
        this._postProcess = this.options.postProcess
    }, getBounds: function () {
        var a = Math.min(this._minPoint.x, this._maxPoint.x);
        var c = Math.max(this._minPoint.x, this._maxPoint.x);
        var d = Math.min(this._minPoint.y, this._maxPoint.y);
        var b = Math.max(this._minPoint.y, this._maxPoint.y);
        return [new L.Point(a, d), new L.Point(c, b)]
    }, setRange: function (a, b) {
        a = a instanceof Array ? this._arrayToPoint(a) : a;
        b = b instanceof Array ? this._arrayToPoint(b) : b;
        this._minPoint = a;
        this._maxPoint = b;
        this._xRange = b.x - a.x;
        this._calculateParameters(a, b);
        return this
    }, setMin: function (a) {
        this.setRange(a, this._maxPoint);
        return this
    }, setMax: function (a) {
        this.setRange(this._minPoint, a);
        return this
    }, setPreProcess: function (a) {
        this._preProcess = a;
        return this
    }, setPostProcess: function (a) {
        this._postProcess = a;
        return this
    }, constrainX: function (a) {
        a = Number(a);
        if (this.options.constrainX) {
            a = Math.max(a, this._minPoint.x);
            a = Math.min(a, this._maxPoint.x)
        }
        return a
    }, evaluate: function (a) {
        var b;
        if (this._preProcess) {
            a = this._preProcess(a)
        }
        b = Number((this._slope * a).toFixed(6)) + Number(this._b.toFixed(6));
        if (this._postProcess) {
            b = this._postProcess(b)
        }
        return b
    }, random: function () {
        var a = Math.random() * this._xRange + this._minPoint.x;
        return this.evaluate(a)
    }, sample: function (d) {
        d = Math.max(d, 2);
        var b = d - 1;
        var e = this._xRange / b;
        var a = this._minPoint.x;
        var c = [];
        while (a <= this._maxPoint.x) {
            c.push(this.evaluate(a));
            a += e
        }
        return c
    }, samplePoints: function (d) {
        d = Math.max(d, 2);
        var b = d - 1;
        var e = this._xRange / b;
        var a = this._minPoint.x;
        var c = [];
        while (a <= this._maxPoint.x) {
            c.push(new L.Point(a, this.evaluate(a)));
            a += e
        }
        return c
    }, getIntersectionPoint: function (c) {
        var b = null;
        if (this._slope !== c._slope) {
            var a = (this._b - c._b) / (c._slope - this._slope);
            var d = this.evaluate(a);
            b = new L.Point(a, d)
        }
        return b
    }
});
L.ColorFunction = L.LinearFunction.extend({
    options: {alpha: 1, includeAlpha: false}, initialize: function (a, b, c) {
        L.Util.setOptions(this, c);
        this._parts = [];
        this._dynamicPart = null;
        this._outputPrecision = 0;
        this._prefix = null;
        this._formatOutput = function (e) {
            return e.toFixed(this._outputPrecision)
        };
        this._mapOutput = function (h) {
            var e = [];
            for (var g = 0; g < this._parts.length; ++g) {
                var f = this._parts[g];
                e.push(h[f])
            }
            if (this.options.includeAlpha) {
                e.push(this.options.alpha)
            }
            return e
        };
        this._getColorString = function (f) {
            f = this._formatOutput(f);
            this.options[this._dynamicPart] = f;
            var e = this._mapOutput(this.options);
            return this._writeColor(this._prefix, e)
        };
        this._writeColor = function (e, f) {
            if (this.options.includeAlpha) {
                e += "a"
            }
            return e + "(" + f.join(",") + ")"
        };
        c = this.options;
        var d = function (f) {
            if (c && c.postProcess) {
                f = c.postProcess.call(this, f)
            }
            var e = this._getColorString(f);
            if (((L.Browser.ie) && e.indexOf("hsl") > -1) || c.rgb) {
                e = L.hslColor(e).toRGBString()
            }
            return e
        };
        L.LinearFunction.prototype.initialize.call(this, a, b, {preProcess: this.options.preProcess, postProcess: d})
    }
});
L.HSLColorFunction = L.ColorFunction.extend({
    initialize: function (a, b, c) {
        L.ColorFunction.prototype.initialize.call(this, a, b, c);
        this._parts = ["outputHue", "outputSaturation", "outputLuminosity"];
        this._prefix = "hsl";
        this._outputPrecision = 2
    }
});
L.RGBColorFunction = L.ColorFunction.extend({
    initialize: function (a, b, c) {
        L.ColorFunction.prototype.initialize.call(this, a, b, c);
        this._parts = ["outputRed", "outputBlue", "outputGreen"];
        this._prefix = "rgb";
        this._outputPrecision = 0
    }
});
L.RGBRedFunction = L.LinearFunction.extend({
    options: {outputGreen: 0, outputBlue: 0}, initialize: function (a, b, c) {
        L.RGBColorFunction.prototype.initialize.call(this, a, b, c);
        this._dynamicPart = "outputRed"
    }
});
L.RGBBlueFunction = L.LinearFunction.extend({
    options: {outputRed: 0, outputGreen: 0}, initialize: function (a, b, c) {
        L.RGBColorFunction.prototype.initialize.call(this, a, b, c);
        this._dynamicPart = "outputBlue"
    }
});
L.RGBGreenFunction = L.LinearFunction.extend({
    options: {outputRed: 0, outputBlue: 0}, initialize: function (a, b, c) {
        L.RGBColorFunction.prototype.initialize.call(this, a, b, c);
        this._dynamicPart = "outputGreen"
    }
});
L.RGBColorBlendFunction = L.LinearFunction.extend({
    initialize: function (d, a, j, g) {
        j = new L.RGBColor(j);
        g = new L.RGBColor(g);
        var c = j.r();
        var b = g.r();
        var i = j.g();
        var h = g.g();
        var f = j.b();
        var e = g.b();
        this._minX = d;
        this._maxX = a;
        this._redFunction = new L.LinearFunction(new L.Point(d, c), new L.Point(a, b));
        this._greenFunction = new L.LinearFunction(new L.Point(d, i), new L.Point(a, h));
        this._blueFunction = new L.LinearFunction(new L.Point(d, f), new L.Point(a, e))
    }, getBounds: function () {
        var b = this._redFunction.getBounds();
        var a = this._greenFunction.getBounds();
        var d = this._blueFunction.getBounds();
        var e = Math.min(b[0].y, a[0].y, d[0].y);
        var c = Math.max(b[0].y, a[0].y, d[0].y);
        return [new L.Point(b[0].x, e), new L.Point(b[1].x, c)]
    }, evaluate: function (a) {
        return new L.RGBColor([this._redFunction.evaluate(a), this._greenFunction.evaluate(a), this._blueFunction.evaluate(a)]).toRGBString()
    }
});
L.HSLHueFunction = L.HSLColorFunction.extend({
    options: {outputSaturation: "100%", outputLuminosity: "50%"},
    initialize: function (a, b, c) {
        L.HSLColorFunction.prototype.initialize.call(this, a, b, c);
        this._dynamicPart = "outputHue"
    }
});
L.HSLSaturationFunction = L.LinearFunction.extend({
    options: {outputHue: 0, outputLuminosity: "50%"},
    initialize: function (a, b, c) {
        L.HSLColorFunction.prototype.initialize.call(this, a, b, c);
        this._formatOutput = function (d) {
            return (d * 100).toFixed(this._outputPrecision) + "%"
        };
        this._dynamicPart = "outputSaturation"
    }
});
L.HSLLuminosityFunction = L.LinearFunction.extend({
    options: {outputHue: 0, outputSaturation: "100%"},
    initialize: function (a, b, c) {
        L.HSLColorFunction.prototype.initialize.call(this, a, b, c);
        this._formatOutput = function (d) {
            return (d * 100).toFixed(this._outputPrecision) + "%"
        };
        this._dynamicPart = "outputLuminosity"
    }
});
L.HSLColorBlendFunction = L.LinearFunction.extend({
    initialize: function (d, a, f, e) {
        f = new L.HSLColor(f);
        e = new L.HSLColor(e);
        var h = f.h();
        var g = e.h();
        var j = f.s();
        var i = e.s();
        var c = f.l();
        var b = e.l();
        this._minX = d;
        this._maxX = a;
        this._hueFunction = new L.LinearFunction(new L.Point(d, h), new L.Point(a, g));
        this._saturationFunction = new L.LinearFunction(new L.Point(d, j), new L.Point(a, i));
        this._luminosityFunction = new L.LinearFunction(new L.Point(d, c), new L.Point(a, b))
    }, getBounds: function () {
        var a = this._hueFunction.getBounds();
        var e = this._saturationFunction.getBounds();
        var b = this._luminosityFunction.getBounds();
        var d = Math.min(a[0].y, e[0].y, b[0].y);
        var c = Math.max(a[0].y, e[0].y, b[0].y);
        return [new L.Point(a[0].x, d), new L.Point(a[1].x, c)]
    }, evaluate: function (a) {
        return new L.HSLColor([this._hueFunction.evaluate(a), this._saturationFunction.evaluate(a), this._luminosityFunction.evaluate(a)]).toHSLString()
    }
});
L.PiecewiseFunction = L.LinearFunction.extend({
    options: {constrainX: true}, initialize: function (d, a) {
        L.Util.setOptions(this, a);
        this._functions = d;
        var c;
        var b;
        c = d[0].getBounds()[0];
        b = d[d.length - 1].getBounds()[1];
        L.LinearFunction.prototype.initialize.call(this, c, b, {
            preProcess: this.options.preProcess,
            postProcess: this.options.postProcess
        })
    }, _getFunction: function (a) {
        var e;
        var d;
        var c;
        var f;
        if (a < this._minPoint.x) {
            f = this._functions[0]
        } else {
            if (a >= this._maxPoint.x) {
                f = this._functions[this._functions.length - 1]
            } else {
                for (var b = 0; b < this._functions.length; ++b) {
                    f = this._functions[b];
                    e = f.getBounds();
                    d = e[0];
                    c = e[1];
                    if (a >= d.x && a < c.x) {
                        break
                    }
                }
            }
        }
        return f
    }, evaluate: function (a) {
        var b;
        var c = null;
        a = this.constrainX(a);
        if (this._preProcess) {
            a = this._preProcess(a)
        }
        b = this._getFunction(a);
        if (b) {
            c = b.evaluate(a);
            if (this._postProcess) {
                c = this._postProcess(c)
            }
        }
        return c
    }
});
L.ColorClassFunction = L.PiecewiseFunction.extend({
    options: {interpolate: false}, initialize: function (h, a, j) {
        var e = [];
        var k;
        L.Util.setOptions(this, j);
        for (var f = 0; f < h.length - 1; ++f) {
            var b = h[f], d = h[f + 1], g = a[f], c = this.options.interpolate ? a[Math.min(a.length - 1, f + 1)] : a[f];
            k = new L.RGBColorBlendFunction(b, d, g, c);
            e.push(k)
        }
        L.PiecewiseFunction.prototype.initialize.call(this, e)
    }
});
L.CustomColorFunction = L.PiecewiseFunction.extend({
    options: {interpolate: true}, initialize: function (e, c, a, m) {
        L.Util.setOptions(this, m);
        var j = c - e;
        var k = this.options.interpolate ? a.length - 1 : a.length;
        var b = j / k;
        var g = [];
        var l;
        var h;
        var d = new L.LinearFunction([0, e], [k, c]);
        for (var f = 0; f < k; ++f) {
            h = f + 1;
            l = this.options.interpolate ? new L.RGBColorBlendFunction(d.evaluate(f), d.evaluate(h), a[f], a[h]) : new L.RGBColorBlendFunction(d.evaluate(f), d.evaluate(h), a[f], a[f]);
            g.push(l)
        }
        d = null;
        L.PiecewiseFunction.prototype.initialize.call(this, g)
    }
});
L.CategoryFunction = L.Class.extend({
    initialize: function (b, a) {
        L.Util.setOptions(this, a);
        this._categoryKeys = Object.keys(b);
        this._categoryMap = b;
        this._preProcess = this.options.preProcess;
        this._postProcess = this.options.postProcess
    }, evaluate: function (a) {
        var b;
        if (this._preProcess) {
            a = this._preProcess(a)
        }
        b = this._categoryMap[a];
        if (this._postProcess) {
            b = this._postProcess(b)
        }
        return b
    }, getCategories: function () {
        return this._categoryKeys
    }
});