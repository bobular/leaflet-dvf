L.Path.XLINK_NS = "http://www.w3.org/1999/xlink";
var TextFunctions = TextFunctions || {
        __updatePath: L.Path.prototype._updatePath, _updatePath: function () {
            this.__updatePath.call(this);
            if (this.options.text) {
                this._createText(this.options.text)
            }
        }, _initText: function () {
            if (this.options.text) {
                this._createText(this.options.text)
            }
        }, getTextAnchor: function () {
            if (this._point) {
                return this._point
            }
        }, setTextAnchor: function (a) {
            if (this._text) {
                this._text.setAttribute("x", a.x);
                this._text.setAttribute("y", a.y)
            }
        }, _createText: function (i) {
            if (this._text) {
                this._container.removeChild(this._text)
            }
            if (this._pathDef) {
                this._defs.removeChild(this._pathDef)
            }
            var d = function (l, m) {
                var j = "";
                for (var k in m) {
                    j += k + ": " + m[k] + ";"
                }
                l.setAttribute("style", j);
                return l
            };
            var b = function (l, j) {
                for (var k in j) {
                    l.setAttribute(k, j[k])
                }
                return l
            };
            this._text = this._createElement("text");
            var c = document.createTextNode(i.text);
            if (i.path) {
                var f = i.path;
                var h = L.Util.guid();
                var e = this._createElement("path");
                e.setAttribute("d", this._path.getAttribute("d"));
                e.setAttribute("id", h);
                if (!this._defs) {
                    this._defs = this._createElement("defs");
                    this._container.appendChild(this._defs)
                }
                this._defs.appendChild(e);
                this._pathDef = e;
                var a = this._createElement("textPath");
                if (f.startOffset) {
                    a.setAttribute("startOffset", f.startOffset)
                }
                if (f.attr) {
                    b(a, f.attr)
                }
                if (f.style) {
                    d(a, f.style)
                }
                a.setAttributeNS(L.Path.XLINK_NS, "xlink:href", "#" + h);
                a.appendChild(c);
                this._text.appendChild(a)
            } else {
                this._text.appendChild(c);
                var g = this.getTextAnchor();
                this.setTextAnchor(g)
            }
            if (i.className) {
                this._text.setAttribute("class", i.className)
            } else {
                this._text.setAttribute("class", "leaflet-svg-text")
            }
            if (i.attr) {
                b(this._text, i.attr)
            }
            if (i.style) {
                d(this._text, i.style)
            }
            this._container.appendChild(this._text)
        }
    };
var PathFunctions = PathFunctions || {
        __updateStyle: L.Path.prototype._updateStyle, _createDefs: function () {
            this._defs = this._createElement("defs");
            this._container.appendChild(this._defs)
        }, _createGradient: function (n) {
            if (!this._defs) {
                this._createDefs()
            }
            if (this._gradient) {
                this._defs.removeChild(this._gradient)
            }
            n = n !== true ? L.extend({}, n) : {};
            var a = L.Util.guid();
            this._gradientGuid = a;
            var j;
            var h;
            if (n.gradientType == "radial") {
                j = this._createElement("radialGradient");
                h = n.radial || {cx: "50%", cy: "50%", r: "50%", fx: "50%", fy: "50%"}
            } else {
                j = this._createElement("linearGradient");
                var b = n.vector || [["0%", "0%"], ["100%", "100%"]];
                h = {x1: b[0][0], x2: b[1][0], y1: b[0][1], y2: b[1][1]}
            }
            h.id = "grad" + a;
            var l = n.stops || [{offset: "0%", style: {color: "rgb(255, 255, 255)", opacity: 1}}, {
                    offset: "60%",
                    style: {color: this.options.fillColor || this.options.color, opacity: 1}
                }];
            var k;
            for (k in h) {
                j.setAttribute(k, h[k])
            }
            for (var d = 0; d < l.length; ++d) {
                var g = l[d];
                var c = this._createElement("stop");
                g.style = g.style || {};
                for (k in g) {
                    var m = g[k];
                    if (k === "style") {
                        var e = "";
                        m.color = m.color || (this.options.fillColor || this.options.color);
                        m.opacity = typeof m.opacity === "undefined" ? 1 : m.opacity;
                        for (var f in m) {
                            e += "stop-" + f + ":" + m[f] + ";"
                        }
                        m = e
                    }
                    c.setAttribute(k, m)
                }
                j.appendChild(c)
            }
            this._gradient = j;
            this._defs.appendChild(j)
        }, _createDropShadow: function (i) {
            if (!this._defs) {
                this._createDefs()
            }
            if (this._dropShadow) {
                this._defs.removeChild(this._dropShadow)
            }
            var a = L.Util.guid();
            var b = this._createElement("filter");
            var j = this._createElement("feOffset");
            var f = this._createElement("feGaussianBlur");
            var g = this._createElement("feBlend");
            i = i || {width: "200%", height: "200%"};
            i.id = "filter" + a;
            var h;
            for (h in i) {
                b.setAttribute(h, i[h])
            }
            var d = {result: "offOut", "in": "SourceAlpha", dx: "2", dy: "2"};
            var e = {result: "blurOut", "in": "offOut", stdDeviation: "2"};
            var c = {"in": "SourceGraphic", in2: "blurOut", mode: "lighten"};
            for (h in d) {
                j.setAttribute(h, d[h])
            }
            for (h in e) {
                f.setAttribute(h, e[h])
            }
            for (h in c) {
                g.setAttribute(h, c[h])
            }
            b.appendChild(j);
            b.appendChild(f);
            b.appendChild(g);
            this._dropShadow = b;
            this._defs.appendChild(b)
        }, _createCustomElement: function (a, b) {
            var d = this._createElement(a);
            for (var c in b) {
                if (b.hasOwnProperty(c)) {
                    d.setAttribute(c, b[c])
                }
            }
            return d
        }, _createImage: function (a) {
            var b = this._createElement("image");
            b.setAttribute("width", a.width);
            b.setAttribute("height", a.height);
            b.setAttribute("x", a.x || 0);
            b.setAttribute("y", a.y || 0);
            b.setAttributeNS(L.Path.XLINK_NS, "xlink:href", a.url);
            return b
        }, _createPattern: function (b) {
            if (this._pattern) {
                this._defs.removeChild(this._pattern)
            }
            var a = this._createCustomElement("pattern", b);
            this._pattern = a;
            return a
        }, _createShape: function (c, b) {
            if (this._shape) {
                this._container.removeChild(this._shape)
            }
            var a = this._createCustomElement(c, b);
            return a
        }, _applyCustomStyles: function () {
        }, _createFillPattern: function (b) {
            var e = L.Util.guid();
            var d = b.pattern;
            d.id = e;
            d.patternUnits = d.patternUnits || "objectBoundingBox";
            var a = this._createPattern(d);
            var c = this._createImage(b.image);
            c.setAttributeNS(L.Path.XLINK_NS, "xlink:href", b.url);
            a.appendChild(c);
            if (!this._defs) {
                this._createDefs()
            }
            this._defs.appendChild(a);
            this._path.setAttribute("fill", "url(#" + e + ")")
        }, _getDefaultDiameter: function (a) {
            return 1.75 * a
        }, _createShapeImage: function (d) {
            d = d || {};
            var c = L.Util.guid();
            var h = this.options.radius || Math.max(this.options.radiusX, this.options.radiusY);
            var q = this._getDefaultDiameter(h);
            var j = d.imageSize || new L.Point(q, q);
            var a = d.radius || q / 2;
            var e = d.shape || {circle: {r: a, cx: 0, cy: 0}};
            var n = d.pattern || {width: j.x, height: j.y, x: 0, y: 0};
            var l = Object.keys(e);
            var g = l.length > 0 ? l[0] : "circle";
            e[g].fill = "url(#" + c + ")";
            var i = this._createShape(g, e[g]);
            if (this.options.clickable) {
                i.setAttribute("class", "leaflet-clickable")
            }
            n.id = c;
            n.patternUnits = n.patternUnits || "objectBoundingBox";
            var k = this._createPattern(n);
            d = d.image || {width: j.x, height: j.y, x: 0, y: 0, url: this.options.imageCircleUrl};
            var f = this._createImage(d);
            f.setAttributeNS(L.Path.XLINK_NS, "xlink:href", d.url);
            k.appendChild(f);
            this._defs.appendChild(k);
            this._container.insertBefore(i, this._defs);
            this._shape = i;
            var m = this;
            this._shape.addEventListener("mouseover", function () {
                m.fire("mouseover")
            });
            this._shape.addEventListener("mouseout", function () {
                m.fire("mouseout")
            });
            this._shape.addEventListener("mousemove", function () {
                m.fire("mousemove")
            });
            var o = this.getTextAnchor();
            if (this._shape && o) {
                if (this._shape.tagName === "circle" || this._shape.tagName === "ellipse") {
                    this._shape.setAttribute("cx", o.x);
                    this._shape.setAttribute("cy", o.y)
                } else {
                    var b = this._shape.getAttribute("width");
                    var p = this._shape.getAttribute("height");
                    this._shape.setAttribute("x", o.x - Number(b) / 2);
                    this._shape.setAttribute("y", o.y - Number(p) / 2)
                }
            }
        }, _updateStyle: function (b) {
            this.__updateStyle.call(this, b);
            var a = b ? b : this;
            if (a.options.stroke) {
                if (a.options.lineCap) {
                    a._path.setAttribute("stroke-linecap", a.options.lineCap)
                }
                if (a.options.lineJoin) {
                    a._path.setAttribute("stroke-linejoin", a.options.lineJoin)
                }
            }
            if (a.options.gradient) {
                a._createGradient(a.options.gradient);
                a._path.setAttribute("fill", "url(#" + a._gradient.getAttribute("id") + ")")
            } else {
                if (!a.options.fill) {
                    a._path.setAttribute("fill", "none")
                }
            }
            if (a.options.dropShadow) {
                a._createDropShadow();
                a._path.setAttribute("filter", "url(#" + a._dropShadow.getAttribute("id") + ")")
            } else {
                a._path.removeAttribute("filter")
            }
            if (a.options.fillPattern) {
                a._createFillPattern(a.options.fillPattern)
            }
            a._applyCustomStyles()
        }
    };
if (L.SVG) {
    var SVGStyleFunctions = L.Util.extend(PathFunctions, {__updateStyle: L.SVG.prototype._updateStyle});
    var SVGTextFunctions = L.Util.extend(TextFunctions, {__updatePath: L.SVG.prototype._updatePath});
    L.SVG.include(SVGStyleFunctions);
    L.SVG.include(SVGTextFunctions)
}
var LineTextFunctions = L.extend({}, TextFunctions);
LineTextFunctions.__updatePath = L.Polyline.prototype._updatePath;
LineTextFunctions.getCenter = function () {
    var c = this._latlngs, b = c.length, e, d, k, h, g, a;
    for (e = 0, d = b - 1, area = 0, lat = 0, lng = 0; e < b; d = e++) {
        k = c[e];
        h = c[d];
        g = k.lat * h.lng - h.lat * k.lng;
        lat += (k.lat + h.lat) * g;
        lng += (k.lng + h.lng) * g;
        area += g / 2
    }
    a = area ? new L.LatLng(lat / (6 * area), lng / (6 * area)) : c[0];
    a.area = area;
    return a
};
LineTextFunctions.getTextAnchor = function () {
    var a = this.getCenter();
    return this._map.latLngToLayerPoint(a)
};
L.Polyline.include(LineTextFunctions);
L.CircleMarker.include(TextFunctions);
L.Path.include(PathFunctions);
L.Polygon.include(PathFunctions);
L.Polyline.include(PathFunctions);
L.CircleMarker.include(PathFunctions);
L.CircleMarker = L.CircleMarker.extend({
    _applyCustomStyles: function () {
        if (this.options.shapeImage || this.options.imageCircleUrl) {
            this._createShapeImage(this.options.shapeImage)
        }
    }, getTextAnchor: function () {
        var a = null;
        if (this._point) {
            a = new L.Point(this._point.x, this._point.y)
        }
        return a
    }
});
L.Point.prototype.rotate = function (d, b) {
    var a = this.distanceTo(b);
    var c = (d * L.LatLng.DEG_TO_RAD) + Math.atan2(this.y - b.y, this.x - b.x);
    this.x = b.x + (a * Math.cos(c));
    this.y = b.y + (a * Math.sin(c))
};
L.MapMarker = L.Path.extend({
    includes: TextFunctions,
    initialize: function (b, a) {
        L.Path.prototype.initialize.call(this, a);
        this._latlng = b
    },
    options: {
        fill: true,
        fillOpacity: 1,
        opacity: 1,
        radius: 15,
        innerRadius: 5,
        position: {x: 0, y: 0},
        rotation: 0,
        numberOfSides: 50,
        color: "#000000",
        fillColor: "#0000FF",
        weight: 1,
        gradient: true,
        dropShadow: true,
        clickable: true
    },
    setLatLng: function (a) {
        this._latlng = a;
        return this.redraw()
    },
    projectLatlngs: function () {
        this._point = this._map.latLngToLayerPoint(this._latlng);
        this._points = this._getPoints();
        if (this.options.innerRadius > 0) {
            this._innerPoints = this._getPoints(true).reverse()
        }
    },
    getBounds: function () {
        var g = this._map, c = this.options.radius * 3, b = g.project(this._latlng), d = new L.Point(b.x - this.options.radius, b.y), f = new L.Point(b.x + this.options.radius, b.y - c), a = g.unproject(d), e = g.unproject(f);
        return new L.LatLngBounds(a, e)
    },
    getLatLng: function () {
        return this._latlng
    },
    setRadius: function (a) {
        this.options.radius = a;
        return this.redraw()
    },
    setInnerRadius: function (a) {
        this.options.innerRadius = a;
        return this.redraw()
    },
    setRotation: function (a) {
        this.options.rotation = a;
        return this.redraw()
    },
    setNumberOfSides: function (a) {
        this.options.numberOfSides = a;
        return this.redraw()
    },
    getPathString: function () {
        var c = this.getTextAnchor();
        if (this._shape) {
            if (this._shape.tagName === "circle" || this._shape.tagName === "ellipse") {
                this._shape.setAttribute("cx", c.x);
                this._shape.setAttribute("cy", c.y)
            } else {
                var b = this._shape.getAttribute("width");
                var a = this._shape.getAttribute("height");
                this._shape.setAttribute("x", c.x - Number(b) / 2);
                this._shape.setAttribute("y", c.y - Number(a) / 2)
            }
        }
        this._path.setAttribute("shape-rendering", "geometricPrecision");
        return new L.SVGPathBuilder(this._points, this._innerPoints).build(6)
    },
    getTextAnchor: function () {
        var a = null;
        if (this._point) {
            a = new L.Point(this._point.x, this._point.y - 2 * this.options.radius)
        }
        return a
    },
    _getPoints: function (l) {
        var c = !l ? 210 : 360;
        var h = !l ? c / 50 : c / Math.max(this.options.numberOfSides, 3);
        var d = !l ? c : c + this.options.rotation;
        var e = !l ? -30 : this.options.rotation;
        var i = [];
        var b;
        var j;
        var f = this.options.radius;
        var k = Math.sqrt(0.75);
        var g = function (m) {
            return m * L.LatLng.DEG_TO_RAD
        };
        var a = this._point;
        if (!l) {
            i.push(a);
            i.push(new L.Point(a.x + k * f, a.y - 1.5 * f))
        }
        while (e < d) {
            j = g(e);
            b = this._getPoint(j, f, l);
            i.push(b);
            e += h
        }
        if (!l) {
            i.push(new L.Point(a.x - k * f, a.y - 1.5 * f))
        }
        return i
    },
    _getPoint: function (d, a, b) {
        var c = a;
        a = !b ? a : this.options.innerRadius;
        return new L.Point(this._point.x + this.options.position.x + a * Math.cos(d), this._point.y - 2 * c + this.options.position.y - a * Math.sin(d))
    },
    _applyCustomStyles: function () {
        if (this.options.shapeImage || this.options.imageCircleUrl) {
            this._createShapeImage(this.options.shapeImage)
        }
    },
    toGeoJSON: function () {
        return L.Util.pointToGeoJSON.call(this)
    }
});
L.mapMarker = function (b, a) {
    return new L.MapMarker(b, a)
};
L.RegularPolygonMarker = L.Path.extend({
    includes: TextFunctions,
    initialize: function (b, a) {
        L.Path.prototype.initialize.call(this, a);
        this._latlng = b;
        this.options.numberOfSides = Math.max(this.options.numberOfSides, 3)
    },
    options: {
        fill: true,
        radiusX: 10,
        radiusY: 10,
        rotation: 0,
        numberOfSides: 3,
        position: {x: 0, y: 0},
        maxDegrees: 360,
        gradient: true,
        dropShadow: false,
        clickable: true
    },
    setLatLng: function (a) {
        this._latlng = a;
        return this.redraw()
    },
    projectLatlngs: function () {
        this._point = this._map.latLngToLayerPoint(this._latlng);
        this._points = this._getPoints();
        if (this.options.innerRadius || (this.options.innerRadiusX && this.options.innerRadiusY)) {
            this._innerPoints = this._getPoints(true).reverse()
        }
    },
    getBounds: function () {
        var a = this._map, c = this.options.radius || this.options.radiusX, b = this.options.radius || this.options.radiusY, g = c * Math.cos(Math.PI / 4), f = b * Math.sin(Math.PI / 4), j = a.project(this._latlng), h = new L.Point(j.x - g, j.y + f), d = new L.Point(j.x + g, j.y - f), i = a.unproject(h), e = a.unproject(d);
        return new L.LatLngBounds(i, e)
    },
    setRadius: function (a) {
        this.options.radius = a;
        return this.redraw()
    },
    setRadiusXY: function (b, a) {
        this.options.radius = null;
        this.options.radiusX = b;
        this.options.radiusY = a;
        return this.redraw()
    },
    setInnerRadius: function (a) {
        this.options.innerRadius = a;
        return this.redraw()
    },
    setInnerRadiusXY: function (b, a) {
        this.options.innerRadius = null;
        this.options.innerRadiusX = b;
        this.options.innerRadiusY = a;
        return this.redraw()
    },
    setRotation: function (a) {
        this.options.rotation = a;
        return this.redraw()
    },
    setNumberOfSides: function (a) {
        this.options.numberOfSides = a;
        return this.redraw()
    },
    getLatLng: function () {
        return this._latlng
    },
    getPathString: function () {
        var c = this.getTextAnchor();
        if (this._shape) {
            if (this._shape.tagName === "circle" || this._shape.tagName === "ellipse") {
                this._shape.setAttribute("cx", c.x);
                this._shape.setAttribute("cy", c.y)
            } else {
                var b = this._shape.getAttribute("width");
                var a = this._shape.getAttribute("height");
                this._shape.setAttribute("x", c.x - Number(b) / 2);
                this._shape.setAttribute("y", c.y - Number(a) / 2)
            }
        }
        this._path.setAttribute("shape-rendering", "geometricPrecision");
        return new L.SVGPathBuilder(this._points, this._innerPoints).build(6)
    },
    _getPoints: function (k) {
        var d = this.options.maxDegrees || 360;
        var h = d / Math.max(this.options.numberOfSides, 3);
        var e = d;
        var f = 0;
        var i = [];
        var c;
        var j;
        var b = !k ? this.options.radius || this.options.radiusX : this.options.innerRadius || this.options.innerRadiusX;
        var a = !k ? this.options.radius || this.options.radiusY : this.options.innerRadius || this.options.innerRadiusY;
        var g = function (l) {
            return l * L.LatLng.DEG_TO_RAD
        };
        while (f < e) {
            j = g(f);
            c = this._getPoint(j, b, a);
            i.push(c);
            f += h
        }
        return i
    },
    _getPoint: function (e, d, c) {
        var b = this.options.position ? this._point.add(new L.Point(this.options.position.x, this.options.position.y)) : this._point;
        var a = new L.Point(b.x + d * Math.cos(e), b.y + c * Math.sin(e));
        a.rotate(this.options.rotation, b);
        return a
    },
    _getDefaultDiameter: function (a) {
        var c = Math.PI / this.options.numberOfSides;
        var b = a * Math.cos(c);
        return 1.75 * b
    },
    _applyCustomStyles: function () {
        if (this.options.shapeImage || this.options.imageCircleUrl) {
            this._createShapeImage(this.options.shapeImage)
        }
    },
    toGeoJSON: function () {
        return L.Util.pointToGeoJSON.call(this)
    }
});
L.regularPolygonMarker = function (b, a) {
    return new L.RegularPolygonMarker(b, a)
};
L.StarMarker = L.RegularPolygonMarker.extend({
    options: {
        numberOfPoints: 5,
        rotation: -15,
        maxDegrees: 360,
        gradient: true,
        dropShadow: true
    }, setNumberOfPoints: function (a) {
        this.options.numberOfPoints = a;
        return this.redraw()
    }, _getPoints: function (l) {
        var d = this.options.maxDegrees || 360;
        var h = d / this.options.numberOfPoints;
        var e = d;
        var f = 0;
        var i = [];
        var c, k;
        var j;
        var b = !l ? this.options.radius || this.options.radiusX : this.options.innerRadius || this.options.innerRadiusX;
        var a = !l ? this.options.radius || this.options.radiusY : this.options.innerRadius || this.options.innerRadiusY;
        var g = function (m) {
            return m * L.LatLng.DEG_TO_RAD
        };
        while (f < e) {
            j = g(f);
            c = this._getPoint(j, b, a);
            k = this._getPoint(j + g(h) / 2, b / 2, a / 2);
            i.push(c);
            i.push(k);
            f += h
        }
        return i
    }
});
L.starMarker = function (b, a) {
    return new L.StarMarker(b, a)
};
L.TriangleMarker = L.RegularPolygonMarker.extend({options: {numberOfSides: 3, rotation: 30, radius: 5}});
L.triangleMarker = function (b, a) {
    return new L.TriangleMarker(b, a)
};
L.DiamondMarker = L.RegularPolygonMarker.extend({options: {numberOfSides: 4, radiusX: 5, radiusY: 10}});
L.diamondMarker = function (b, a) {
    return new L.DiamondMarker(b, a)
};
L.SquareMarker = L.RegularPolygonMarker.extend({options: {numberOfSides: 4, rotation: 45, radius: 5}});
L.squareMarker = function (b, a) {
    return new L.SquareMarker(b, a)
};
L.PentagonMarker = L.RegularPolygonMarker.extend({options: {numberOfSides: 5, rotation: -18, radius: 5}});
L.pentagonMarker = function (b, a) {
    return new L.PentagonMarker(b, a)
};
L.HexagonMarker = L.RegularPolygonMarker.extend({options: {numberOfSides: 6, rotation: 30, radius: 5}});
L.hexagonMarker = function (b, a) {
    return new L.HexagonMarker(b, a)
};
L.OctagonMarker = L.RegularPolygonMarker.extend({options: {numberOfSides: 8, rotation: 22.5, radius: 5}});
L.octagonMarker = function (b, a) {
    return new L.OctagonMarker(b, a)
};
L.SVGMarker = L.Path.extend({
    initialize: function (b, a) {
        L.Path.prototype.initialize.call(this, a);
        this._svg = a.svg;
        if (this._svg.indexOf("<") === 0) {
            this._data = this._svg
        }
        this._latlng = b
    }, projectLatlngs: function () {
        this._point = this._map.latLngToLayerPoint(this._latlng)
    }, setLatLng: function (a) {
        this._latlng = a;
        this.redraw()
    }, getLatLng: function () {
        return this._latlng
    }, getPathString: function () {
        var b = this;
        var a = function () {
            var k = b._path.parentNode;
            while (k.nodeName.toLowerCase() !== "g") {
                k = k.parentNode
            }
            if (b.options.clickable) {
                k.setAttribute("class", "leaflet-clickable")
            }
            var i = b._data;
            var j = i.nodeName.toLowerCase() === "svg" ? i.cloneNode(true) : i.querySelector("svg").cloneNode(true);
            if (b.options.setStyle) {
                b.options.setStyle.call(b, j)
            }
            var p = j.getAttribute("width");
            var l = j.getAttribute("height");
            var d = p ? p.replace("px", "") : "100%";
            var q = l ? l.replace("px", "") : "100%";
            if (d === "100%") {
                d = b.options.size.x;
                q = b.options.size.y;
                j.setAttribute("width", d + (String(d).indexOf("%") !== -1 ? "" : "px"));
                j.setAttribute("height", q + (String(q).indexOf("%") !== -1 ? "" : "px"))
            }
            var r = b.options.size || new L.Point(d, q);
            var f = new L.Point(r.x / d, r.y / q);
            var e = k.getElementsByTagName("svg");
            if (e.length > 0) {
                e[0].parentNode.removeChild(e[0])
            }
            k.appendChild(j);
            var m = [];
            var h = b.options.anchor || new L.Point(-r.x / 2, -r.y / 2);
            var o = b._point.x + h.x;
            var n = b._point.y + h.y;
            m.push("translate(" + o + " " + n + ")");
            m.push("scale(" + f.x + " " + f.y + ")");
            if (b.options.rotation) {
                m.push("rotate(" + b.options.rotation + " " + (d / 2) + " " + (q / 2) + ")")
            }
            k.setAttribute("transform", m.join(" "))
        };
        if (!this._data) {
            var c = new XMLHttpRequest();
            c.onreadystatechange = function () {
                if (this.readyState == 4 && this.status == 200) {
                    b._data = this.responseXML;
                    a()
                }
            };
            c.open("GET", this._svg, true);
            c.send(null)
        } else {
            a()
        }
    }, toGeoJSON: function () {
        return pointToGeoJSON.call(this)
    }
});
L.MarkerGroup = L.FeatureGroup.extend({
    initialize: function (b, a) {
        L.FeatureGroup.prototype.initialize.call(this, a);
        this.setLatLng(b)
    }, setStyle: function (a) {
        return this
    }, setLatLng: function (a) {
        this._latlng = a;
        this.eachLayer(function (b) {
            if (b.setLatLng) {
                b.setLatLng(a)
            }
        });
        return this
    }, getLatLng: function (a) {
        return this._latlng
    }, toGeoJSON: function () {
        var b = {type: "FeatureCollection", features: []};
        var a = function (c) {
            return function (d) {
                c.features.push(L.Util.pointToGeoJSON.call(d))
            }
        };
        this.eachLayer(a(b));
        return b
    }
});