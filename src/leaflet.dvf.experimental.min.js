L.SeriesMarker = L.Path.extend({
    initialize: function (b, a) {
        L.Path.prototype.initialize.call(this, a);
        L.Util.setOptions(this, a);
        this._latlng = b
    },
    options: {fill: false, size: new L.Point(80, 80), position: {x: 0, y: 0}, weight: 1, color: "#000", opacity: 1},
    setLatLng: function (a) {
        this._latlng = a;
        return this.redraw()
    },
    projectLatlngs: function () {
        this._point = this._map.latLngToLayerPoint(this._latlng);
        this._points = this._getPoints()
    },
    getBounds: function () {
        var f = this._map, b = f.project(this._latlng), c = new L.Point(b.x, b.y), e = new L.Point(b.x + this.options.size.x, b.y - this.options.size.y), a = f.unproject(c), d = f.unproject(e);
        return new L.LatLngBounds(a, d)
    },
    getLatLng: function () {
        return this._latlng
    },
    getPathString: function () {
        return new L.SVGPathBuilder(this._points, null, {closePath: this.options.fill}).build(6)
    },
    getDataPoint: function (a) {
        return _.find(this._seriesPoints, function (b) {
            return b.x === a
        })
    },
    getClosestPathPoint: function (a) {
        var g = this._points;
        var b;
        var h = -1;
        var e = _.find(g, function (k, j) {
            var i = k.x >= a;
            if (i) {
                h = j
            }
            return i
        });
        if (e) {
            if (e.x === a) {
                b = e
            } else {
                if (h > 0) {
                    var f = g[h - 1];
                    var c = Math.abs(e.x - a);
                    var d = Math.abs(f.x - a);
                    if (c < d) {
                        b = e
                    } else {
                        b = f
                    }
                }
            }
        }
        return b
    },
    getClosestPoint: function (a) {
        var g = this._seriesPoints;
        var b;
        var h = -1;
        a = this._reverseXTransform.evaluate(a);
        var e = _.find(g, function (k, j) {
            var i = k.x >= a;
            if (i) {
                h = j
            }
            return i
        });
        if (e) {
            if (e.x === a) {
                b = e
            } else {
                if (h > 0) {
                    var f = g[h - 1];
                    var c = Math.abs(e.x - a);
                    var d = Math.abs(f.x - a);
                    if (c < d) {
                        b = e
                    } else {
                        b = f
                    }
                }
            }
        }
        return b
    },
    _getPoints: function () {
        var q = this.options;
        var p = q.size;
        var e = q.xRange ? q.xRange[0] : q.minX;
        var b = q.xRange ? q.xRange[1] : q.maxX;
        var d = q.yRange ? q.yRange[0] : q.minY;
        var a = q.yRange ? q.yRange[1] : q.maxY;
        var l = new L.LinearFunction([e, 0], [b, p.x]);
        var c = new L.LinearFunction([d, 0], [a, p.y]);
        this._reverseXTransform = new L.LinearFunction([0, e], [p.x, b]);
        this._reverseYTransform = new L.LinearFunction([0, d], [p.y, a]);
        var j;
        var n, m;
        var f = q.xField || "x";
        var i = q.yField || "y";
        var o = [];
        var g = q.value;
        this._seriesPoints = [];
        for (var h in g) {
            if (g.hasOwnProperty(h)) {
                j = g[h];
                n = L.Util.getFieldValue(j, f);
                m = L.Util.getFieldValue(j, i);
                if (isNaN(n)) {
                    n = moment(n).unix()
                } else {
                    n = Number(n)
                }
                this._seriesPoints.push(new L.Point(n, m));
                n = l.evaluate(n);
                m = c.evaluate(m);
                o.push(new L.Point(this._point.x + q.position.x + n - p.x / 2, this._point.y + q.position.y - m))
            }
        }
        this._seriesPoints = _.sortBy(this._seriesPoints, function (r) {
            return r.x
        });
        o = _.sortBy(o, function (r) {
            return r.x
        });
        if (q.fill) {
            var k = c.evaluate(d);
            o.unshift(new L.Point(this._point.x + q.position.x + l.evaluate(e) - p.x / 2, this._point.y + q.position.y - k));
            o.push(new L.Point(this._point.x + q.position.x + l.evaluate(b) - p.x / 2, this._point.y + q.position.y - k))
        }
        return o
    }
});
L.Line = L.Path.extend({
    initialize: function (b, a) {
        L.Path.prototype.initialize.call(this, a);
        this._points = b
    }, getPathString: function () {
        var a = new L.SVGPathBuilder(this._points, null, {closePath: false}).build(6);
        return a
    }
});
L.SparklineMarker = L.ChartMarker.extend({
    initialize: function (b, a) {
        L.Util.setOptions(this, a);
        L.ChartMarker.prototype.initialize.call(this, b, a)
    },
    options: {
        weight: 1,
        opacity: 1,
        dataPointHighlightStyle: {
            weight: 1,
            opacity: 1,
            color: "#1E90FF",
            lineCap: "square",
            dropShadow: false,
            dashArray: [5, 2]
        }
    },
    _highlight: function (a) {
        if (a.weight) {
            a.weight *= 2
        }
        return a
    },
    _unhighlight: function (a) {
        if (a.weight) {
            a.weight /= 2
        }
        return a
    },
    _bindMouseEvents: function (c) {
        var a = this;
        var b = this.options.tooltipOptions;
        c.on("mousemove", function (t) {
            var g = this.options;
            var z = g.key;
            var p = g.value;
            var q = t.layerPoint;
            var m = q.x - this._point.x;
            var l = q.y - this._point.y;
            var v = g.iconSize;
            var w = m;
            var u = l;
            var o;
            var h = 5;
            if (g.marker) {
                a.removeLayer(g.marker)
            }
            if (g.lines) {
                _.each(g.lines, function (e) {
                    a.removeLayer(e)
                })
            }
            var f = c.getClosestPoint(m + g.position.x + a.options.size.x / 2);
            var d = c.getClosestPathPoint(q.x);
            var j = c.getBounds();
            if (f) {
                p = {x: f.x, y: f.y};
                o = new L.Point(-h, v.y + h);
                var i = {};
                var n = function (e) {
                    return '<div><div><span class="xvalue">' + e.x + '</span><span class="separator">:</span><span class="yvalue">' + e.y + "</span></div></div>"
                };
                var r = g.displayText ? g.displayText(p) : n(p);
                i[z] = {name: g.displayName, value: r};
                var s = new L.LegendIcon(i, g, {
                    className: "leaflet-div-icon",
                    iconSize: b ? b.iconSize : v,
                    iconAnchor: o
                });
                var k = a._map.layerPointToLatLng(d);
                g.marker = new L.Marker(k, {icon: s});
                g.lines = [new L.Line([new L.Point(d.x, c._point.y), new L.Point(d.x, d.y)], a.options.dataPointHighlightStyle), new L.Line([new L.Point(d.x, d.y), new L.Point(c._point.x + g.position.x - a.options.size.x / 2, d.y)], a.options.dataPointHighlightStyle)];
                a.addLayer(g.marker);
                _.each(g.lines, function (e) {
                    a.addLayer(e)
                })
            }
        });
        c.on("mouseover", function (f) {
            var d = this.options;
            d = a._highlight(d);
            this.initialize(a._latlng, d);
            this.redraw();
            this.setStyle(d)
        });
        c.on("mouseout", function (f) {
            var d = this.options;
            d = a._unhighlight(d);
            this.initialize(a._latlng, d);
            this.redraw();
            this.setStyle(d);
            if (d.lines) {
                _.each(d.lines, function (e) {
                    a.removeLayer(e)
                })
            }
            a.removeLayer(d.marker)
        })
    },
    _loadComponents: function () {
        var f = this.options.chartOptions;
        var e = this.options.data;
        var d;
        var c = this.options.size;
        var g;
        for (var b in e) {
            if (e.hasOwnProperty(b)) {
                d = e[b];
                g = f[b];
                g = L.Util.extend({}, this.options, g);
                g.xField = "0";
                g.yField = "1";
                g.key = b;
                g.value = d;
                var a = new L.SeriesMarker(this._latlng, g);
                this._bindMouseEvents(a);
                this.addLayer(a)
            }
        }
    }
});
L.SparklineDataLayer = L.ChartDataLayer.extend({
    initialize: function (b, a) {
        L.ChartDataLayer.prototype.initialize.call(this, b, a)
    }, _preProcessRecords: function (t) {
        var d;
        var l;
        var n = [Number.MAX_VALUE, Number.MIN_VALUE];
        var o = [Number.MAX_VALUE, Number.MIN_VALUE];
        var v = {};
        var g = [];
        var b = this.options.xField || "x";
        var h = this.options.yField || "y";
        var m = this.options.seriesField;
        var a = this.options.filter || this.options.includeLayer;
        var z;
        var c;
        var s = {};
        var w;
        var i;
        for (i in t) {
            if (t.hasOwnProperty(i)) {
                d = t[i];
                var e = a ? a.call(this, d) : true;
                if (e) {
                    if (m) {
                        l = L.Util.getFieldValue(d, m);
                        if (_.isObject(l)) {
                            l = _.pairs(l)
                        }
                        for (z in this.options.chartOptions) {
                            s = {};
                            var r = this.options.chartOptions[z];
                            for (w in l) {
                                if (l.hasOwnProperty(w)) {
                                    c = l[w];
                                    k = L.Util.getFieldValue(c, r.xField || b);
                                    y = L.Util.getFieldValue(c, r.yField || h);
                                    if (isNaN(k)) {
                                        k = moment(k).unix()
                                    }
                                    k = Number(k);
                                    v[k] = k;
                                    n[0] = Math.min(n[0], k);
                                    n[1] = Math.max(n[1], k);
                                    o[0] = Math.min(o[0], y);
                                    o[1] = Math.max(o[1], y);
                                    s[k] = y
                                }
                            }
                            g[i] = g[i] || d;
                            L.Util.setFieldValue(g[i], z, s)
                        }
                    } else {
                        for (z in this.options.chartOptions) {
                            l = L.Util.getFieldValue(d, z);
                            if (_.isObject(l)) {
                                l = _.pairs(l)
                            }
                            s = {};
                            var f = this.options.chartOptions[z];
                            for (w in l) {
                                if (l.hasOwnProperty(w)) {
                                    c = l[w];
                                    k = L.Util.getFieldValue(c, f.xField || b);
                                    y = L.Util.getFieldValue(c, f.yField || h);
                                    if (c.x) {
                                        k = c.x;
                                        y = c.y
                                    } else {
                                        if (_.isArray(c)) {
                                            k = c[0];
                                            y = c[1]
                                        } else {
                                            k = i;
                                            y = c
                                        }
                                    }
                                    if (isNaN(k)) {
                                        k = moment(k).unix()
                                    }
                                    k = Number(k);
                                    v[k] = k;
                                    n[0] = Math.min(n[0], k);
                                    n[1] = Math.max(n[1], k);
                                    o[0] = Math.min(o[0], y);
                                    o[1] = Math.max(o[1], y);
                                    s[k] = y
                                }
                            }
                            g[i] = g[i] || d;
                            L.Util.setFieldValue(g[i], z, s)
                        }
                    }
                }
            }
        }
        v = _.sortBy(_.keys(v), function (j) {
            return j
        });
        for (i in g) {
            var p = g[i];
            for (z in this.options.chartOptions) {
                var u = L.Util.getFieldValue(p, z);
                for (var q = 0; q < v.length; ++q) {
                    var k = v[q];
                    if (!(k in u)) {
                        u[k] = 0
                    }
                }
                L.Util.setFieldValue(g[i], z, _.chain(u).pairs().sortBy(function (j) {
                    return j
                }).value())
            }
        }
        this.options.layerOptions.minX = n[0];
        this.options.layerOptions.maxX = n[1];
        this.options.layerOptions.minY = Math.min(0, o[0]);
        this.options.layerOptions.maxY = o[1];
        this.options.xField = "0";
        this.options.yField = "1";
        return g
    }, _getMarker: function (b, a) {
        return new L.SparklineMarker(b, a)
    }
});
L.sparklineDataLayer = function (b, a) {
    return new L.SparklineDataLayer(b, a)
};
L.WordCloudMarker = L.ChartMarker.extend({
    initialize: function (b, a) {
        L.Util.setOptions(this, a);
        L.ChartMarker.prototype.initialize.call(this, b, a)
    }, options: {}, _loadComponents: function () {
    }
});
L.wordCloudMarker = function (b, a) {
    return new L.WordCloudMarker(b, a)
};
L.WordCloudDataLayer = L.ChartDataLayer.extend({
    initialize: function (b, a) {
        L.ChartDataLayer.prototype.initialize.call(this, b, a)
    }, _preProcessRecords: function (a) {
        return a
    }, _getMarker: function (b, a) {
        return new L.WordCloudMarker(b, a)
    }
});
L.wordCloudDataLayer = function (b, a) {
    return new L.WordCloudDataDataLayer(b, a)
};
L.Graph = L.DataLayer.extend({
    statics: {
        EDGESTYLE: {
            STRAIGHT: function (a, b) {
                return new L.Polyline([a, b])
            }, ARC: function (a, b) {
                return new L.ArcedPolyline([a, b])
            }
        }
    }
});
L.Graph = L.Graph.extend({
    options: {getEdge: L.Graph.EDGESTYLE.STRAIGHT}, _getLayer: function (b, c, a) {
        b.location.setStyle(c);
        return b.location
    }, _getLocation: function (d, e) {
        var m = this.options.fromField;
        var f = this.options.toField;
        var i;
        var b = L.Util.getFieldValue(d, m);
        var g = L.Util.getFieldValue(d, f);
        var h = this.options.locationMode.call(this, b, b);
        var c = this.options.locationMode.call(this, g, g);
        if (h && c) {
            var k = h.center;
            var j = c.center;
            if (k && j) {
                var l = this.options.getEdge.call(this, k, j);
                var a = new L.LatLngBounds(new L.LatLng(Math.min(k.lat, j.lat), Math.min(k.lng, j.lng)), new L.LatLng(Math.max(k.lat, j.lat), Math.max(k.lng, j.lng)));
                i = {center: a.getCenter(), location: l, text: b + " - " + g}
            }
        }
        return i
    }
});
L.WeightedLineSegment = L.Polyline.extend({
    initialize: function (b, a, c) {
        L.Polyline.prototype.initialize.call(this, c);
        L.Util.setOptions(this, c);
        this._weightedPoint1 = b;
        this._weightedPoint2 = a;
        this._latlngs = []
    }, getLatLngs: function () {
        var b = this._weightedPointToPoint(this._weightedPoint1);
        var a = this._weightedPointToPoint(this._weightedPoint2);
        var d = b[1];
        var c = a[1];
        return [this._map.layerPointToLatLng(d), this._map.layerPointToLatLng(c)]
    }, projectLatlngs: function () {
        this._points = this._getPoints();
        if (typeof this.options.fill !== "undefined" && this.options.fill && this.options.gradient) {
            this._setGradient()
        }
    }, _setGradient: function () {
        var k = this._points[1];
        var h = this._points[4];
        var c = h.x - k.x;
        var b = h.y - k.y;
        if (c !== 0 || b !== 0) {
            var a = Math.atan(b / c);
            var i = c / Math.abs(c);
            var f = b / Math.abs(b);
            k = new L.Point(50 + 50 * Math.cos(a + Math.PI), 50 + 50 * Math.sin(a + Math.PI));
            h = new L.Point(50 + 50 * Math.cos(a), 50 + 50 * Math.sin(a));
            if (i < 0) {
                var l = k;
                k = h;
                h = l
            }
            var j = this.options.weightToColor ? this.options.weightToColor.evaluate(this._weightedPoint1.lineWeight) : this._weightedPoint1.fillColor;
            var g = this.options.weightToColor ? this.options.weightToColor.evaluate(this._weightedPoint2.lineWeight) : this._weightedPoint2.fillColor;
            var e = this.options.weightToOpacity ? this.options.weightToOpacity.evaluate(this._weightedPoint1.lineWeight) : 1;
            var d = this.options.weightToOpacity ? this.options.weightToOpacity.evaluate(this._weightedPoint2.lineWeight) : 1;
            this.options.gradient = {
                vector: [[k.x.toFixed(2) + "%", k.y.toFixed(2) + "%"], [h.x.toFixed(2) + "%", h.y.toFixed(2) + "%"]],
                stops: [{offset: "0%", style: {color: j, opacity: e}}, {offset: "100%", style: {color: g, opacity: d}}]
            };
            this.setStyle(this.options)
        }
    }, _weightedPointToPoint: function (a) {
        var c = [];
        this._latlngs.push(a.latlng);
        var b = this._map.latLngToLayerPoint(a.latlng);
        var f = a.lineWeight / 2;
        var h = a.angle;
        var g = h + Math.PI;
        var e = new L.Point(b.x + Math.cos(h) * f, b.y + Math.sin(h) * f);
        var d = new L.Point(b.x + Math.cos(g) * f, b.y + Math.sin(g) * f);
        c = [e, b, d];
        return c
    }, _getPoints: function () {
        var f = [];
        var e = this._weightedPointToPoint(this._weightedPoint1);
        var d = this._weightedPointToPoint(this._weightedPoint2);
        var c = new L.LinearFunction(e[0], d[0]);
        var b = new L.LinearFunction(e[1], d[1]);
        var a = new L.LinearFunction(e[2], d[2]);
        var h = a.getIntersectionPoint(c);
        var g = new L.Bounds([].concat(e, d));
        if (h) {
            if (!g.contains(h)) {
                d = d.reverse()
            }
        } else {
            if (c._slope === a._slope) {
                d = d.reverse()
            }
        }
        f = f.concat(e, d);
        c = null;
        b = null;
        a = null;
        h = null;
        this._originalPoints = f;
        return f
    }, getBounds: function () {
        var c = new L.LatLngBounds();
        var a;
        for (var b = 0; b < this._latlngs.length; ++b) {
            c.extend(this._latlngs[b])
        }
        return c
    }, getPathString: function () {
        return new L.SVGPathBuilder(this._points, []).build(6)
    }
});
L.WeightedLineSegment.include(LineTextFunctions);
L.WeightedFlowLine = L.FlowLine.extend({
    initialize: function (b, a) {
        L.Util.setOptions(this, a);
        L.FlowLine.prototype.initialize.call(this, b, a);
        this._loaded = false
    }, _getAngle: function (g, f) {
        var d = this._map.latLngToLayerPoint(g);
        var c = this._map.latLngToLayerPoint(f);
        var b = c.x - d.x;
        var a = c.y - d.y;
        var e = Math.atan(a / b);
        return e
    }, _getAngles: function (e, c) {
        var a = this._getAngle(e, c);
        if (isNaN(a)) {
            a = 0
        }
        var d = a + Math.PI / 2;
        var b = d + Math.PI;
        return [d, b]
    }, onAdd: function (a) {
        L.FlowLine.prototype.onAdd.call(this, a);
        if (this._data && !this._loaded) {
            this._loadRecords(this._data)
        }
    }, _addLineSegment: function (f, e, c, a, h, b) {
        var d = this._getAngles(f, e);
        var j = this._getDynamicOptions(a[h[b - 1]]);
        var g = this._getDynamicOptions(a[h[b]]);
        c.push(L.extend({latlng: f, angle: (d[0] + c[c.length - 1].angle) / 2}, g.layerOptions));
        var i = new L.WeightedLineSegment(c[0], c[1], g.layerOptions);
        this.addLayer(i);
        if (this.options.showLegendTooltips) {
            this._bindMouseEvents(i, g.layerOptions, g.legendDetails)
        }
        this.onEachSegment(a[h[b - 1]], a[h[b]], i);
        return c
    }, _loadRecords: function (a) {
        if (this._map) {
            var h = [];
            var e = Object.keys(a);
            if (e.length > 0) {
                e = e.length === 1 ? e.push(e[0]) : e;
                var g = this._getLocation(a[e[0]], e[0]).center;
                var f = this._getLocation(a[e[1]], e[1]).center;
                var d = this._getAngles(g, f);
                var b = this._getDynamicOptions(a[e[0]]);
                if (d.length > 0) {
                    h.push(L.extend({latlng: g, angle: d[0]}, b.layerOptions));
                    for (var c = 1; c < e.length - 1; ++c) {
                        g = f;
                        f = this._getLocation(a[e[c + 1]], e[c + 1]).center;
                        h = this._addLineSegment(g, f, h, a, e, c);
                        h = h.slice(1)
                    }
                    g = f;
                    f = this._getLocation(a[e[e.length - 1]]).center;
                    this._addLineSegment(g, f, h, a, e, e.length - 1)
                }
                this._loaded = true
            }
        }
    }
});
L.WeightedPolyline = L.FeatureGroup.extend({
    initialize: function (a, b) {
        L.FeatureGroup.prototype.initialize.call(this, b);
        L.Util.setOptions(this, b);
        this._latlngs = a
    }, onAdd: function (a) {
        L.LayerGroup.prototype.onAdd.call(this, a);
        this._loadComponents()
    }, getBounds: function () {
        var a = new L.LatLngBounds();
        this.eachLayer(function (b) {
            a.extend(b.getBounds ? b.getBounds() : b.getLatLng())
        });
        return a
    }, setLatLngs: function (a) {
        this._latlngs = a;
        this._loadComponents();
        this.redraw()
    }, getLatLngs: function () {
        return this._latlngs
    }, options: {weightToColor: new L.HSLHueFunction([0, 120], [20, -30])}, _getAngle: function (g, f) {
        var d = this._map.latLngToLayerPoint(g);
        var c = this._map.latLngToLayerPoint(f);
        var b = c.x - d.x;
        var a = c.y - d.y;
        var e = Math.atan(a / b);
        return e
    }, _getAngles: function (e, c) {
        var a = this._getAngle(e, c);
        if (isNaN(a)) {
            a = 0
        }
        var d = a + Math.PI / 2;
        var b = d + Math.PI;
        return [d, b]
    }, _loadComponents: function () {
        var e = [];
        var d = this._latlngs[0];
        var c = this._latlngs[1];
        var b = this._getAngles(d, c);
        if (b.length > 0) {
            e.push({latlng: d, angle: b[0], lineWeight: d.weight});
            for (var a = 1; a < this._latlngs.length - 1; ++a) {
                d = this._latlngs[a];
                c = this._latlngs[a + 1];
                b = this._getAngles(d, c);
                e.push({latlng: d, angle: b[0], lineWeight: d.weight});
                this.addLayer(new L.WeightedLineSegment(e[0], e[1], this.options));
                e = e.slice(1)
            }
            d = L.extend({}, c);
            c = this._latlngs[this._latlngs.length - 1];
            e.push({latlng: d, angle: e[0].angle, lineWeight: c.weight});
            this.addLayer(new L.WeightedLineSegment(e[0], e[1], this.options))
        }
    }
});
L.weightedPolyline = function (a, b) {
    return new L.WeightedPolyline(a, b)
};
L.StackedPieChartMarker = L.ChartMarker.extend({
    initialize: function (b, a) {
        L.Util.setOptions(this, a);
        L.ChartMarker.prototype.initialize.call(this, b, a)
    },
    options: {
        weight: 1,
        opacity: 1,
        color: "#000",
        fill: true,
        radius: 10,
        rotation: 0,
        numberOfSides: 50,
        mouseOverExaggeration: 1.2,
        maxDegrees: 360,
        iconSize: new L.Point(50, 40)
    },
    _loadComponents: function () {
        var p;
        var n = 0;
        var z = 1;
        var b = 0;
        var v = 0;
        var l = 0;
        var f = this.options.radius;
        var k = this.options.barThickness;
        var w = this.options.maxDegrees || 360;
        var g = 0;
        var u;
        var d = this.options;
        var h;
        var x = this.options.data;
        var r = this.options.chartOptions;
        var e;
        var A;
        var a = function (B, i) {
            var j = 0;
            if (B[i]) {
                j = parseFloat(B[i])
            }
            return j
        };
        var s;
        var q = 0;
        var c = [];
        var o = [];
        var m;
        for (A in x) {
            p = a(x, A);
            m = 0;
            for (s = 0; s < x[A].length; ++s) {
                p = parseFloat(x[A][s]);
                m += p
            }
            c.push(m);
            o.push(d.barThickness / m);
            n = (n > m) ? n : m;
            b += d.values[q];
            ++q
        }
        z = d.barThickness / n;
        if (b > 0) {
            circle = new L.CircleMarker(this._latlng, {
                color: d.color,
                radius: k,
                fillColor: d.fillColor,
                fill: true,
                iconSize: new L.Point(50, 40)
            });
            this._bindMouseEvents(circle);
            this.addLayer(circle);
            q = 0;
            for (A in x) {
                m = 0;
                l = d.values[q] / b;
                v = l * w;
                d.startAngle = g;
                d.endAngle = g + v;
                for (s = 0; s < x[A].length; ++s) {
                    p = parseFloat(x[A][s]);
                    m += p;
                    d.radius = m * o[q];
                    d.barThickness = p * o[q];
                    e = r[A];
                    d.fillColor = this.options.fillColors[s];
                    if (d.fillColor == "transparent") {
                        d.fillOpacity = 0
                    } else {
                        d.fillOpacity = 1
                    }
                    d.color = e.color || "#000";
                    d.radiusX = d.radius;
                    d.radiusY = d.radius;
                    d.rotation = 0;
                    d.key = A + " " + s;
                    d.value = p;
                    d.displayName = e.displayName;
                    d.displayText = e.displayText;
                    u = new L.RadialBarMarker(this._latlng, d);
                    this._bindMouseEvents(u);
                    this.addLayer(u)
                }
                g = d.endAngle;
                q++
            }
            var t = function (i) {
                return parseInt(100 * i) + "%"
            };
            for (s = 0.2; s < 1; s += 0.2) {
                circle = new L.CircleMarker(this._latlng, {
                    value: s,
                    color: d.color,
                    radius: k * s,
                    weight: 1,
                    dashArray: [5, 5],
                    fill: false,
                    iconSize: new L.Point(50, 40),
                    displayName: "percent",
                    displayText: t
                });
                this._bindMouseEvents(circle);
                this.addLayer(circle)
            }
        }
    }
});
L.stackedPieChartMarker = function (b, a) {
    return new L.StackedPieChartMarker(b, a)
};
L.LayeredRegularPolygonMarker = L.MarkerGroup.extend({
    options: {levels: 2, numberOfSides: 50}, setStyle: function (k) {
        k.levels = k.levels || 2;
        var f = [];
        var d = k.radiusX || k.radius;
        var b = k.radiusY || k.radius;
        var h = d / (0.75 * k.levels);
        var a = b / (0.75 * k.levels);
        var c = L.extend({}, k);
        d = d + (k.levels - 1) * h;
        b = b + (k.levels - 1) * a;
        var j = k.fillOpacity || 0.5;
        var e = k.fillOpacity / (1.5 * k.levels);
        j = j - k.levels * e;
        for (var g = 0; g < k.levels; ++g) {
            c.radius = 0;
            c.radiusX = d;
            c.radiusY = b;
            c.fillOpacity = j;
            this._markers[g].setStyle(c);
            d -= h;
            b -= a;
            j += e
        }
        return this
    }, initialize: function (e, l) {
        L.Util.setOptions(this, l);
        l.levels = l.levels || 2;
        var g = [];
        var d = l.radiusX || l.radius;
        var b = l.radiusY || l.radius;
        var j = d / (0.75 * l.levels);
        var a = b / (0.75 * l.levels);
        var c = L.extend({}, l);
        d = d + (l.levels - 1) * j;
        b = b + (l.levels - 1) * a;
        var k = l.fillOpacity || 0.5;
        var f = l.fillOpacity / (1.5 * l.levels);
        k = k - l.levels * f;
        for (var h = 0; h < l.levels; ++h) {
            c.radius = 0;
            c.radiusX = d;
            c.radiusY = b;
            c.fillOpacity = k;
            g.push(new L.RegularPolygonMarker(e, c));
            d -= j;
            b -= a;
            k += f
        }
        this._markers = g;
        L.MarkerGroup.prototype.initialize.call(this, e, g)
    }
});